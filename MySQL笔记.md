#### MySQL学习笔记

#### 1. MySQL基础
1. MySQL的客户端／服务器架构
   - MySQL由客户端，服务器组成
   - 本质上都算是计算机上的一个进程，服务器程序的进程又称 MySQL数据库实例
   - mysql，mysqld
2. MySQL安装与启动
   - 安装
    ubuntu：apt-get安装，完全卸载看CSDN文章
   - 服务器启动
    _service mysql start_
    _service mysql stop_
   - 客户端启动
    _mysql -hlocalhost -uroot -ps_
3. 客户端与服务器连接的过程
   - 本质上是一个进程间通信的过程
   - 通信方式
    TCP/IP:跨网络，默认端口3306
    命名管道,共享内存,Unix域套接字文件：同一台主机
   - 步骤：连接管理，解析与优化，存储引擎
     - 连接管理
        服务器用线程来与客户端交互，客户端断开连接时，缓存该线程，可下次分配给新服务，这样就不频繁创建和销毁线程，节省开销。
     - 解析与优化
        查询缓存：缓存刚刚处理过的查询请求和结果，下次完全一样就重用数据。维护开销大不推荐使用
        语法解析：要查询什么，有无语法错误
        查询优化：外连接转换为内连接、表达式简化、子查询转为连接等等
     - 存储引擎
        调用APL查询。不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。
4. 存储引擎
   - 默认InnoDB
   - _SHOW ENGINES;_
   - 不同的表可以设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式
5. 启动选项
   - 命令行启动添加选项
   - 配置文件中使用选项：/etc/mysql/my.cnf, ~/.my.cnf
   - 优先级 前者 > 后者
6. 系统变量
   - _SHOW VARIABLES [LIKE 匹配的模式]_
   - 通过命令行添加启动选项
   - 通过命令行添加启动选项
   - 服务器程序运行过程中设置
        GLOBAL: *SET GLOBAL default_storage_engine = MyISAM;*
        SESSION: *SET SESSION default_storage_engine = MyISAM;*
        *SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];*
   - 有些只有GLOBAL或者SESSION，有些是只读
   - 有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置
7. 状态变量
   - 关于程序运行状态的变量
   - *SHOW [GLOBAL|SESSION]STATUS LIKE 'thread%';*
8. 字符集和比较规则
   - 解码，编码
   - 一些字符集
      ASCII：128，1
      utf8：变长编码方式，1 ~ 4
      MySQL: utf8mb3: 1 ~ 3
   - *SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];*
   - *SHOW COLLATION [LIKE 匹配的模式];*
   - 每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则。修改任何一方都会变化
   - 四个级别的字符集和比较规则
        服务器级别：*SHOW VARIABLES LIKE 'character_set_database';*
        数据库级别
        表级别
        列级别
   - 字符集的转换：*SET NAMES 字符集名;*
   - 应用
        可以根据这个列的类型来确定存储数据时每个列的实际数据占用的存储空间大小
        比较字符串大小的表达式以及对某个字符串列进行排序

#### 2. InnoDB记录结构
1. InnoDB将数据存储到磁盘上，在内存中处理数据，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。
2. 页是 MySQL 中磁盘和内存交互的基本单位，也是 MySQL 是管理存储空间的基本单位。
3. 行格式
   - CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
   - ALTER TABLE 表名 ROW_FORMAT=行格式名称
4. COMPACT行格式
   - 记录的真实数据
   - 记录的额外信息：变长字段长度列表，NULL值列表，记录头信息
   - 变长字段长度列表
       - VARCHAR(M)，存储多少字节的数据是不固定的
       - 1，2字节表示一列数据
       - 只存储值为 非NULL 的列内容占用的长度
       - 如果列采用变长字符集也要存储       
   - NULL值列表
       - 主键列、被 NOT NULL 修饰的列都是不可以存储 NULL 值
       - 每个允许存储 NULL 的列对应一个二进制位
       - 对于非可变但为空的，不存储
       - 对于非可变但没填满的，剩余空间都用空格字符填满，如CHAR(10)，为了防止更新数据时再中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片 
   - 记录的真实数据
       - 隐藏列
            row_id：没有主键时定义，唯一标识一条记录
            transaction_id：事务ID
            roll_pointer: 回滚指针
5. Redundant行格式
   - 5.0以前老格式
   - 字段长度偏移列表（NULL比特位记录NULL值）
   - 记录头信息
   - 记录的真实数据
6. 行溢出数据
   - 一条记录占用的最大存储空间
        一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节
   - 行溢出（>16KB即页）
      - Compact，Reduntant
        记录的真实数据 处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后 记录的真实数据 处用20个字节存储指向这些页的地址（溢出页）
7. Dynamic和Compressed行格式
   - 和Compact行格式类似，但是行溢出时把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址
   - Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间

#### 3. InnoDB索引页结构
1. 存放记录的页为索引页（Index Page）
2. InnoDB索引页构成（Header 和 Trailer 所有类型页通用）
    File Header 文件头部 38 字节 页的一些通用信息
    Page Header 页面头部 56 字节 索引页专有的一些信息
    Infimum + Supremum 最小记录和最大记录 26 字节 两个虚拟的行记录
    User Records 用户记录 不确定 实际存储的行记录内容
    Free Space 空闲空间 不确定 页中尚未使用的空间
    Page Directory 页面目录 不确定 页中的某些记录的相对位置
    File Trailer 文件尾部 8 字节 校验页是否完整  
3. 记录头信息
    delete_mask  标记该记录是否被删除
    min_rec_mask  B+树的每层非叶子节点中的最小记录都会添加该标记
    n_owned  表示当前记录拥有的记录数
    heap_no  表示当前记录在记录堆的位置信息
    record_type  表示当前记录的类型， 0 表示普通记录， 1 表示B+树非叶节点记录， 2 表示最小记录， 3表示最大记录
    next_record  表示下一条记录的相对位置
4. next_record
    - 下一条记录 指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）
    - 记录按照主键从小到大的顺序形成了一个单链表
    - 为什么要指向记录头信息和真实数据之间的位置呢？而不是指向整条记录的开头位置?向左读取就是记录头信息，向右读取就是真实数据,并且逆序记录，能提高高速缓存的命中率
5. 删除一条记录时会发生什么？
    记录并没有从存储空间中移除，而是把该条记录的 delete_mask 值设置为 1 
    记录的 next_record 值变为了0，意味着该记录没有下一条记录了
    上一条记录的 next_record 指向了下一条记录
    最大记录 的 n_owned 值减小
6. 删除多条记录时会发生什么？
    当索引页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间
7. Page Directory页目录
   - 记录分组
     - 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组
     - 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该组内拥有多少条记录
     - 每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，即页目录，这些地址偏移量被称为槽，页面目录就是由 槽 组成的
     - 最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间
8. 在一个索引页中查找指定主键值的记录时会发生什么？
   - 通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录（计算中间槽位置，查看对应主键值再比较）
   - 通过记录的 next_record 属性遍历该槽所在的组中的各个记录
9. Page Header 页面头部
   - 转码针对索引页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等
10. File Header文件头部
   - 针对各种页都通用的一些状态信息
   - FIL_PAGE_SPACE_OR_CHKSUM
        校验和
   - FIL_PAGE_PREV 和 FIL_PAGE_NEXT
        双向链表，多个不连续的页关联起来，并不是所有类型的页都有上一个和下一个页的属性
11. File Trailer 文件尾部
    - 校验和
        每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为 File Header 在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在 File Header 中的校验和就代表着已经修改过的页，而在 File Trialer 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。
    - 页面被最后修改时对应的日志序列位置（LSN）

#### 4. B+树索引
1. 数据页建立规则
    下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不连续。（通过File Header内的两个指针确定顺序）
2. 页分裂
    在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。
3. 目录项
    - 为了快速定位目标页，我们需要给它们做个目录，每个页对应一个目录项
    - 页的用户记录中最小的主键值，用 key 来表示
    - 页号，用 page_no 表示
4. InnoDB的索引方案
   - 目录项记录
        复用数据页来存储目录项
   - 头信息内record_type区分
        0 ：普通的用户记录
        1 ：目录项记录
        2 ：最小记录
        3 ：最大记录
5. 目录项记录和普通的用户记录有什么不同？
   - 头信息的record_type不同
   - 目录项记录只有主键值和页的编号两个列（还有头信息），而普通的用户记录的列有很多列
   - 只有在存储 目录项记录 的页中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 
6. 为什么要将目录项存储在页内？
   - InnoDB最大连续存储空间为16KB
   - 增删时，需要移动所有目录项
7. 根据主键值查找一条用户记录需要哪些步骤？（多次二分法）
   -  确定目录项记录页
   -  通过目录项记录页确定用户记录真实所在的页
   -  在真实存储用户记录的页中定位到具体的记录
8. B+ 树
   - 多级目录
   - 实际用户记录其实都存放在B+树的最底层的节点上
   - 一般不会超过4层
9. 聚簇索引
   - 拥有以下两种特性的B+树为聚簇索引
   - 使用记录主键值的大小进行记录和页的排序
        页，存放用户记录的页，以及存放目录项记录的页都是按照主键大小排序
   - B+ 树的叶子节点存储的是完整的用户记录
   - InnoDB 存储引擎会自动的为我们创建聚簇索引，聚簇索引就是数据的存储方式，即索引即数据，数据即索引
10. InnoDB数据的存储方式是什么？
    B+树，或者说拥有以上特性的聚簇索引
11. 二级索引
    - 以非主键的列作为搜索条件
    - 与聚簇索引的不同
      - 使用记录非主键列的大小进行记录和页的排序
      - B+ 树的叶子节点存储的并不是完整的用户记录，而只是 非主键列+主键 这两个列的值
      - 目录项记录中不再是 主键+页号 的搭配，而变成了 索引列+主键+页号 的搭配
12. 非主键列的记录查询与主键列记录查询有什么不同？
    - 确定 目录项记录 页
    - 通过 目录项记录 页确定用户记录真实所在的页
    - 在真实存储用户记录的页中定位到具体的记录
    - 再根据主键值去聚簇索引中再查找一遍完整的用户记录，得到完整的数据记录
    - 即需要回标，建立两颗B+树
13. 为什么非主键B+树不把完整的用户记录放到叶子节点？
    浪费存储空间
14. 联合索引
    - 本质上也是二级索引，把各个记录和页按照 c1 列进行排序，在记录的 c2 列相同的情况下，采用 c2 列进行排序
    - 目录项记录为c1，c2,页号
    - 叶子节点处为：c1,c2，主键
    - 注意只建立一颗B+树
15. 为空表创建B+树索引会发生什么?
    - 先创建一个 根节点 页面，既没有用户记录，也没有目录项记录
    - 随后向表中插入用户记录时，先把用户记录存储到这个 根节点 中
    - 根节点页满时，会将 根节点 中的所有记录复制到一个新分配的页，再对这个新页进行 页分裂 的操作。这时新插入的记录根据键值分配到新页中，根节点 便升级为存储目录项记录的页
    - 一个B+树索引的根节点自诞生之日起，便不会再移动
16. 内节点中目录项记录的唯一性
    - 聚簇索引由于存在主键自动满足
    - 对于二级索引，要求其内节点的目录项记录的内容由三个部分构成，索引列的值，主键值，页号。否则当两个目录页索引列值相同时，新记录就不知道往哪插入了
17. 一个页面最少存储2条记录
    B+树本质上就是一个大的多层级目录，如果每个页面只放一个记录相当于一个大目录只放一个子目录会导致目录层级非常多
18. MyISAM的索引方案
    - 也是使用树形结构，但将数据和索引分开
    - 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为 数据文件
    - 单独为表的主键创建一个索引储存到索引文件中，在索引的叶子节点中存储的是主键值+行号 的组合。先通过索引找到对应的行号，再通过行号去找对应的记录
    - 相当于MyISAM 中建立的索引相当于全部都是二级索引
    -  非主键索引叶子节点存储的为相应的列 + 行号
19. 创建和删除索引
    - *ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);*
    - *ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;*
    - *PRIMARY KEY(c1)*
    - *INDEX idx_c2_c3 (c2, c3)*
20. 索引的缺点
    - 空间上的代价
        每建立一个索引都要为它建立一棵 B+ 树
    - 时间上的代价
        为了满足B+ 树每层节点都是按照索引列的值从小到大的顺序排序，所以每次对表中的数据进行增、删、改操作时，存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序
    - 一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差
21. B+树索引适用的条件：用于查找(WHERE)
    - 例，表INFO,主键为A，而B,C,D列组成联合索引
    - 一般原则
        如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列
    - 全值匹配
        SELECT * FROM INFO WHERE B = '' AND C = '' AND D = '';
        可以用到所有索引
    - 匹配左边的列
        SELECT * FROM INFO WHERE B = '' AND C = ''
        可以用到索引
        SELECT * FROM INFO WHERE C = ''
        用不到索引，因为这个索引是先按照B排序的，B值不同的记录中C可能是无序的
    - 匹配列前缀
        一般的比较规则都是逐个比较字符的大小
        SELECT * FROM INFO WHERE B LIKE 'As%'
        可以用到
        SELECT * FROM INFO WHERE B LIKE '%As%
        用不到
        如果要查询后缀且用到索引，那么就需要将表中的数据全部逆序存储一下，再查找
    - 匹配范围值
        如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+ 树索引
        SELECT * FROM INFO WHERE B > 'Asa' AND B < 'Barlow' AND C > '1980-01-01';
        因为这个索引是先按照B排序的，B值不同的记录中C可能是无序的
    - 精确匹配某一列并范围匹配另外一列
        对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找
        SELECT * FROM INFO WHERE B = 'Asa' AND C > '1980-01-01a' AND C < '1982-01-01' ;
22. 用于排序(ORDER BY)
    - 文件排序
        - 在内存中或者磁盘上进行排序的方式。一般情况下，记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，当查询的结果集太大以至于不能在内存中进行排序的话，要借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端
        - 有相应索引时，由于 B+ 树索引本身就是按照规则排好序的，所以直接从索引中提取数据，然后进行 回表 操作取出该索引中不包含的列
    - 使用联合索引排序
        不能颠倒顺序
        匹配索引左边的列的形式可以使用部分的 B+ 树索引
        当联合索引左边列的值为常量，也可以使用后边的列进行排序 
        SELECT * FROM INFO WHERE B = 'A' ORDER BY B, C LIMIT 10
    - 不可以使用索引进行排序的几种情况
        - ASC、DESC混用
            SELECT * FROM INFO ORDER BY B, C DESC LIMIT 10;
            不能高校使用索引，规定使用联合索引的各个排序列的排序顺序必须是一致的
        - WHERE子句中出现非排序使用到的索引列
        - 排序列包含非同一个索引的列
        - 排序列使用了复杂的表达式    
            索引列是以单独列的形式出现，而不是（函数）修饰过的形式
23. 用于分组(GROUP BY)
    和使用 B+ 树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组
24. 回表的代价
    - 顺序I/O
        idx_B_C_D, B的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中
    - 随机I/O
        回表时，叶子节点里的主键并不一定连续，可能分布在不同的数据页中
    - idx_B_C_D查询的特点
        会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引
        访问二级索引使用 顺序I/O ，访问聚簇索引使用 随机I/O 
    - 需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描(聚簇索引)也不使用 二级索引，如要查询的数据占比较高时
25. 查询优化器
    - 查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 二级索引 + 回表 的方式
    - 添加了 LIMIT 的查询更容易让优化器采用 二级索引 + 回表 的方式进行查询
26. 覆盖索引
    最好在查询列表里只包含索引列，省去了 回表 操作带来的性能损耗。
    很不鼓励用 * 号作为查询列表，最好把我们需要查询的列依次标明。
27. 建立索引时的注意事项
    - 只为用于搜索、排序或分组的列创建索引
    - 考虑列的基数
        列的基数 指的是某一列中不重复数据的个数。在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。例如基数为1，则所有值都一样就无法排序，无法进行快速查找。而且可能还要回表
    - 索引列的类型尽量小
        数据类型越小，在查询时进行的比较操作越快
        数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率
        对于表的主键来说更加适用
    - 索引字符串值的前缀
        只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。
        索引列前缀的方式无法支持使用索引排序
    - 让索引列在比较表达式中单独出现
        如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的
        WHERE my_col * 2 < 4     
    - 主键插入顺序
        主键插入如果忽大忽小如1，5，15，35...，假设某个数据页存储的记录已经满了，再插入会导致页面分裂和记录移位即性能损耗
        让主键具有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入
    - 冗余和重复索引

#### 8. MySQL的数据目录
1. 数据库和文件系统
    像 InnoDB 、 MyISAM 这样的存储引擎都是把表存储在文件系统，即磁盘上的
2. 数据目录
    数据目录 是用来存储 MySQL 在运行过程中产生的数据
    SHOW VARIABLES LIKE 'datadir'
3. 数据库以及表在文件系统中的表示（数据目录内）
    - db.opt
         该数据库的各种属性，比方说该数据库的字符集和比较规则
    - 表名.frm
         表结构的定义, 视图（查询语句生成的虚拟表）结构的定义
    - ibdata1
        系统表空间, 自动扩展
    - 表名.ibd
        独立表空间
    - MyISAM
        test.frm： 表结构
        test.MYD： 数据
        test.MY：  索引文件
    - 其他文件
        服务器进程文件
        服务器日志文件
        默认/自动生成的SSL和RSA证书和密钥文件
4. 文件系统对数据库的影响
   - 数据库名称和表名称不得超过文件系统所允许的最大长度
   - 特殊字符：MySQL 会把数据库名和表名中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 @+编码值 的形式作为文件名
   - 文件长度受文件系统最大长度限制
5. MySQL系统数据库
   - mysql
        存储了MySQL的用户账户和权限信息，一些日志信息等
   - information_schema
        所有其他数据库的信息，如有哪些表、哪些视图、哪些索引等等
   - performance_schema
        性能监控，保存MySQL服务器运行过程中的一些状态信息，如内存使用状况
   - sys
        information_schema与performance_schema的视图，方便查看


#### 9. InnoDB的表空间
1. 区（extent）
   - 连续的64个页就是一个 区 ，也就是说一个区默认占用1MB空间大小
   - 256个区被划分成一组
   - 每个组的最开始的几个页面类型是固定的
2. 为什么要有区的概念
    B+ 树的每一层中的页都会形成一个双向链表，如果链表中相邻的两个页物理位置离得非常远，则查询效率很低，我们应该尽量让链表中相邻的页的物理位置也相邻。所以在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照 区 为单位分配
3. 段（segment）
   - 段是以区为单位申请存储空间的， 更精确的应该是某些零散的页面以及一些完整的区的集合
   - 分为叶子节点段，非叶子节点段
4. 为什么要有段的概念
   - 查找扫描的是B+树的叶子节点，需要区分叶子节点和非叶子节点。否则范围扫描效果很低。
5. 碎片区
   - 默认情况下一个使用 InnoDB 存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间
   - 为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于
   - 碎片区直属于表空间，并不属于任何一个段
6. 区的分类
    FREE 空闲的区
    FREE_FRAG 有剩余空间的碎片区
    FULL_FRAG 没有剩余空间的碎片区
    FSEG 附属于某个段的区
    FREE、FREE_FRAG、FULL_FRAG直属于表空间，FSEG属于某个段
7.  XDES Entry结构
    - 每个区都对应着一个 XDES Entry 结构， 记录了对应的区的一些属性
6. 为某个段分配存储空间的策略
   - 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的
   - 当某个段已经占用了32个碎片区（半个区）页面之后，就会以完整的区为单位来分配存储空间
8. XDES Entry的作用
    - 向段中插入数据的时候我们要分辨出哪些区是空闲碎片区或者满碎片区或者完整的区，XDES Entry内的节点组成不同区的链表，如FREE 链表， FREE_FRAG 链表，FULL_FRAG 链表。当我们想插入某一类型的区时就不需要遍历所有的区，只需要找到对应链表的节点来插入数据即可。
    - 表示那个区属于那个段，以便为数据分配段
9. 如何知道哪个区属于哪个段？
    不同索引有不同的段，根据XDES内的段号区分，而属于某个段的区也分为空闲，未满，满三种，所以也要建立对应的列表。