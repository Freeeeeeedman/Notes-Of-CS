#### MySQL学习笔记

#### 1. MySQL基础
1. MySQL的客户端／服务器架构
   - MySQL由客户端，服务器组成
   - 本质上都算是计算机上的一个进程，服务器程序的进程又称 MySQL数据库实例
   - mysql，mysqld
2. MySQL安装与启动
   - 安装
    ubuntu：apt-get安装，完全卸载看CSDN文章
   - 服务器启动
    _service mysql start_
    _service mysql stop_
   - 客户端启动
    _mysql -hlocalhost -uroot -p_
3. 客户端与服务器连接的过程
   - 本质上是一个进程间通信的过程
   - 通信方式
    TCP/IP:跨网络，默认端口3306
    命名管道,共享内存,Unix域套接字文件：同一台主机
   - 步骤：连接管理，解析与优化，存储引擎
     - 连接管理
        服务器用线程来与客户端交互，客户端断开连接时，缓存该线程，可下次分配给新服务，这样就不频繁创建和销毁线程，节省开销。
     - 解析与优化
        查询缓存：缓存刚刚处理过的查询请求和结果，下次完全一样就重用数据。维护开销大不推荐使用
        语法解析：要查询什么，有无语法错误
        查询优化：外连接转换为内连接、表达式简化、子查询转为连接等等
     - 存储引擎
        调用API查询。不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。
4. 存储引擎
   - 默认InnoDB
   - _SHOW ENGINES;_
   - 不同的表可以设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式
5. 启动选项
   - 命令行启动添加选项
   - 配置文件中使用选项：/etc/mysql/my.cnf, ~/.my.cnf
   - 优先级 前者 > 后者
6. 系统变量
   - _SHOW VARIABLES [LIKE 匹配的模式]_
   - 通过命令行添加启动选项
   - 服务器程序运行过程中设置
        GLOBAL: *SET GLOBAL default_storage_engine = MyISAM;*
        SESSION: *SET SESSION default_storage_engine = MyISAM;*
        *SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];*
   - 有些只有GLOBAL或者SESSION，有些是只读
   - 有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置
7. 状态变量
   - 关于程序运行状态的变量
   - *SHOW [GLOBAL|SESSION]STATUS LIKE 'thread%';*
8. 字符集和比较规则
   - 解码，编码
   - 一些字符集
      ASCII：128，1
      utf8：变长编码方式，1 ~ 4
      MySQL: utf8mb3: 1 ~ 3
   - *SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];*
   - *SHOW COLLATION [LIKE 匹配的模式];*
   - 每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则。修改任何一方都会变化
   - 四个级别的字符集和比较规则
        服务器级别：*SHOW VARIABLES LIKE 'character_set_database';*
        数据库级别
        表级别
        列级别
   - 字符集的转换：*SET NAMES 字符集名;*
   - 应用
        可以根据这个列的类型来确定存储数据时每个列的实际数据占用的存储空间大小
        比较字符串大小的表达式以及对某个字符串列进行排序

#### 2. InnoDB记录结构
1. InnoDB将数据存储到磁盘上，在内存中处理数据，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。
2. 页是 MySQL 中磁盘和内存交互的基本单位，也是 MySQL 是管理存储空间的基本单位。
3. 行格式
   - CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
   - ALTER TABLE 表名 ROW_FORMAT=行格式名称
4. COMPACT行格式
   - 记录的真实数据
   - 记录的额外信息：变长字段长度列表，NULL值列表，记录头信息
   - 变长字段长度列表
       - VARCHAR(M)，存储多少字节的数据是不固定的
       - 1，2字节表示一列数据
       - 只存储值为 非NULL 的列内容占用的长度
       - 如果列采用变长字符集也要存储       
   - NULL值列表
       - 主键列、被 NOT NULL 修饰的列都是不可以存储 NULL 值
       - 每个允许存储 NULL 的列对应一个二进制位
       - 对于非可变但为空的，不存储
       - 对于非可变但没填满的，剩余空间都用空格字符填满，如CHAR(10)，为了防止更新数据时再中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片 
   - 记录的真实数据
       - 隐藏列
            row_id：没有主键时定义，唯一标识一条记录
            transaction_id：事务ID
            roll_pointer: 回滚指针
5. Redundant行格式
   - 5.0以前老格式
   - 字段长度偏移列表（NULL比特位记录NULL值）
   - 记录头信息
   - 记录的真实数据
6. 行溢出数据
   - 一条记录占用的最大存储空间
        一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节
   - 行溢出（>16KB即页）
      - Compact，Reduntant
        记录的真实数据 处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后 记录的真实数据 处用20个字节存储指向这些页的地址（溢出页）
7. Dynamic和Compressed行格式
   - 和Compact行格式类似，但是行溢出时把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址
   - Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间

#### 3. InnoDB索引页结构
1. 存放记录的页为索引页（Index Page）
2. InnoDB索引页构成（Header 和 Trailer 所有类型页通用）
    File Header 文件头部 38 字节 页的一些通用信息
    Page Header 页面头部 56 字节 索引页专有的一些信息
    Infimum + Supremum 最小记录和最大记录 26 字节 两个虚拟的行记录
    User Records 用户记录 不确定 实际存储的行记录内容
    Free Space 空闲空间 不确定 页中尚未使用的空间
    Page Directory 页面目录 不确定 页中的某些记录的相对位置
    File Trailer 文件尾部 8 字节 校验页是否完整  
3. 记录头信息
    delete_mask  标记该记录是否被删除
    min_rec_mask  B+树的每层非叶子节点中的最小记录都会添加该标记
    n_owned  表示当前记录拥有的记录数
    heap_no  表示当前记录在记录堆的位置信息
    record_type  表示当前记录的类型， 0 表示普通记录， 1 表示B+树非叶节点记录， 2 表示最小记录， 3表示最大记录
    next_record  表示下一条记录的相对位置
4. next_record
    - 下一条记录 指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）
    - 记录按照主键从小到大的顺序形成了一个单链表
    - 为什么要指向记录头信息和真实数据之间的位置呢？而不是指向整条记录的开头位置?向左读取就是记录头信息，向右读取就是真实数据,并且逆序记录，能提高高速缓存的命中率
5. 删除一条记录时会发生什么？
    记录并没有从存储空间中移除，而是把该条记录的 delete_mask 值设置为 1 
    记录的 next_record 值变为了0，意味着该记录没有下一条记录了
    上一条记录的 next_record 指向了下一条记录
    最大记录 的 n_owned 值减小
6. 删除多条记录时会发生什么？
    当索引页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间
7. Page Directory页目录
   - 记录分组
     - 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组
     - 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该组内拥有多少条记录
     - 每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，即页目录，这些地址偏移量被称为槽，页面目录就是由 槽 组成的
     - 最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间
8. 在一个索引页中查找指定主键值的记录时会发生什么？
   - 通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录（计算中间槽位置，查看对应主键值再比较）
   - 通过记录的 next_record 属性遍历该槽所在的组中的各个记录
9. Page Header 页面头部
   - 转码针对索引页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等
10. File Header文件头部
   - 针对各种页都通用的一些状态信息
   - FIL_PAGE_SPACE_OR_CHKSUM
        校验和
   - FIL_PAGE_PREV 和 FIL_PAGE_NEXT
        双向链表，多个不连续的页关联起来，并不是所有类型的页都有上一个和下一个页的属性
11. File Trailer 文件尾部
    - 校验和
        每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为 File Header 在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在 File Header 中的校验和就代表着已经修改过的页，而在 File Trialer 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。
    - 页面被最后修改时对应的日志序列位置（LSN）
12. MySQL如何保持磁盘内存数据一致性？
#### 4. B+树索引
1. 数据页建立规则
    下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不连续。（通过File Header内的两个指针确定顺序）
2. 页分裂
    在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。
3. 目录项
    - 为了快速定位目标页，我们需要给它们做个目录，每个页对应一个目录项
    - 页的用户记录中最小的主键值，用 key 来表示
    - 页号，用 page_no 表示
4. InnoDB的索引方案
   - 目录项记录
        复用数据页来存储目录项
   - 头信息内record_type区分
        0 ：普通的用户记录
        1 ：目录项记录
        2 ：最小记录
        3 ：最大记录
5. 目录项记录和普通的用户记录有什么不同？
   - 头信息的record_type不同
   - 目录项记录只有主键值和页的编号两个列（还有头信息），而普通的用户记录的列有很多列
   - 只有在存储 目录项记录 的页中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 
6. 为什么要将目录项存储在页内？
   - InnoDB最大连续存储空间为16KB
   - 增删时，需要移动所有目录项
7. 根据主键值查找一条用户记录需要哪些步骤？（多次二分法）
   -  确定目录项记录页
   -  通过目录项记录页确定用户记录真实所在的页
   -  在真实存储用户记录的页中定位到具体的记录
8. B+ 树
   - 多级目录
   - 实际用户记录其实都存放在B+树的最底层的节点上
   - 一般不会超过4层
9. 聚簇索引
   - 拥有以下两种特性的B+树为聚簇索引
   - 使用记录主键值的大小进行记录和页的排序
        页，存放用户记录的页，以及存放目录项记录的页都是按照主键大小排序
   - B+ 树的叶子节点存储的是完整的用户记录
   - InnoDB 存储引擎会自动的为我们创建聚簇索引，聚簇索引就是数据的存储方式，即索引即数据，数据即索引
10. InnoDB数据的存储方式是什么？
    B+树，或者说拥有以上特性的聚簇索引
    **为什么用B+树而不是其他的存储方式？有什么优缺点？**
11. 二级索引
    - 以非主键的列作为搜索条件
    - 与聚簇索引的不同
      - 使用记录非主键列的大小进行记录和页的排序
      - B+ 树的叶子节点存储的并不是完整的用户记录，而只是 索引+主键 这两个列的值
      - 目录项记录中不再是 主键+页号 的搭配，而变成了 索引列+主键+页号 的搭配
12. 非主键列的记录查询与主键列记录查询有什么不同？
    - 确定 目录项记录 页
    - 通过 目录项记录 页确定用户记录真实所在的页
    - 在真实存储用户记录的页中定位到具体的记录
    - 再根据主键值去聚簇索引中再查找一遍完整的用户记录，得到完整的数据记录
    - 即需要回表，建立两颗B+树
13. 为什么非主键B+树不把完整的用户记录放到叶子节点？
    浪费存储空间
14. 联合索引
    - 本质上也是二级索引，把各个记录和页按照 c1 列进行排序，在记录的 c2 列相同的情况下，采用 c2 列进行排序
    - 目录项记录为c1，c2,页号
    - 叶子节点处为：c1,c2，主键
    - 注意只建立一颗B+树
15. 为空表创建B+树索引会发生什么?
    - 先创建一个 根节点 页面，既没有用户记录，也没有目录项记录
    - 随后向表中插入用户记录时，先把用户记录存储到这个 根节点 中
    - 根节点页满时，会将 根节点 中的所有记录复制到一个新分配的页，再对这个新页进行 页分裂 的操作。这时新插入的记录根据键值分配到新页中，根节点 便升级为存储目录项记录的页
    - 一个B+树索引的根节点自诞生之日起，便不会再移动
16. 内节点中目录项记录的唯一性
    - 聚簇索引由于存在主键自动满足
    - 对于二级索引，要求其内节点的目录项记录的内容由三个部分构成，索引列的值，主键值，页号。否则当两个目录页索引列值相同时，新记录就不知道往哪插入了
17. 一个页面最少存储2条记录
    B+树本质上就是一个大的多层级目录，如果每个页面只放一个记录相当于一个大目录只放一个子目录会导致目录层级非常多
18. MyISAM的索引方案
    - 也是使用树形结构，但将数据和索引分开
    - 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为 数据文件
    - 单独为表的主键创建一个索引储存到索引文件中，在索引的叶子节点中存储的是主键值+行号 的组合。先通过索引找到对应的行号，再通过行号去找对应的记录
    - 相当于MyISAM 中建立的索引相当于全部都是二级索引
    -  非主键索引叶子节点存储的为相应的列 + 行号
19. 创建和删除索引
    - *ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);*
    - *ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;*
    - *PRIMARY KEY(c1)*
    - *INDEX idx_c2_c3 (c2, c3)*
20. 索引的缺点
    - 空间上的代价
        每建立一个索引都要为它建立一棵 B+ 树
    - 时间上的代价
        为了满足B+ 树每层节点都是按照索引列的值从小到大的顺序排序，所以每次对表中的数据进行增、删、改操作时，存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序
    - 一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差
21. B+树索引适用的条件：用于查找(WHERE)
    - 例，表INFO,主键为A，而B,C,D列组成联合索引
    - 一般原则
        如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列
    - 全值匹配
        SELECT * FROM INFO WHERE B = '' AND C = '' AND D = '';
        可以用到所有索引
    - 匹配左边的列
        SELECT * FROM INFO WHERE B = '' AND C = ''
        可以用到索引
        SELECT * FROM INFO WHERE C = ''
        用不到索引，因为这个索引是先按照B排序的，B值不同的记录中C可能是无序的
    - 匹配列前缀
        一般的比较规则都是逐个比较字符的大小
        SELECT * FROM INFO WHERE B LIKE 'As%'
        可以用到
        SELECT * FROM INFO WHERE B LIKE '%As%
        用不到
        如果要查询后缀且用到索引，那么就需要将表中的数据全部逆序存储一下，再查找
    - 匹配范围值
        如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+ 树索引
        SELECT * FROM INFO WHERE B > 'Asa' AND B < 'Barlow' AND C > '1980-01-01';
        因为这个索引是先按照B排序的，B值不同的记录中C可能是无序的
    - 精确匹配某一列并范围匹配另外一列
        对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找
        SELECT * FROM INFO WHERE B = 'Asa' AND C > '1980-01-01a' AND C < '1982-01-01' ;
22. 用于排序(ORDER BY)
    - 文件排序
        - 在内存中或者磁盘上进行排序的方式。一般情况下，记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，当查询的结果集太大以至于不能在内存中进行排序的话，要借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端
        - 有相应索引时，由于 B+ 树索引本身就是按照规则排好序的，所以直接从索引中提取数据，然后进行 回表 操作取出该索引中不包含的列
    - 使用联合索引排序
        不能颠倒顺序
        匹配索引左边的列的形式可以使用部分的 B+ 树索引
        当联合索引左边列的值为常量，也可以使用后边的列进行排序 
        SELECT * FROM INFO WHERE B = 'A' ORDER BY B, C LIMIT 10
    - 不可以使用索引进行排序的几种情况
        - ASC、DESC混用
            SELECT * FROM INFO ORDER BY B, C DESC LIMIT 10;
            不能高效使用索引，规定使用联合索引的各个排序列的排序顺序必须是一致的
        - WHERE子句中出现非排序使用到的索引列
        - 排序列包含非同一个索引的列
        - 排序列使用了复杂的表达式    
            索引列是以单独列的形式出现，而不是（函数）修饰过的形式
23. 用于分组(GROUP BY)
    和使用 B+ 树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组
24. 回表的代价
    - 顺序I/O
        idx_B_C_D, B的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中
    - 随机I/O
        回表时，叶子节点里的主键并不一定连续，可能分布在不同的数据页中
    - idx_B_C_D查询的特点
        会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引
        访问二级索引使用 顺序I/O ，访问聚簇索引使用 随机I/O 
    - 需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描(聚簇索引)也不使用 二级索引，如要查询的数据占比较高时
25. 查询优化器
    - 查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 二级索引 + 回表 的方式
    - 添加了 LIMIT 的查询更容易让优化器采用 二级索引 + 回表 的方式进行查询
26. 覆盖索引
    最好在查询列表里只包含索引列，省去了 回表 操作带来的性能损耗。
    很不鼓励用 * 号作为查询列表，最好把我们需要查询的列依次标明。
27. 建立索引时的注意事项
    - 只为用于搜索、排序或分组的列创建索引
    - 考虑列的基数
        列的基数 指的是某一列中不重复数据的个数。在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。例如基数为1，则所有值都一样就无法排序，无法进行快速查找。而且可能还要回表
    - 索引列的类型尽量小
        数据类型越小，在查询时进行的比较操作越快
        数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率
        对于表的主键来说更加适用
    - 索引字符串值的前缀
        只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。
        索引列前缀的方式无法支持使用索引排序
    - 让索引列在比较表达式中单独出现
        如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的
        WHERE my_col * 2 < 4     
    - 主键插入顺序
        主键插入如果忽大忽小如1，5，15，35...，假设某个数据页存储的记录已经满了，再插入会导致页面分裂和记录移位即性能损耗
        让主键具有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入
    - 冗余和重复索引

#### 5. MySQL的数据目录
1. 数据库和文件系统
    像 InnoDB 、 MyISAM 这样的存储引擎都是把表存储在文件系统，即磁盘上的
2. 数据目录
    数据目录 是用来存储 MySQL 在运行过程中产生的数据
    SHOW VARIABLES LIKE 'datadir'
3. 数据库以及表在文件系统中的表示（数据目录内）
    - db.opt
         该数据库的各种属性，比方说该数据库的字符集和比较规则
    - 表名.frm
         表结构的定义, 视图（查询语句生成的虚拟表）结构的定义
    - ibdata1
        系统表空间, 自动扩展
    - 表名.ibd
        独立表空间
    - MyISAM
        test.frm： 表结构
        test.MYD： 数据
        test.MY：  索引文件
    - 其他文件
        服务器进程文件
        服务器日志文件
        默认/自动生成的SSL和RSA证书和密钥文件
4. 文件系统对数据库的影响
   - 数据库名称和表名称不得超过文件系统所允许的最大长度
   - 特殊字符：MySQL 会把数据库名和表名中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 @+编码值 的形式作为文件名
   - 文件长度受文件系统最大长度限制
5. MySQL系统数据库
   - mysql
        存储了MySQL的用户账户和权限信息，一些日志信息等
   - information_schema
        所有其他数据库的信息，如有哪些表、哪些视图、哪些索引等等
   - performance_schema
        性能监控，保存MySQL服务器运行过程中的一些状态信息，如内存使用状况
   - sys
        information_schema与performance_schema的视图，方便查看


#### 6. InnoDB的表空间
1. 区（extent）
   - 连续的64个页就是一个 区 ，也就是说一个区默认占用1MB空间大小
   - 256个区被划分成一组
   - 每个组的最开始的几个页面类型是固定的
2. 为什么要有区的概念
    B+ 树的每一层中的页都会形成一个双向链表，如果链表中相邻的两个页物理位置离得非常远，则查询效率很低，我们应该尽量让链表中相邻的页的物理位置也相邻。所以在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照 区 为单位分配
3. 段（segment）
   - 段是以区为单位申请存储空间的， 更精确的应该是某些零散的页面以及一些完整的区的集合
   - 分为叶子节点段，非叶子节点段
4. 为什么要有段的概念
   - 查找扫描的是B+树的叶子节点，需要区分叶子节点和非叶子节点。否则范围扫描效果很低。
5. 碎片区
   - 默认情况下一个使用 InnoDB 存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间
   - 为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于
   - 碎片区直属于表空间，并不属于任何一个段
6. 区的分类
    FREE 空闲的区
    FREE_FRAG 有剩余空间的碎片区
    FULL_FRAG 没有剩余空间的碎片区
    FSEG 附属于某个段的区
    FREE、FREE_FRAG、FULL_FRAG直属于表空间，FSEG属于某个段
7. 为某个段分配存储空间的策略
   - 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的
   - 当某个段已经占用了32个碎片区（半个区）页面之后，就会以完整的区为单位来分配存储空间
8. XDES Entry的作用
    - 每个区都对应着一个 XDES Entry 结构， 记录了对应的区的一些属性
    - 向段中插入数据的时候我们要分辨出哪些区是空闲碎片区或者满碎片区或者完整的区，XDES Entry内的节点组成不同区的链表，如FREE 链表， FREE_FRAG 链表，FULL_FRAG 链表。当我们想插入某一类型的区时就不需要遍历所有的区，只需要找到对应链表的节点来插入数据即可。
    - 表示那个区属于那个段，以便为数据分配段
9.  如何知道哪个区属于哪个段？
    不同索引有不同的段，根据XDES内的段号区分，而属于某个段的区也分为空闲，未满，满三种，所以也要建立对应的列表。
10. 组
    - 256个区划分为一组
    - 第一个组前三个页固定，为FSP_HDR， IBUF_BITMAP， INODE
    - 其余组前两个页固定，为XDES， IBUF_BITMAP
11. INODE Entry
    - 每个段对应着一个INODE Entry，用于记录段中的属性
    - 存储了段的 FREE 链表、 NOT_FULL 链表、 FULL 链表的基结点，便于查找链表头尾
12. FSP_HDR 类型页
    - 存储了表空间的一些整体属性以及第一个组内256个区的对应的 XDES Entry 结构
    - 存储了表空间的 FREE 链表、 FREE_FRAG 链表、FULL_FRAG 链表的基节点
13. XDES 类型页
    - 类似FSP_HDR页，但是不记录表空间的属性， 记录该组内的所有区对应的 XDES Entry 结构
14. INODE 类型页
    - 存储了每个段的INODE Entry 结构
    - 而INODE Entry 结构又...
    - 创建索引时就会创建段
15. 系统表空间
    - 系统表空间的结构和独立表空间基本类似，系统表空间中会额外记录一些有关整个系统信息的页面
16. 向表中插入数据要经历什么（发散思维，从哪找，怎么找等等）
    MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+ 树中
17. 元数据与数据字典
    - 元数据
        记录一些系统数据，如某个表属于哪个表空间，表里边有多少列，索引对应的根页面在哪个表空间的哪个页面等等
    - 数据字典
        记录元数据的内部系统表
    - 基本系统表
        - SYS_TABLE： 记录表ID
        - SYS_COLUMNS： 记录表的列信息
        - SYS_INDEXES：记录表的索引信息
        - SYS_FIELDS： 记录表的索引列的信息。
    - 基本数据表的元数据硬编码到代码中，页号为 7 的页面，类型为 SYS记录这些表的索引。设计时数据字典的信息当成一个段来分配存储空间，数据量少，所以只有一个碎片页。
    - 不能直接访问 InnoDB 的这些内部系统表的，但可以通过*SHOW TABLES LIKE 'innodb_sys%'*查看

#### 7.单表访问（FROM 子句后边只有一个表）
1. 执行计划
    一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的 执行计划
2. 唯一二级索引
    如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引
3. 使用索引来执行查询的方式
    针对主键或唯一二级索引的等值查询
    针对普通二级索引的等值查询
    针对索引列的范围查询
    直接扫描整个索引  
4. 访问方法（access method）
     执行查询语句的方式称之为 访问方法
5. const
    - 通过主键或者唯一二级索引列来定位一条记录的访问方法定义为： const
    - SELECT * FROM single_table WHERE key2 = 3841;
    - 这种 const 访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才
    有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个const 访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。
6. ref
   - 搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为： ref
   - 与const区别在于：可能匹配到多条连续的记录，还需要回表
   - 特殊情况
     - 二级索引列值为 NULL 的情况：ref
     - 最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为 ref
7. ref_or_null
   - 使用二级索引而不是全表扫描的方式执行查询null，称为：ref_or_null
   - SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;
8. range
   - 利用索引进行范围匹配的访问方法称之为： range 
   - SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
9. index
   - 采用遍历二级索引记录的执行方式称之为： index 
   - SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc'
   - 原因：二级索引记录比聚簇索记录小的多，也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多
10. all
    - 全表扫描执行查询的方式称之为： all
11. 注意
    - 一般情况下只能利用单个二级索引执行查询
        - SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;
        - 一般来说，等值查找比范围查找需要扫描的行数更少，先二级索引定位条件1，再回表，再筛选条件2
    - 明确range访问方法使用的范围区间
        - LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引
        - 化简：在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为 TRUE
        - 一个使用到索引的搜索条件和没有使用该索引的搜索条件使用 OR 连接起来后是无法使用该索引的，原因是要回表全部二级索引的记录，开销比全表扫描大
        - SELECT * FROM single_table WHERE key2 > 100 OR TRUE
12. 索引合并
    使用到多个索引来完成一次查询的执行方法称之为： index merge
13. 交集合并( Intersection合并)
    - SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
    - 步骤：按照不同的搜索条件分别读取不同的二级索引，将从多个二级索引得到的主键值取交集，然后进行回表操作
    - 读取二级索引的操作是 顺序I/O ，而回表操作是 随机I/O ，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为 回表 而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。
    - 使用情况
      - 二级索引列是等值匹配的情况
      - 主键列可以是范围匹配
      - 原因：二级索引的用户记录是由 索引列 + 主键 构成的，二级索引列的值相同的记录可能会有好多条按照主键 的值进行排序的。之所以在二级索引列都是等值匹配的情况下才可能使用Intersection 索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。否则还要先排序再比对，开销大
    - 优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过 Intersection 索引合并后需要回表的记录数大大减少时才会使用 Intersection 索引合并
14. Union合并
    - SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'
    - 使用情况
      - 二级索引列是等值匹配的情况
      - 主键列可以是范围匹配
      - 使用 Intersection 索引合并的搜索条件
    - 优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过 Union 索引合并后进行访问的代价比全表扫描更小时才会使用 Union 索引合并
15. Sort-Union合并
    - SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z
    - 述这种先按照二级索引记录的主键值进行排序，之后按照 Union 索引合并方式执行的方式称之为 SortUnion 索引合并，很比单纯的 Union 索引合并多了一步对二级索引记录的主键值排序的过程
16. 为什么没有Sort-Intersection索引合并？
    Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高。
    Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了
17. 索引合并注意事项
    联合索引替代Intersection索引合并
    SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';

#### 8. 多表访问：连接的原理
1. Join连接的本质
   - 连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户
   - SELECT * FROM t1, t2;
   - 笛卡尔积很大时，需要过滤
2. 连接的过程
   - SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
   - 首先确定第一个需要查询的表，这个表称之为驱动表。单表查询（从以上执行方法中选取代价最小的方法）
   - 从驱动表产生的结果集中的每一条记录，分别需要到 t2 被驱动表中查找匹配的记录。即多次单表查询
   - 在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。
3. 内连接和外连接
   - 内连接
        对于 内连接 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集
   - 外连接
        驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集
        左外连接
        右外连接
4. 过滤条件
   - WHERE 子句中的过滤条件
        不论是内连接还是外连接，凡是不符合 WHERE 子句中的过滤条件的记录都不会被加入最后的结果集
   - ON 子句中的过滤条件
        如果无法在被驱动表中找到匹配 ON 子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充
   - 为什么要有on
        -  ON 子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的
        - 内连接中的WHERE子句和ON子句是等价的
   - 连接条件
         一般情况下，我们都把只涉及单表的过滤条件放到 WHERE 子句中，把涉及两表的过滤条件都放到 ON 子句中
5. 内连接和外连接的根本区别
   - 在驱动表中的记录不符合 ON 子句中的连接条件时不会把该记录加入到最后的结果集
   - 对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。而左外连接和右外连接的驱动表和被驱动表不能轻易互换。因为找不到记录的对应的被驱动表值为NULL
   - *SELECT * FROM t1 [INNER | LEFT | RIGHT] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];*
   - *SELECT * FROM t1, t2;*也是内连接
6. 嵌套循环连接 （ Nested-Loop Join ）
   - 驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式
   - 比如之前的内连接
7. 使用索引加快连接速度
   - 查询一次被驱动表其实就相当于一次单表扫描，我们可以利用索引来加快查询速度
   - SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
   - 在m2, n2上分别建立索引，挑选代价更低的执行查询。
   - 建立了索引不一定使用索引，只有在 二级索引 + 回表 的代价比全表扫描的代价更低时才会使用索引
8. 基于块的嵌套循环连接（Block Nested-Loop Join）
   - 嵌套循环连接需要查询被驱动表多次， 当被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，I/O代价非常大，所以应尽量减少访问被驱动表的次数
   - 在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配。即通过join buffer一次性和多个驱动表记录匹配，在内存中完成，显著减少I/O代价
9. 如何优化连接查询？
    - 为被驱动表加上效率高的索引
    - 尝试调大 join_buffer_size 的值来对连接查询进行优化
10. 为什么不建议使用*作为查询列表?
   - 如果需要查询的列表就是某个索引的一部分，那么就相当于index访问方法查询，不需要回表
   - 查询时是被驱动表的每一条记录与join buffer内的驱动表记录做匹配，不用*作为查询列表则可在join buffer 中放置更多的记录

#### 9. MySQL基于成本的优化
1. 成本
   - I/O成本
    MyISAM 、 InnoDB 存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作
   - CPU 成本
    读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 CPU 成本
   - 成本常数
    读取一个页面花费的成本默认是 1.0 ，读取以及检测一条记录是否符合搜索条件的成本默认是 0.2
2. 单表查询基于成本的优化步骤
   1. 根据搜索条件，找出所有可能使用的索引
   2. 计算全表扫描的代价
   3. 计算使用不同索引执行查询的代价
   4. 对比各种执行方案的代价，找出成本最低的那一个
3. 全表扫描的代价
   - I/O成本：聚簇索引占用的页面数 * 1.0 （不区分内节点和叶子节点） 
   - CPU成本：该表中的记录数 * 0.2
4. 不同索引执行查询的代价
    - 唯一二级索引
      - 范围区间数量（I/O）
         读取索引的一个范围区间的 I/O成本和读取一个页面是相同的
      - 需要回表的记录数（I/O）
         每次回表操作都相当于访问一个页面
      - 回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立（CPU）
    - 普通二级索引
        过程类似上面
    - 是否有可能使用索引合并（Index Merge）
5. 基于索引统计数据的成本计算
   - SELECT * FROM single_table WHERE key1 IN ('aa1', 'aa2', 'aa3', ... , 'zzz');
   - index dive 
        当索引不是唯一二级索引时，需要通过直接访问索引对应的 B+ 树来计算某个范围区间对应的索引记录条数
   - 对于多个单点区间，当 IN 语句中的参数个数小于200个的话，将使用 index dive 的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，使用所谓的索引统计数据来进行估算
   - 索引统计数据的估算
        大概计算出单个值的重复次数，乘以然后in中参数个数，就是要回表的记录数
   - 当你的查询中使用到了IN查询，但是却实际没有用到索引，就应该考虑一下是不是由于 eq_range_index_dive_limit 值太小导致的
6. 连接查询的成本
   - 单次查询驱动表的成本
   - 多次查询被驱动表的成本
   - 对驱动表进行查询后得到的记录条数称之为驱动表的扇出（fanout）
7. 两表连接的成本分析
   - 连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本
   - （左右）外连接
        驱动表固定，分别为驱动表和被驱动表选择成本最低的访问方法
   - 内连接
        驱动表不固定，分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划
8. 两表连接的优化
   - 尽量减少驱动表的扇出
   - 对被驱动表的访问成本尽量低
   - 尽量在被驱动表的连接列上建立索引，这样就可以使用 ref 访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样成本更低
9. 多表连接的成本分析
   - 有n个表，即有n！种连接顺序
   - 提前结束某种顺序的成本评估，成本分析时记录之前的最小值，大于这个最小值就不再分析
   - 设定系统变量，连接表个数小于该值则继续穷举，大于该值则以该值相同数量的表进行穷举分析
   - 根据某种启发式规则不考虑某些连接顺序 
10. 调整成本常数
    - 一条语句的执行其实是分为两层
        server 层：连接管理、查询缓存、语法解析、查询优化等操作
        存储引擎层：存储引擎层执行具体的数据存取操作
    - 一条语句在 server 层中执行的成本是和它操作的表使用的存储引擎是没关系的
    - server 层的成本常数
        *SELECT * FROM mysql.server_cost;*
    - 存储引擎层的成本常数
        *SHOW TABLES FROM mysql LIKE '%cost%';*

#### 10. InnoDB统计数据收集
1. 统计数据存储方式
   - 永久性的统计数据
        存储在磁盘上
   - 非永久性的统计数据
        存储在内存种
   - InnoDB 默认是以表为单位来收集和存储统计数据的，可以指定存储在哪
   - InnoDB的统计数据数据并不准确
2. 统计数据从哪得到的？
    从InnoDB的表空间内的一些文件头部，段头部等等得到以及一些算法得到
3. 为什么最好不在索引列中存放NULL值？
    涉及优化器在利用统计数据来选择最优的执行计划这部分

#### 11. MySQL基于规则的优化
1. 查询重写
    MySQL依据一些规则，将用户的语句转换为比较高效执行的形式。下面所述即为一些重写规则。
2. 条件化简
   - 移除不必要的括号
   - 常量传递：AND可以，OR不行
   - 等值传递
   - 移除没用的条件
   - 表达式计算
   - HAVING子句和WHERE子句的合并
   - 常量表检测
3. 为什么最好让索引列以单独的形式出现在表达式?
   - 这样可以用到索引
   - 优化器会尝试对这些表达式进行化简
4. 常量表检测
   - 查询的表中一条记录没有，或者只有一条记录
   - 使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表
   - 优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本
5. 外连接消除
   - 右左连接只在驱动表的选取方式上是不同的，优化器会首先把右连接查询转换成左连接查询
   - 在外连接查询中，指定的 WHERE 子句中包含被驱动表中的列不为 NULL 值的条件称之为空值拒绝
   - 在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换
5. 外连接消除有什么好处？
    查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询
6. 子查询语法
   - 出现在某个查询语句的某个位置中的查询就被称为子查询 
   - 外层查询
   - from中子查询结果集组成的表称之为 派生表
   - SELECT 子句中
        SELECT (SELECT m1 FROM t1 LIMIT 1);
   - FROM 子句中
        SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 > 2) AS t;
   - WHERE 或 ON 子句中
        SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);
   - ORDER BY 子句中
   - GROUP BY 子句中
7. 按返回的结果集区分子查询
   - 标量子查询
        只返回一个单一值的子查询
        SELECT (SELECT m1 FROM t1 LIMIT 1);
   - 行子查询
        返回一条记录的子查询
        SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);
   - 列子查询
        查询出一个列的数据
        SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);
   - 表子查询
        子查询的结果既包含很多条记录，又包含很多个列
        SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);
8. 按与外层查询关系来区分子查询
   - 不相关子查询
        子查询可以单独运行出结果，而不依赖于外层查询的值
   - 相关子查询
        子查询的执行需要依赖于外层查询的值
        SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);
9. 子查询在布尔表达式中的使用
   - 我们平时用子查询最多的地方就是把它作为布尔表达式的一部分来作为搜索条件用在 WHERE 子句或者 ON 子句里
   - 使用 = 、 > 、 < 、 >= 、 <= 、 <> 、 != 、 <=> 作为布尔表达式的操作符
        这里的子查询只能是标量子查询或者行子查询
        SELECT * FROM t1 WHERE m1 < (SELECT MIN(m2) FROM t2);
   - IN 或者 NOT IN
        SELECT * FROM t1 WHERE (m1, n2) IN (SELECT m2, n2 FROM t2);
   - ANY/SOME （ ANY 和 SOME 是同义词）
        只要子查询结果集中存在某个值和给定的操作数做 comparison_operator 比较结果为 TRUE ，那么整个表达式的结果就为 TRUE 
        SELECT * FROM t1 WHERE m1 > (SELECT MIN(m2) FROM t2);
        =ANY 和 IN同意
   - ALL
        子查询结果集中所有的值和给定的操作数做 comparison_operator 比较结果为 TRUE ，那么整个表达式的结果就为 TRUE ，否则整个表达式的结果就为 FALSE
        SELECT * FROM t1 WHERE m1 > ALL(SELECT m2 FROM t2);
   - EXISTS子查询
        判断子查询的结果集中是否有记录
        SELECT * FROM t1 WHERE EXISTS (SELECT 1 FROM t2);
10.  子查询语法注意事项
     - 子查询必须用小括号扩起来
     - 在 SELECT 子句中的子查询必须是标量子查询
            要加LIMIT 1
     - 对于 [NOT] IN/ANY/SOME/ALL 子查询来说，子查询中不允许有 LIMIT 语句
            目前不支持
     - 不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询
11.  标量子查询、行子查询的执行方式
     - 对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了
     - 对于相关的标量子查询或者行子查询来说，先从外层查询中获取一条记录，然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，最后根据子查询的查询结果来检测外层查询 WHERE 子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。再执行第一步。
12. IN子查询结果集太多会导致什么问题？
    - 结果集太多，可能内存中都放不下
    - IN 子句中的参数特别多
        无法有效的使用索引，只能对外层查询进行全表扫描
        导致检测一条记录是否符合和 IN 子句中的参数匹配花费的时间太长
13. IN子查询优化
    - 使用物化表
        将该结果集写入一个临时表里，物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行 IN 语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。
    - 物化表转内连接
        物化表后，就相当于表和子查询物化表进行内类链接，而转化成内连接之后查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询
        查询的总成本：
        物化子查询时需要的成本 + 扫描驱动表（物化表）的成本 + 驱动表（物化表）中的记录数量 X 比对时对物化表（驱动表）单表访问的成本（物化表去重且有索引索引非常快）
    - 子查询转化为半连接
        对于物化表转内连接的情况，会对物化表去重。而半连接中，我们只关心在驱动表中是否有匹配的记录而不关心有多少数量
    - 执行 IN to EXISTS 转换
        转为 EXISTS 子查询后却可以使用到索引
    - 注意执行顺序是半连接-EXIST转化-物化表，因为物化表也有成本
14. 如何实现半连接？（执行半连接的策略，成本不同，挑选最低）
    - 子查询中的表上拉
        当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表 上拉 到外层查询的 FROM 子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中
            SELECT * FROM s1 WHERE key2 IN (SELECT key2 FROM s2 WHERE key3 = 'a');
        原因是主键或者唯一索引列中的数据本身就是不重复
    - 重复值消除
        使用临时表设定主键，消除 semi-join 结果集中的重复值的方式
    - 松散索引扫描
        扫描索引，但只取被驱动表值相同的记录的第一条去做匹配操作的方式称之为 松散索引扫描
15. 半连接的使用条件？
    感觉不会问这么细，要是问到就说看过，在高性能MySQL那边书里有
16. ANY/ALL子查询优化
     不相关子查询可以转化为与最大最小值的比较   
17. [NOT] EXISTS子查询的执行
    先执行子查询，再重写语句。有索引的话可以加快查询速度
18. 对于派生表的优化
    子查询放在外层查询的 FROM 子句后，那么这个子查询的结果相当于一个 派生表
    SELECT * FROM (SELECT A, B FROM S2)...
    - 派生表延迟物化
        将派生表的结果集写到一个内部的临时表中，然后就把这个物化表当作普通表一样参与查询。延迟物化指的是先要判断是否有结果集再考虑是否物化
    - 将派生表和外层的表合并，也就是将查询重写为没有派生表的形式
        消除派生表，就不用物化了
    - 顺序：合并-物化

#### 12.查询优化-Explain
1. 执行计划
    一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的 执行计划 ，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。
2. Explain命令
   -  查看某个查询的执行计划，在这个执行计划的辅助下，我们应该怎样改进自己的查询语句以使查询执行起来更高效
     EXPLAIN SELECT 1;
   -  一条大的查询语句里边可以包含若干个 SELECT 关键字，每个 SELECT 关键字代表着一个小的查询语句，而每个 SELECT 关键字的 FROM 子句中都可以包含若干张表（这些表用来做连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个 SELECT 关键字中的表来说，它们的 id 值是相同的
3. EXPLAIN 语句输出的各个列
    id 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id
    select_type SELECT 关键字对应的那个查询的类型
    table 表名
    partitions 匹配的分区信息
    type 针对单表的访问方法
    possible_keys 可能用到的索引
    key 实际上使用的索引
    key_len 实际使用到的索引长度
    ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息
    rows 预估的需要读取的记录条数
    filtered 某个表经过搜索条件过滤后剩余记录条数的百分比
    Extra 一些额外的信息
4. table
   - 不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。
   -  EXPLAIN SELECT * FROM s1 INNER JOIN s2;有两条记录分table分别为s1，s2
5. id
   - 查询语句中每出现一个 SELECT 关键字，就会为它分配一个唯一的 id 值
   - 连接查询: EXPLAIN SELECT * FROM s1 INNER JOIN s2;
        一个 SELECT 关键字后边的 FROM 子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的.出现在前边的表表示驱动表，出现在后边的表表示被驱动表
   - 子查询： EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) ;
        - 涉及多个 SELECT 关键字，所以在包含子查询的查询语句的执行计划中，每个 SELECT 关键字都会对应一个唯一的 id 值
       - 查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了
   - id为NULL：UNION语句；EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;
        UNION 子句会通过创建 <union1, 2> 的临时表把多个查询的结果集合并起来并对结果集中的记录进行去重。id 为 NULL 表明这个临时表是为了合并两个查询的结果集而创建的
6. select_type
   - 每一个 SELECT 关键字代表的小查询都定义了一个称之为 select_type 的属性，表示这个小查询在整个大查询中扮演了一个什么角色
   - SIMPLE
        查询语句中不包含 UNION 或者子查询的查询都算作是 SIMPLE 类型，如连接查询
   - PRIMARY
        包含 UNION 、 UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type 值就是 PRIMARY
   - UNION
        包含 UNION 或者 UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是 UNION
   - SUBQUERY
        采用将该子查询物化的方案来执行该子查询时
   - DERIVED
        对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的 select_type 就是 DERIVED
7. type
    - type 列就表明了这个访问方法是什么
    - system，表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory
    - const，根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法
    - eq_ref，在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的
    - index_merge，一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用 Intersection 、 Union 、 Sort-Union 这三种索引合并的方式来执行查询
    - range，索引获取某些 范围区间 的记录，那么就可能使用到 range 访问方法
    - index，使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index
    - ALL，全表扫描
    - 除了 All 这个访问方法外，其余的访问方法都能用到索引，除了 index_merge 访问方法外，其余的访问方法都最多只能用到一个索引
8. possible_keys和key
    - possible_keys 列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些， key 列表示实际用到的索引有哪些
    - possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引
9. key_len
   - key_len 列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度
   - 对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100) ，使用的字符集是 utf8 ，那么该列实际占用的最大存储空间就是 100 × 3 = 300 个字节。
   - 如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多1个字节。
   - 对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度
10. ref
    当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 const 、 eq_ref 、 ref 、 ref_or_null 、unique_subquery 、 index_subquery 其中之一时， ref 列展示的就是与索引列作等值匹配的是什么
11. rows
    代表查询时预计要扫描的行数
12. filtered
    - 单表查询时，代表在满足第一个条件的rows中可以满足其余搜索条件的记录的占比
    - 我们更关注在连接查询中驱动表对应的执行计划记录的filtered 值，代表被驱动表需要执行查询的记录占驱动表rows的比值
13. Extra
    - 补充一些查询中的额外信息
    - Impossible WHERE
        查询语句的 WHERE 子句永远为 FALSE 时将会提示该额外信息
    - Using index
        当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，不需要回表操作
    - Using index condition
        有些搜索条件中虽然出现了索引列，但却不能使用到索引，例如搜索条件包含了后缀搜索
    - Using join buffer (Block Nested Loop)
        在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度， MySQL 一般会为其分配一块名叫join buffer 的内存块来加快查询速度，也就是我们所讲的 基于块的嵌套循环算法
    - Using intersect(...) 、 Using union(...) 和 Using sort_union(...)
        用到了以上的索引合并的方式
    - Using filesort
        查询时排序了，如order by，group by
    - Using temporary
        - MySQL 可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 DISTINCT 、 GROUP BY 、 UNION 等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL 很有可能寻求通过建立内部的临时表来执行查询
        - GROUP BY子句的查询中默认添加上 ORDER BY 子句，需要显式的写上 ORDER BY NULL
        -  执行计划中出现 Using temporary 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表
14. 通过Json格式的EXPLAIN输出查看衡量执行计划好坏的重要属性：成本
    在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT=JSON 
    EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\G
15. 查看重写后的语句
    - 使用 EXPLAIN 语句查看了某个查询的执行计划后，紧接着还可以使用 SHOW WARNINGS 语句查看与这个查询的执行计划有关的一些扩展信息
    - Level 、 Code 、 Message 
    - 注意Message 字段展示的信息并不是标准的查询语句，不能直接运行

#### 13. optimizer trace（优化轨迹）表
1. optimizer trace表
    查看优化器生成执行计划的整个过程
2. 如何打开该功能
  *SHOW VARIABLES LIKE 'optimizer_trace';*
  *SET optimizer_trace="enabled=on";*
3. 如何查看完整的优化过程
    - 到information_schema 数据库下的 OPTIMIZER_TRACE 表查看
    1. 打开optimizer trace功能 (默认情况下它是关闭的):
        SET optimizer_trace="enabled=on";
    2. 这里输入你自己的查询语句
        SELECT ...;
    3. 从OPTIMIZER_TRACE表中查看上一个查询的优化过程
        SELECT * FROM information_schema.OPTIMIZER_TRACE;
    4. 可能你还要观察其他语句执行的优化过程，重复上边的第2、3步
        ...
    5. 当你停止查看语句的优化过程时，把optimizer trace功能关闭
        SET optimizer_trace="enabled=off"
4. 分析阶段
    prepare 阶段
    optimize 阶段
    execute 阶段
5. optimize 阶段
    - 基于成本的优化主要集中在 optimize 阶段
    - 对于单表查询来说，我们主要关注 optimize 阶段的 "rows_estimation" 这个过程
    - 这个过程深入分析了对单表查询的各种执行方案的成本；对于多表接查询来说，我们更多需要关注 "considered_execution_plans" 这个过程，这个过程里会写明各种不同的连接方式所对应的成本。
    - 优化器最终会选择成本最低的那种方案来作为最终的执行计划，也就是我们使用 EXPLAIN 语句所展现出的那种方案。

#### 14. InnoDB的Buffer：调节磁盘和CPU的矛盾
1. 什么是InnoDB的缓存
    磁场访问速度慢，所以 InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其 缓存 起来，这样将来有请求再次访问该页面时，就可以省去磁盘 IO 的开销了。
2.  Buffer Pool （缓冲池）
    - InnoDB为了缓存磁盘中的页，在 MySQL 服务器启动的时候就向操作系统申请了一片连续的内存即缓冲池
    - 默认情况下 Buffer Pool 只有 128M 大小
    - 启动服务器的时候可以配置
        [server]
        innodb_buffer_pool_size = 268435456 
3. 缓冲池结构
   - 控制块
        包括每一个缓存页的控制信息，如该页所属的表空间编号、页号、缓存页在 Buffer Pool 中的地址、链表节点信息、一些锁信息以及 LSN 信息
   - 缓存页
        默认的缓存页大小和在磁盘上默认的页大小是一样的，都是 16KB
   - 整个 Buffer Pool 对应的内存空间
        - 控制块被存放到 Buffer Pool的前边，缓存页被存放到 Buffer Pool 后边，两种之间有一点碎片空间
        - 每个控制块大约占用缓存页大小的5%，注意这个不包含在我们设置的缓冲池的大小内，所以一般缓冲池比我们设置的大5%左右
4. free链表（如何如何确定读取页时将该页存放到缓冲池的哪一页）
    - 最初启动 MySQL 服务器的时候，需要完成对 Buffer Pool 的初始化过程
    - 如何确定读取页时将该页存放到缓冲池的哪一页？
      - 把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作 free链表 （或者说空闲链表）
      - 链表的基节点占用的内存空间并不包含在为 Buffer Pool 申请的一大片连续内存空间之内，而是单独申请的一块内存空间
5. 缓存页的哈希处理（如何确定该页以及在缓冲池中？）
   - 当我们需要访问某个页中的数据时，就会把该页从磁盘加载到 Buffer Pool 中，如果该页已经
 Buffer Pool 中的话直接使用
   - 如何确定该页以及在缓冲池中？
        哈希表，表空间号 + 页号 来定位一个页的，也就相当于 表空间号 + 页号 是一个 key ，缓存页 就是对应的 value
6. flush链表（当缓存页修改后怎么办？）
   - 脏页
    修改了 Buffer Pool 中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为 脏页 （英文名： dirty page ）
   - 并不着急立即把修改同步到磁盘上，而是在未来的某个时间点进行同步以节省开销
   - 同步的时候我们怎么知道 Buffer Pool 中哪些页是 脏页 ，哪些页从来没被修改过呢？
        创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫 flush链表 。
7. LRU链表（当缓冲池已满怎么办？）
   - 删除旧页加入新页，按照最近最少使用 的原则去淘汰缓存页
   - LRU链表
        只要我们使用到某个缓存页，就把该缓存页调整到 LRU链表 的头部，这样 LRU链表 尾部就是最近最少使用的缓存页喽
   - 划分区域的LRU链表（提高缓冲池缓存命中率）
        - 预读页面很多时会导致LRU链表 尾部的一些缓存页会很快的被淘汰掉
        - 全表扫描的语句执行的频率也不高，每次执行都要把 Buffer Pool 中的缓存页大更换
        - 解决方法
             - LRU链表 按照一定比例分成两截，频率高的放到热数据yong区域内，低的放到冷数据old区域。
             - 当磁盘上的某个页面在初次加载到Buffer Pool中的某个缓存页时，该缓存页对应的控制块会被放到old区域的头部。
             - 在对某个处在 old 区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部
8. 刷新脏页到磁盘
   - 从 LRU链表 的冷数据中刷新一部分页面到磁盘
   - 从 flush链表 中刷新一部分页面到磁盘
9. 创建多个Buffer Pool实例
   - 在多线程环境下，访问Buffer Pool 中的各种链表都需要加锁处理啥的，在 Buffer Pool 特别大而且多线程并发访问特别高的情况下，单一的 Buffer Pool 可能会影响请求的处理速度。
   - 在服务器启动的时候设置
      [server]
      innodb_buffer_pool_instances = 2
   - 不是说 Buffer Pool 实例创建的越多越好，分别管理各个 Buffer Pool 也是需要性能开销的
10. 在服务器运行中调整缓冲池大小
    - 在服务器运行期间调整 Buffer Pool 的大小时就是以 chunk 为单位增加或者删除内存空间，，而不需要重新向操作系统申请一片大的内存，然后进行缓存页的复制。节省性能开销。
    - innodb_buffer_pool_chunk_size的值只能在服务器启动时指定，在服务器运行过程中是不可以修改的。
11. 查看Buffer Pool的状态信息
    *SHOW ENGINE INNODB STATUS*

#### 15. 事务
1. 原子性（Atomicity）
    执行数据库一条操作时，要么全做，要么全不做
2. 隔离性（Isolation）
    数据库中其它的状态转换不会影响到本次状态转换
3. 一致性（Consistency）
    如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的，或者说符合一致性的。
4. 持久性（Durability）
   持久性 意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来，不论之后发生了什么事故，本次转换造成的影响都不应该被丢失掉
5. 如何保持保证数据库中数据的一致性？
   - 数据库本身能为我们保证一部分一致性需求
        自带的：如唯一索引，重复值时会报错
        定义触发器的方式来自定义一些约束条件以保证数据库中数据的一致性
   - 更多的一致性需求需要靠写业务代码的程序员自己保证
        业务层面实现
6. ACID关系
   - 数据库某些操作的原子性和隔离性都是保证一致性的一种手段
   - 满足 原子性 和 隔离性 的操作不一定满足一致性
7. 事务
    需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称之为一个事务（ transaction ）
8. 事务的状态转换
   - 活动的（active）
    事务对应的数据库操作正在执行过程中
   - 部分提交的（partially committed）
    当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时
   - 失败的（failed）
    当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行
   - 中止的（aborted）
    如果事务执行了半截而变为 失败的 状态，就要撤销失败事务对当前数据库造成的影响，即回滚。而当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。
   - 提交的（committed）
    当一个处在 部分提交的 状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了 提交的 状态。
   - 只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。
9. 开启事务
   - *BEGIN [WORK];*
   - *START TRANSACTION;*：可以添加修饰符
       - READ ONLY：只读事务，属于该事务的数据库操作只能读取数据，注意只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，可以增删改临时表即CREATE TMEPORARY TABLE创建的表
       - READ WRITE：属于该事务的数据库操作既可以读取数据，也可以修改数据
       - WITH CONSISTENT SNAPSHOT ：启动一致性读
       - 使用逗号将 修饰符 分开，默认事务的访问模式就是 读写 模式
10. 提交事务
    *COMMIT [WORK]*
11. 手动中止事务
    *ROLLBACK [WORK]*
    ROLLBACK 语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚。
12. 支持事务的存储引擎
    只有 InnoDB 和 NDB 存储引擎支持，该使用不支持事务的存储引擎的表所做的修改将无法进行回滚。
13. 自动提交
    - *SHOW VARIABLES LIKE 'autocommit';*
    - 默认情况下，如果我们不显式的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的 自动提交 
    - 关闭自动提交
      - 显式的的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务
      - 把系统变量 autocommit 的值设置为 OFF 
      - 直到我们显式的写出 COMMIT 语句来把这个事务提交掉，或者显式的写出 ROLLBACK 语句来把这个事务回滚掉
14. 隐式提交
    - 因为某些特殊的语句而导致事务提交的情况称为 隐式提交
    - 定义或修改数据库对象的数据定义语言（DDL）
        CREATE 、ALTER 、 DROP等去修改 数据库 、 表 、 视图 、 存储过程，就会隐式的提交前边语句所属于的事务
    - 隐式使用或修改 mysql 数据库中的表
         ALTER USER 、 CREATE USER 、 DROP USER 、 GRANT 、 RENAME USER 、 REVOKE 、 SETPASSWORD
    - 事务控制或关于锁定的语句
         START TRANSACTION 、BEGIN， autocommit ，LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句
    - 加载数据的语句
        LOAD DATA 语句来批量往数据库中导入数据
    - 关于 MySQL 复制的一些语句
         START SLAVE 、 STOP SLAVE 、 RESET SLAVE 、 CHANGE MASTER TO 
    - 其它的一些语句
         ANALYZE TABLE 、 CACHE INDEX 、 CHECK TABLE 、 FLUSH 、 LOAD INDEX INTO CACHE 、 OPTIMIZE TABLE 、 REPAIR TABLE 、 RESET等等
15. 保存点
    - 保存点：在调用 ROLLBACK 语句时可以指定会滚到哪个点，而不是回到最初的原点。
    - 创建：*SAVEPOINT 保存点名称;*
    - 回滚：*ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;*
    - 删除：*RELEASE SAVEPOINT 保存点名称;*
#### 16.redo日志
1. 如何保持持久性
   - 简单方法:在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘
   - 缺点
        - 在 InnoDB 中是以页为单位来进行磁盘IO的，刷新一个完整的数据页太浪费了
        - 随机IO刷起来比较慢
   - 没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好
2. redo日志（重做日志）
   - 记录事务对数据库做了哪些修改的日志，只将该事务执行过程中产生的 redo 日志刷新到磁盘（事务可能有多个数据库操作，一个数据库操作可能有多个步骤）
   - 优点
       - redo 日志占用的空间非常小
            存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的
       - redo 日志是顺序写入磁盘的
            在执行事务的过程中，每执行一条语句，就可能产生若干条 redo 日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO
3. redo日志格式
   - type ：该条 redo 日志的类型。
   - space ID ：表空间ID。
   - page number ：页号。
   - data ：该条 redo 日志的具体内容。
4. 物理日志（简单日志）
   - 记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容时什么
   - data里包括：偏移量，具体数据（MLOG_8BYTE）或者具体数据占用的字节数，偏移量，具体数据（MLOG_WRITE_STRING）
5. 逻辑日志
   - 插入一条语句会导致的改变非常多
     - 会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的 B+ 树），如系统数据页面的一些统计数据
     - 表中包含多少个索引，一条 INSERT 语句就可能更新多少棵 B+ 树
     - 针对某一棵 B+ 树来说，既可能更新叶子节点页面（添加数据），也可能更新内节点页面（添加目录项记录），也可能创建新的页面（页空间不足，页分裂）
     - 具体表现
       - 可能更新 Page Directory 中的槽信息
       - Page Header 中的各种页面统计信息
       - 数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的 next_record 属性来维护这个单向链表
       - 等等
   - 为什么需要逻辑日志？
        插入一条语句会导致的改变非常多，如果每个操作都记录一条redo日志占用的空间非常大
   - 逻辑日志
        只记录一些必要的要素，而不像物理日志一样记录所有操作。系统奔溃重启时，需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复
   - 逻辑日志的一些种类
      - 插入一条记录时的redo日志
      - 删除一条记录时的redo 日志
      - ...
6. 以组的形式写入redo日志（如何通过redo日志保证事务的原子性？）
   - 规定在执行这些需要保证原子性的操作时必须以组的形式来记录redo 日志，在该组中的最后一条 redo 日志后边加上一条特殊类型的 redo 日志来表示一次原子性的操作。这样系统奔溃重启进行恢复时，当解析到该条特殊的日志时才认为解析到了一组完整的 redo 日志，才会进行恢复。否则的话直接放弃前边解析到的 redo 日志。
   - 举例
       - 向聚簇索引对应 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。
       - 向某个二级索引对应 B+ 树的页面中插入一条记录时产生的 redo 日志是不可分割的。
7. 不可分割是什么意思？
   - 乐观插入
      定位到具体的数据页之后，如果该数据页的剩余的空闲空间充足，直接插入，并记录一条redo日志
   - 悲观插入
       该数据页剩余的空闲空间不足，需要页分裂，设计数据复制，插入节点，添加目录项记录等多个操作即多条redo日志
   - 比分悲观插入的这些操作应该是原子性的不可分割的
8. Mini-Transaction（MTR）（如何保证事务的原子性？）
   - 对底层页面中的一次原子访问的过程称之为一个 Mini-Transaction
   - 一个事务可以包含若干条语句，每一条语句其实是由若干个 mtr 组成，一个所谓的 mtr 可以包含一组 redo 日志，在进行奔溃恢复时这一组 redo 日志作为一个不可分割的整体。
9. redo log block
    通过 mtr 生成的 redo 日志都放在了大小为 512字节的 页 又称block中。
10. redo日志缓冲区
    为了解决磁盘速度过慢的问题，写入 redo 日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为 redo log buffer 的连续内存空间， redo日志缓冲区，即log buffer 。这片内存空间被划分成若干个连续的 redo log block。
11. 如何向redo日志缓冲区中写入redo日志？
    顺序写入，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。并不是每生成一条 redo 日志，就将其插入到 log buffer 中，而是每个 mtr 运行过程中产生的日志先暂时存到一个地方，当该 mtr 结束的时候，将过程中产生的一组 redo 日志再全部复制到 log buffer 中。
12. 并发执行（实际事务执行过程）
    不同的事务可能是并发执行的，所以 T1 、 T2 之间的 mtr 可能是交替执行的。每当一个 mtr 执行完成时，伴随该 mtr 生成的一组 redo 日志就需要被复制到 log buffer 中，也就是说不同事务的 mtr 可能是交替写入 logbuffer 的
13. redo日志刷盘时机
    - log buffer 空间不足时（通过系统变量 innodb_log_buffer_size 指定）
    - 事务提交时（保持持久性）
        事务提交时可以不把修改过的 Buffer Pool 页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的 redo 日志刷新到磁盘
    - 后台线程刷新
    - 正常关闭服务器时
    - 做所谓的 checkpoint 时
14. redo日志文件组
    磁盘上的 redo 日志文件不只一个，而是以一个 日志文件组 的形式出现的。循环写入。为了避免覆盖，提出了checkpoint的概念
15. redo日志文件格式
    将logbuffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中，所以 redo 日志文件其实也是由若干个 512 字节大小的block组成。
16. LSN日志序列号
    在向 log buffer 中写入 redo 日志时不是一条一条写入的，而是以一个 mtr 生成的一组 redo 日志为单位进行写入的。每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。
17. 如何标记哪些日志被刷新到磁盘中了？
    通过比较两个全局变量，即通过比较LSN和flushed_to_disk_lsn，如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。
18. flush链表中的LSN
    一次mtr结束时会把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表，flush链表中的脏页按照第一次修改发生的时间顺序进行排序，即按照oldest_modification的LSN值排序(由大到小，即每次插入头部)。同时也会记录最新的一次修改的LSN值即newest_modification
19. checkpoint
    - 判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。
    - 如果一个页被刷新到了磁盘，那么其对应的mtr的redo日志就可以被覆盖了，即可以增加checkpoint_lsn，我们把这个过程称之为做一次 checkpoint。在flush链表中，是按照最早被修改的LSN，由大到小排序的，所以如果链表的尾节点的控制块对应的脏页被刷新到了磁盘上，那么更新该脏页的最早被修改的LSN给checkpoint_lsn。即说明小于该值的脏页都已经被刷新到了磁盘上了，对应的redo日志都可以被覆盖了。
    - 一般情况下都是后台的线程在对 LRU链表 和 flush链表 进行刷脏操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。如果修改十分频繁，则需要用户线程来进行刷脏页的操作
20. 查看系统中的各种LSN值
    *SHOW ENGINE INNODB STATUS*
21. innodb_flush_log_at_trx_commit的用法(维持持久性会很明显的降低数据库性能)
    - 为了保证事务的 持久性 ，用户线程在事务提交时需要将该事务执行过程中产生的所有 redo 日志都刷新到磁盘上。这一条要求太狠了，会很明显的降低数据库性能
    - 对事务的 持久性 要求不是那么强烈的话，可以选择修改一个称为 innodb_flush_log_at_trx_commit 的系统变量的值
    - 0 ：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步 redo 日志，这个任务是交给后台线程做的
    - 1:当该系统变量值为1时，表示在事务提交时需要将 redo 日志同步到磁盘，可以保证事务的 持久性 。 1也是 innodb_flush_log_at_trx_commit 的默认值。
    - 2 ：当该系统变量值为2时，表示在事务提交时需要将 redo 日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘
    - 2保证数据库挂了，操作系统没挂的话，事务的 持久性 还是可以保证的，但是操作系统也挂了的话，那就不能保证持久性了。
22. 崩溃恢复
    服务器不崩溃的情况下,redo日志会使得性能变差,但如果服务器崩溃,那么redo日志很有作用
23. 确定恢复的起点
    需要从 checkpoint_lsn 开始读取 redo 日志来恢复页面,即小于checkpoint_lsn的控制块对应的脏页都已经被刷新到磁盘了
24. 确定恢复的终点
    写redo日志时是顺序写入block中,block里记录有该block占用的空间大小,满的block是512字节,那么只要恢复到该值不是512的block就行了
25. 如何进行崩溃恢复?
    - 确定恢复的起点
    - 确定恢复的终点
    - 按照redo 日志的顺序依次扫描checkpoint_lsn 之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。
    - 也可以使用哈希表将同一个页面的redo日志一次性回复,避免了很多读取页面的随机IO
    - 跳过已经刷新到磁盘的页面,页面头记录这最近修改页面时对应的LSN值,该值小于checkpoint_lsn的页面就不用恢复了

#### 17.undo日志
1. 通过事务回滚来保证原子性
   - 事务执行过程中可能遇到各种错误及手动ROLLBACK都会导致事务执行到一半就结束
   - 为了保证事务的原子性，我们需要把东西改回原先的样子，称之为 回滚（rollback）
   - 而回滚需要使用undo日志
2. undo日志(撤销日志)
   - 为了回滚而记录的一些数据称之为撤销日志
   - 查询操作（ SELECT ）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的 undo日志
   - 一般每对一条记录做一次改动，就对应着一条 undo日志 ，但在某些更新记录的操作中，也可能会对应着2条 undo日志
   - undo日志 是被记录到类型为 FIL_PAGE_UNDO_LOG页面中，页面可以从系统表空间中分配，也可以从一种专门存放 undo日志 的表空间，也就是所谓的 undo tablespace 中分配
3. 事务id
   - 某个事务执行过程中对某个表执行了增、删、改操作，那么 InnoDB 存储引擎就会给它分配一个独一无二的事务id
       - 对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个 事务id ，否则的话是不分配 事务id 的
       - 对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个 事务id ，否则的话也是不分配 事务id 的
   - 执行SELECT语句过程中用到的注意内部临时表和手动用CREATE TEMPORARY TABLE创建用户临时表不同。在事务回滚时并不需要把执行SELECT语句过程中用到的内部临时表也回滚，在执行SELECT语句用到内部临时表时并不会为它分配事务id。
4. 事务id是怎么生成的（类似于row_id）
   - 服务器会在内存中维护一个全局变量，每次会把该值作为事务id分配给该事务，该变量自增1
   - 记录到系统表空间即磁盘中
   - 系统重新启动时将该全局变量加载到内存中
5. trx_id隐藏列
   - InnoDB 记录行格式，聚簇索引记录中除完整的用户数据外，还包含trx_id、roll_pointer、row_id（无主键时）的隐藏列
   - trx_id即某个对这个聚簇索引记录做改动的语句所在的事务对应的事务id
6. table id
    - 每个表都会被分配一个唯一的 table id
    - 可以通过系统数据库information_schema 中的 innodb_sys_tables 表来查看某个表对应的 table id 
7.  INSERT操作对应的undo日志（TRX_UNDO_INSERT_REC）
    - 回滚插入操作，即删除插入的undo日志，也就是说在写对应的undo日志时，主要是把这条记录的主键信息记上
    - 注意当我们向某个表中插入一条记录时，实际上需要向聚簇索引和所有的二级索引都插入一条记录。回滚时，也有删除聚簇索引和所有的二级索引的对应的记录。（但由于两者都含有主键信息，所以其实是一一对应的）
    - 部分结构
      - undo no
            在一个事务中从0开始递增
      - 主键各列信息
            记录中的主键包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下
      - table id
      - roll pointer
            本质上就是一个指向记录对应的undo日志的一个指针（一般一次改动对应一个undo日志，所有的行中都有隐藏的roll pointer）
