#### 算法学习

#### 主要用来分类记录学习过的算法题和大致思路
#### 常考数据结构知识点
1. 二叉搜索树（二叉排序树，二叉查找树）
   - 定义
      ![1657074267116](image/算法学习/1657074267116.png)
      若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
      若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
      它的左右子树也分别为二叉搜索树
   - 特征
      二叉搜索树中序遍历的结果是有序增大的
   - 性能
     - 对于同一组数据，我们可以构建各种不同的二叉查找树，因此插入、删除和查找操作的执行效率也不同
     - 在最糟糕情况下，根节点的左右子树极度不平衡，已经退化为了链表，因此，查找的时间复杂度就变成了O(n)。在理想情况下（二叉查找树为满二叉树），查找的时间复杂度为O(logn)。
      ![1657074351545](image/算法学习/1657074351545.png)
   - 删除
         将删除节点的左孩子放到删除节点的右子树的最左面节点的左孩子上，要删除的节点的右孩子为新的根节点
         同样适用于红黑树和AVL树
2. 为什么哈希表不能替代二叉查找树（哈希表和二叉树的应用场景）
   - 无序与有序
      哈希表中的数据是无序存储的，如果要输出有序数据序列，需要先进行排序，或者配合有序链表来使用。而对于二叉查找树，我们只需要进行中序遍历，就可以在O(n)的时间复杂度内，输出有序数据序列。
   - 稳定性
      哈希表扩容耗时很多，而且当遇到哈希冲突时，性能不稳定。而对于二叉查找树，如果用**平衡二叉树**就非常稳定，时间复杂度稳定在O(logn
   - 性能
      O(logn)的算法并不一定比O(1)的算法运行速度慢。尽管哈希表上操作的时间复杂度是常量级的，但因为哈希冲突的存在，再加上哈希函数的计算耗时，哈希表并不一定就比平衡二叉树效率高
   - 设计要素
      哈希表的构造比二叉查找树复杂，需要考虑的东西很多，如哈希函数的设计、冲突解决方法、扩容和缩容等。平衡二叉树只需要考虑如何维护平衡性
3. 平衡二叉查找树（AVL树）
   - 二叉树中任意一个节点的左右子树的高度相差不能大于1，且满足二叉查找树的特点
   - 用途：解决一般二叉查找树退化为链表，查找复杂度为O(n)的情况，使得整棵树尽量矮胖，最坏情况下也保持O(LogN)的时间复杂度实现查找
4. B树（BalanceTree，平衡多路查找树）
5. 2-3树
   是B树的一种，同时也是一颗绝对平衡的树，节点可以存放一个或两个元素,每个节点有2个或3个孩子
      ![1657075340159](image/算法学习/1657075340159.png)
6. 2-3-4树
   阶数为4的B树
   二节点（孩子有2个，自己节点有1个元素），三节点，四节点
   ![1657075448021](image/算法学习/1657075448021.png)
7. 红黑树
   - 红黑树其实就是对概念模型2-3树（或者2-3-4树）的一种实现
      - 2-3-4树
         2节点转化为红黑树中的黑节点，3节点可以表示为左倾红节点或者右倾红节点，4节点必须树平衡，一黑带两红
      - 2-3树(只考虑左倾红黑树)
         - 2节点转化为红黑树中的黑节点，3节点只表示为左倾红节点
         - 只要把左倾红黑树中的红色节点顺时针方向旋转45°使其与黑父平行，然后再将它们看作一个整体，就是一颗2-3树！（因为2-3是绝对平衡的，转一下就变成AVL树）
            ![1657076376562](image/算法学习/1657076376562.png)
         - 2-3插入原则
              插入2节点，插入后变为3节点
              插入3节点，插入后变为4节点（临时），再分裂
              对应红黑树将插入的节点涂成红色与黑色父节点关联，形成概念模型2-3树中的3节点或者临时4节点
         - 2-3删除原则
              3节点直接删除
              2节点根据父节点和兄弟节点是2节点还是3节点分为3种情况
               ![1657083306796](image/算法学习/1657083306796.png)
   - 左倾红黑树的好处
      - 左倾红黑树限制了如果在树中出现了红色节点，那么这个节点必须是左儿子。
      - 如果父节点为红色，就不用考虑其右倾兄弟的情况，将插入操作变得简单
   - 红黑树5条定义
      - 节点颜色有红色与黑色
           **2节点转化为红黑树中的黑节点，3节点可以表示为左倾红节点**
      - 根节点必为黑色
          2-3树中如果根节点为2节点，那么它本来就对应红黑树中黑节点；如果根节点为3节点，也可以用黑色节点表示较大的那个元素，然后较小的元素作为左倾红节点存在于红黑树中
      - 所有叶子节点（NIL）都是黑色
      - 任意节点到叶子节点经过的黑色节点数目相同
          红黑树中的红节点是和黑色父节点绑定的，在2-3树中本来就是同一层的，而只有黑色节点才会在2-3树中真正贡献高度，由于2-3树的任一节点到空链接距离相同，因此在红黑树中就是黑色完美平衡
      - 不会有连续的红色节点
          2-3中不会产生连续红节点
   - 红黑树的旋转
      右旋和左旋，以某个节点旋转，相当于先旋转该节点和其左右两个子节点，再分配子节点的节点
   - 红黑树的插入
      - 插入元素比黑父大
         插在了黑父的右边，而黑父左边是红色儿子。这种情况会导致在红黑树中出现右倾红节点。对应着2-3树中出现了临时4节点这个临时4节点分裂，左右元素各自形成一个2节点，中间元素上升到上层跟父节点结合。所以，我们在红黑树中的动作是，将原本红色的左右儿子染黑（左右分裂），将黑父染红（等待上升结合）。
     - 插入元素比红父小，且红父为左倾
         插在红父左边导致连续的红节点，先右旋，再左右互换颜色，再到情况1
     - 插入元素比红父大，且红父为左倾
         插在红父右边，形成右倾，先左旋，再按情况2处理
   - 红黑树的删除
      和一般二叉搜索树一样，当我们要删除某个节点的时候选择它的前驱节点或者后继节点元素来替代它，转而删除它的前驱/后继节点
      **太复杂了不看了**
8. 红黑树和AVL树的区别
   - 调整平衡的实现机制不同
     - 红黑树根据节点颜色(同一父节点出发到叶子节点，所有路径上的黑色节点数目一样)，一些约定和旋转实现；
     - AVL根据树的平衡因子(所有节点的左右子树高度差的绝对值不超过1)和旋转决定
   - 红黑树的插入效率更高
     - 红黑树是用**非严格的平衡**(黑色完全平衡，整体高度差可以大于1)来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，空间开销比较小，即维护成本低
     - 而AVL是**严格平衡树**，因此在增加或者删除节点的时候需要大量的旋转操作来保持平衡，因此空间开销大，即维护成本高
   - 使用场景不同
     - 若查询的频率远远大于（>）插入和删除，应该选择AVL树
     - 若查询的频率小于等于（<=）插入和删除的频率，应该选择RB树
#### 二分法
1. 前提
   - 有序数组
   - 数组内无重复元素，有重复时下标不唯一
2. 循环不变量原则
   - [left,right]
   - [left,rigth)
3. 复杂度
    二分空间复杂度O(1),时间复杂度O(logn)
4. 解题
   - 注意[left,right]原则，while(left <= right),循环结束后left比right大1
   - 防止溢出:int middle = left + ((right-left)/2); 
   - 一些特殊情况，如数组大小为0或者为1时
5. 704二分查找
   一般的二分
6. 27移除元素
   不存在元素时，返回的位置应该是right + 1
7. 33搜索旋转排序数组
   按照[left, mid] 或者 [mid, right]查找，并且只查找这两个区间时有序的情况，要么左边有序要么右边有序，一直循环查找
8. 4寻找两个正序数组的中位数
   - 思路
      - 两个数组A,B大小：m,n;寻找中位数下标为(m+n)/2 或 (m+n)/2+1。即寻找第k小的值，k=(m+n)/2 + 1或 (m+n)/2+2，注意k代表的是第几个而不是下标!
      比较A[k/2−1]和B[k/2−1]，对于A[k/2−1]和B[k/2−1] 中的较小值，最多只会有(k/2-1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第k小的数了
      - 对于两种情况，排除了k/2个不可能是第k+1小的值，继续对剩下的元素二分
         A[k/2−1] <= B[k/2−1],排除A[0]到A[k/2−1]
         A[k/2−1] > B[k/2−1],排除B[0]到B[k/2−1]
      - 特殊情况
         - 越界时，k不能直接减去k/2
               int newIndex1 = min(index1 + k / 2 - 1, m - 1);
         - A或B排除完时，就直接从另一个数组内读取
         - k=1，即返回两个数组首元素的最小值
   - 注意
      偶数情况，要除以2.0而不是2！
9.  69x 的平方根 
   - 二分法，mid值连续逼近
      if(mid < x / mid)防止溢出
   - 牛顿迭代法，如果要保留小数的话就需要用牛顿迭代法O(logn)
      xi+1 = 1/2(xi + C / xi)
      当相邻两次迭代得到的交点非常接近1e-6时break
      fabs:<math.h>
      注意牛顿法定义值必须都定义为double，否则int相除还是为整数导致错误
10. 34在排序数组中查找元素的第一个和最后一个位置
    - 分别查找左右界，对于查找右界的情况，则左边界在nums[mid] == target的情况下也要右移，这样最后退出循环的右界就是左边界-1。左界同理。
    - 判断在前或者在后的情况：设定初值int rightBorder = -2;两个有一个为-2则说明没有该目标值
    - 判断在范围内并且有：(rightBorder - leftBorder)>1，这时两个边界一个在左一个在右
11. 162寻找峰值
   因为nums[-1] = nums[n] = −∞，所以如果单调递增必有峰值，如果先增后减也必有峰值。如果nums[mid] > nums[mid + 1]则左边必有峰值，right = mid。而nums[mid] < nums[mid + 1]则右边必有峰值，left = mid + 1。当left == right时就是要返回的峰值。
12. 240搜索二维矩阵II
    - 二分法O(mlogn)
      对每行进行二分
    - z字法O(m + n)
      从右上角开始，如果当前值大于target则向左走即col--，如果小于则向下走即row++,直到遇到target

#### 链表
1. 定义
   **一般手写输入为test(ListNode *head, ...){}**
   ```
   struct ListNode {
      int val;
      ListNode* next;
      ListNode(int x) : val(x), next(NULL) {}
   };
2. 性能分析
   - 数组
   插入/删除时间复杂度O(n)，查询时间复杂度O(1),适用于数据量固定，查找频繁，较少增删的场景
   - 链表
   插入/删除时间复杂度O(1)，查询时间复杂度O(n),适用于数据量不固定，频繁增删，较少查询的场景
3. 虚拟头结点
   便于统一处理链表中的节点
   ListNode* dummyNode = new ListNode(0);
   dummyNode->next = head;
   ...
   head = dummyNode->next;
   delete dummyNode;
   return head;
4. ACM链表写法
5. 203移除链表元素
   使用dummyNode，while(cur->next != NULL)循环删除节点，注意最后也要删除dummyNode，返回dummyNode->next作为头节点
6. 707设计链表
   class MyLinkedList {
      public:...
      private:
         int m_size;
         int m_dummyNode;
   }
   由于创建时都是通过new进行创建的，所以删除时使用ListNode *tmp = cut->next;再delete tmp;
7. 206反转链表
   - 双指针法，tmp用于记录cur->next的地址，pre用于记录之前的地址
   - 递归法,ListNode* reverse(ListNode* pre, ListNode* cur),思路一致，通过递归实现赋值
8. 24两两交换链表中的节点
   - 一般模拟：tmp记录第一个真实节点，tmp1记录第三个真实节点，使用dummyNode方便遍历
   - 递归法，ListNode* swapPairs(ListNode* head)，每次递归返回交换**完成后**的子链表的头节点  