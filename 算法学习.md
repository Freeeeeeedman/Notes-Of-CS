#### 算法学习

#### 主要用来分类记录学习过的算法题和大致思路

#### 二分法
1. 前提
   - 有序数组
   - 数组内无重复元素，有重复时下标不唯一
2. 循环不变量原则
   - [left,right]
   - [left,rigth)
3. 复杂度
    二分空间复杂度O(1),时间复杂度O(logn)
4. 解题
   - 注意[left,right]原则，while(left <= right),循环结束后left比right大1
   - 防止溢出:int middle = left + ((right-left)/2); 
   - 一些特殊情况，如数组大小为0或者为1时
5. 704二分查找
   一般的二分
6. 27移除元素
   不存在元素时，返回的位置应该是right + 1
7. 33搜索旋转排序数组
   按照[left, mid] 或者 [mid, right]查找，并且只查找这两个区间时有序的情况，要么左边有序要么右边有序，一直循环查找
8. 4寻找两个正序数组的中位数
   - 思路
      - 两个数组A,B大小：m,n;寻找中位数下标为(m+n)/2 或 (m+n)/2+1。即寻找第k小的值，k=(m+n)/2 + 1或 (m+n)/2+2，注意k代表的是第几个而不是下标!
      比较A[k/2−1]和B[k/2−1]，对于A[k/2−1]和B[k/2−1] 中的较小值，最多只会有(k/2-1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第k小的数了
      - 对于两种情况，排除了k/2个不可能是第k+1小的值，继续对剩下的元素二分
         A[k/2−1] <= B[k/2−1],排除A[0]到A[k/2−1]
         A[k/2−1] > B[k/2−1],排除B[0]到B[k/2−1]
      - 特殊情况
         - 越界时，k不能直接减去k/2
               int newIndex1 = min(index1 + k / 2 - 1, m - 1);
         - A或B排除完时，就直接从另一个数组内读取
         - k=1，即返回两个数组首元素的最小值
   - 注意
      偶数情况，要除以2.0而不是2！
9.  69x 的平方根 
   - 二分法，mid值连续逼近
      if(mid < x / mid)防止溢出
   - 牛顿迭代法，如果要保留小数的话就需要用牛顿迭代法O(logn)
      xi+1 = 1/2(xi + C / xi)
      当相邻两次迭代得到的交点非常接近1e-6时break
      fabs:<math.h>
      注意牛顿法定义值必须都定义为double，否则int相除还是为整数导致错误
10. 34在排序数组中查找元素的第一个和最后一个位置
    - 分别查找左右界，对于查找右界的情况，则左边界在nums[mid] == target的情况下也要右移，这样最后退出循环的右界就是左边界-1。左界同理。
    - 判断在前或者在后的情况：设定初值int rightBorder = -2;两个有一个为-2则说明没有该目标值
    - 判断在范围内并且有：(rightBorder - leftBorder)>1，这时两个边界一个在左一个在右
11. 162寻找峰值
   因为nums[-1] = nums[n] = −∞，所以如果单调递增必有峰值，如果先增后减也必有峰值。如果nums[mid] > nums[mid + 1]则左边必有峰值，right = mid。而nums[mid] < nums[mid + 1]则右边必有峰值，left = mid + 1。当left == right时就是要返回的峰值。
12. 240搜索二维矩阵II
    - 二分法O(mlogn)
      对每行进行二分
    - z字法O(m + n)
      从右上角开始，如果当前值大于target则向左走即col--，如果小于则向下走即row++,直到遇到target

#### 链表
1. 定义
   **一般手写输入为test(ListNode *head, ...){}**
   ```
   struct ListNode {
      int val;
      ListNode* next;
      ListNode(int x) : val(x), next(NULL) {}
   };
2. 性能分析
   - 数组
   插入/删除时间复杂度O(n)，查询时间复杂度O(1),适用于数据量固定，查找频繁，较少增删的场景
   - 链表
   插入/删除时间复杂度O(1)，查询时间复杂度O(n),适用于数据量不固定，频繁增删，较少查询的场景
3. 虚拟头结点
   便于统一处理链表中的节点
   ListNode* dummyNode = new ListNode(0);
   dummyNode->next = head;
   ...
   head = dummyNode->next;
   delete dummyNode;
   return head;
4. ACM链表写法
5. 203移除链表元素
   使用dummyNode，while(cur->next != NULL)循环删除节点，注意最后也要删除dummyNode，返回dummyNode->next作为头节点
6. 707设计链表
   class MyLinkedList {
      public:...
      private:
         int m_size;
         int m_dummyNode;
   }
   由于创建时都是通过new进行创建的，所以删除时使用ListNode *tmp = cut->next;再delete tmp;
7. 206反转链表
   - 双指针法，tmp用于记录cur->next的地址，pre用于记录之前的地址
   - 递归法,ListNode* reverse(ListNode* pre, ListNode* cur),思路一致，通过递归实现赋值
8. 24两两交换链表中的节点
   - 一般模拟：tmp记录第一个真实节点，tmp1记录第三个真实节点，使用dummyNode方便遍历
   - 递归法，ListNode* swapPairs(ListNode* head)，每次递归返回交换**完成后**的子链表的头节点  