

### 算法学习，主要用来分类记录学习过的算法题和大致思路
### 应试
1. string
   - 数组内每个值为char类型，可以和char类型相加
   - tolower(ch), toupper(ch)
   - 整数转string：to_string(n)
   - string转整数：stoi(str)
   - 取字符串str.substr(0, 8),起始位置下标为0，取8位
2. map，set，unordered_map
   - 默认排序key由小到大
   - 插入数据：st.insert(num)，前提 if(uset.count(ch) == 0)否找报错
   - 迭代器数据访问： cout << it->first << " " << it->second << endl;
3. 杂
   - 进制转换：str[i] >= '0' && str[i] <= '9'
   - % 取余， / 整除
   - 质数因子小于等于数开根号的值，1不是质数
   - int(a)强制转换
   - 迭代器循环 for(auto it = mp.begin(); it != mp.end(); ++it) {}
   - 取反reverse(str.begin(), str.end())
   - 循环内按间隔取值for(int i = 0; i < n; i+=8) {}
### ACM模式
####  C++输入输出
1. cin >>
   - 以空格、tab或换行（回车也是换行）作为分隔符
        cin>>a>>b>>c;
   - 也可以接受一个字符串，遇 tab/space/enter 结束
   - int a; cin >> a; 输入字符'1'，a结果也为int类型1

2. getline()
   - 用于按照特定间隔符分割字符串
   - 需包含“#include<string>”
   - getline(istream is, string str, 结束符)， 默认结束符为'\n'
   - 可以读入 SPACE/TAB，遇到ENTER停止读取；且读取完成后会丢弃末尾的换行符
   - cin.getline()属于istream流，而getline()属于string流，是不一样的两个函数
   - 当同时使用cin>>,getline()时，需要注意的是，在cin>>读入数据完成之后，如果接下来的字符是换行符，那么在使用 getline()之前需要用getchar()把换行符吞掉，然后再使用getline()读入下一行数据。否则，getline()会首先读入换行符，然后停止读取。由于getline()函数会丢弃数据末尾的换行符，因此最终读入的数据为空
   - 举例，如果用cin输入abc再enter，那么enter将保留再缓冲区被getline读取，但getline读取时会丢弃最后一个换行符，所以无任何输出


#### 循环输入输出处理常见问题
1. 为什么需要循环输入输出：通常来说OJ对于每道题里面有.in和.out文件，分别表示测试数据的输入和输出。如果某些编程题的所有数据都只做在一个.in和一个.out中，这样就会变成多组测试了，所以需要提交的代码中循环处理。

2. 处理方法：其实这个问题可以避免，就是编程题后台每个样例做一组对应的.in和.out文件，这样就变成单组测试，代码就不需要循环处理，但是平时练习的题目质量不一，这个问题都会出现。(有人在阿里笔试中遇到)

3. 代码里面循环处理了即使是单组测试也会完全没问题，所以为了偷懒，可以全写成循环处理。

4. 还有一个坑：如果测试数据是多组的，但是恰巧你代码里面需要些标记数组，map，set等，在循环内一定记得清空，不然可能会产生前面的测试样例影响了后续数据的答案。


#### 做题时要点总结
1. ACM模式中对应各类格式的输入数据的处理要熟稔
   https://ac.nowcoder.com/acm/contest/5657/G
2. 定义输入变量时一定要先初始化，否则会有随机值
3. 对于一些单次输入，要求输出的结果在循环外初始化，但必须要记得在循环内每次都要清空。
4. 每次循环内要清空数组，map，set， vector， string，cin，stringstream
      - cin.sync();
      - str.clear();
      - ss.clear();
5. 看清楚结果的输出格式，例如循环输出了cout << str << ' ';，但要记得最后还要补加一个**cout << endl**;来区分不同的结果
6. 在处理单组多个字符串时，如果是以空格为分割，用cin结合getchar()就可以了，但如果以其他符号分割，就必须用getline()结合stringstream
7. 审题时一定要注意数据范围，否则结果溢出即使思路对答案也是错误的！
      int                        [-2^31,2^31-1] ~ 2 * 10 ^ 9
      unsigned                   [0,2^32-1]
      long long                  [-2^63,2^63-1]
      unsigned long long         [0,2^64-1]
      char                       [-128,127]

      double        [-2^1024,2^1023] 即 [-1.7E+308,1.7E+308] 精度为16位左右
      long double   [-1.2e4932,1.2e4932] 精度不低于 double


8. 一些头文件
   - #include<bits/stdc++.h>：所有c++标准库的头文件
   - #include <iostream>：cin，cout
   - #include <sstream>：stringstream输入输出流
   - #include <algorithm>：一些算法，如sort()
   - #include <string>:字符串string
9. cin()
   cin >> 以空格，换行，tab为结束符。但是会保留最后一个换行在缓冲区中。同时也不会读取最后一个空格。
10. getline()
   - 用来处理字符串的，输入的必须是字符串
   - 注意getline()默认在处理单行数据时是不以空格为分割的，会全部输入！
   - 在标准输入中连续使用cin>>, getline()时要用getchar()清除前一个cin>>留下的换行。注意如果缓冲区中还要空格也会被读取出来(但是如果用了stringstream流就不需要写getchar())
   - getline使用cin流，以'#'分割，但只会输出#前的字符
   - getline使用stringstream流，就可以正常输出所有以#分割的字符，包括最后一段
11. getchar()
   - 用来读取换行符
12. 使用迭代遍历的方式是!=vec.end();
#### 针对特定输入数据的处理模板
1. 输入数据有多组, 每行表示一组输入数据，没有指明每行有几个数据
   如: 0 1 2 3 4 
       5 6 7 
   ```
   #include <iostream>
   using namespace std;

   int main() {
      int ele = 0;
      while(cin >> ele) {
         cin.sync();
         int sum = ele;
         while(getchar() != '\n') {
               cin >> ele;
               sum += ele;
         }
         cout << sum << endl;
      }
   }
   ```
2. 输入数据有多组，第一行表述数据组数，接下来每行第一个整数表示数据数目，其余表示数据
   3
   3 1 2 3
   2 1 2 
   3 1 3 4
   ```
   #include <iostream>
   using namespace std;

   int main() {
      int t = 0;
      cin >> t;
      int n = 0;
      while(cin >> n) {
         cin.sync();
         int sum = 0, tmp = 0;
         for(int i = 0; i < n; i++) {
               cin >> tmp;
               sum += tmp;
         }
         cout << sum << endl;
      }
   }
   ```

3. 输入数据有多组， 输入的为字符串，以空格为分隔，每行为一组数据
   ```
   #include <iostream>
   #include <algorithm>
   #include <vector>
   #include <string>
   using namespace std;

   int main() {
      vector<string> strs;
      string str;
      while(cin >> str) {
         cin.sync();
         strs.clear();
         strs.push_back(str);
         while(getchar() != '\n') {
               cin >> str;
               strs.push_back(str);
         }
         sort(strs.begin(), strs.end());
         for(auto& str : strs) {
               cout << str << ' ';
         }
         cout << endl;
      }
   }
   ```

4. 输入数据有多组， 输入的为字符串，以','为分隔，每行为一组数据
   ```
   #include <iostream>
   #include <sstream>
   #include <algorithm>
   #include <vector>
   #include <string>
   using namespace std;

   int main() {
      vector<string> strs;
      string str;
      while(getline(cin, str)) {
         strs.clear();
         stringstream ss(str);
         while(getline(ss, str, ',')) {
               strs.push_back(str);
         }
         sort(strs.begin(), strs.end());
         for(int i = 0; i < strs.size() - 1; i++) {
               cout << strs[i] << ',';
         }
         cout << strs[strs.size() - 1] << endl;
      }
      
   }
   ```
5. 数据范围： 0 < a,b < 2 x 10 ^ 10
   ```
   #include <iostream>
   using namespace std;

   int main() {
      long long a = 0, b = 0;
      while(cin >> a >> b) {
         cout << a + b << endl;
      }
   }
   ```




###  算法练习
#### 常考数据结构知识点
1. 二叉搜索树（二叉排序树，二叉查找树）
   - 定义
      ![1657074267116](image/算法学习/1657074267116.png)
      若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
      若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
      它的左右子树也分别为二叉搜索树
   - 特征
      二叉搜索树中序遍历的结果是有序增大的
   - 性能
     - 对于同一组数据，我们可以构建各种不同的二叉查找树，因此插入、删除和查找操作的执行效率也不同
     - 在最糟糕情况下，根节点的左右子树极度不平衡，已经退化为了链表，因此，查找的时间复杂度就变成了O(n)。在理想情况下（二叉查找树为满二叉树），查找的时间复杂度为O(logn)。
      ![1657074351545](image/算法学习/1657074351545.png)
   - 删除
         将删除节点的左孩子放到删除节点的右子树的最左面节点的左孩子上，要删除的节点的右孩子为新的根节点
         同样适用于红黑树和AVL树
2. 为什么哈希表不能替代二叉查找树（哈希表和二叉树的应用场景）
   - 无序与有序
      哈希表中的数据是无序存储的，如果要输出有序数据序列，需要先进行排序，或者配合有序链表来使用。而对于二叉查找树，我们只需要进行中序遍历，就可以在O(n)的时间复杂度内，输出有序数据序列。
   - 稳定性
      哈希表扩容耗时很多，而且当遇到哈希冲突时，性能不稳定。而对于二叉查找树，如果用**平衡二叉树**就非常稳定，时间复杂度稳定在O(logn
   - 性能
      O(logn)的算法并不一定比O(1)的算法运行速度慢。尽管哈希表上操作的时间复杂度是常量级的，但因为哈希冲突的存在，再加上哈希函数的计算耗时，哈希表并不一定就比平衡二叉树效率高
   - 设计要素
      哈希表的构造比二叉查找树复杂，需要考虑的东西很多，如哈希函数的设计、冲突解决方法、扩容和缩容等。平衡二叉树只需要考虑如何维护平衡性
3. 平衡二叉查找树（AVL树）
   - 二叉树中任意一个节点的左右子树的高度相差不能大于1，且满足二叉查找树的特点
   - 用途：解决一般二叉查找树退化为链表，查找复杂度为O(n)的情况，使得整棵树尽量矮胖，最坏情况下也保持O(LogN)的时间复杂度实现查找
4. B树（BalanceTree，平衡多路查找树）
5. 2-3树
   是B树的一种，同时也是一颗绝对平衡的树，节点可以存放一个或两个元素,每个节点有2个或3个孩子
      ![1657075340159](image/算法学习/1657075340159.png)
6. 2-3-4树
   阶数为4的B树
   二节点（孩子有2个，自己节点有1个元素），三节点，四节点
   ![1657075448021](image/算法学习/1657075448021.png)
7. 红黑树
   - 红黑树其实就是对概念模型2-3树（或者2-3-4树）的一种实现
      - 2-3-4树
         2节点转化为红黑树中的黑节点，3节点可以表示为左倾红节点或者右倾红节点，4节点必须树平衡，一黑带两红
      - 2-3树(只考虑左倾红黑树)
         - 2节点转化为红黑树中的黑节点，3节点只表示为左倾红节点
         - 只要把左倾红黑树中的红色节点顺时针方向旋转45°使其与黑父平行，然后再将它们看作一个整体，就是一颗2-3树！（因为2-3是绝对平衡的，转一下就变成AVL树）
            ![1657076376562](image/算法学习/1657076376562.png)
         - 2-3插入原则
              插入2节点，插入后变为3节点
              插入3节点，插入后变为4节点（临时），再分裂
              对应红黑树将插入的节点涂成红色与黑色父节点关联，形成概念模型2-3树中的3节点或者临时4节点
         - 2-3删除原则
              3节点直接删除
              2节点根据父节点和兄弟节点是2节点还是3节点分为3种情况
               ![1657083306796](image/算法学习/1657083306796.png)
   - 左倾红黑树的好处
      - 左倾红黑树限制了如果在树中出现了红色节点，那么这个节点必须是左儿子。
      - 如果父节点为红色，就不用考虑其右倾兄弟的情况，将插入操作变得简单
   - 红黑树5条定义
      - 节点颜色有红色与黑色
           **2节点转化为红黑树中的黑节点，3节点可以表示为左倾红节点**
      - 根节点必为黑色
          2-3树中如果根节点为2节点，那么它本来就对应红黑树中黑节点；如果根节点为3节点，也可以用黑色节点表示较大的那个元素，然后较小的元素作为左倾红节点存在于红黑树中
      - 所有叶子节点（NIL）都是黑色
      - 任意节点到叶子节点经过的黑色节点数目相同
          红黑树中的红节点是和黑色父节点绑定的，在2-3树中本来就是同一层的，而只有黑色节点才会在2-3树中真正贡献高度，由于2-3树的任一节点到空链接距离相同，因此在红黑树中就是黑色完美平衡
      - 不会有连续的红色节点
          2-3中不会产生连续红节点
   - 红黑树的旋转
      右旋和左旋，以某个节点旋转，相当于先旋转该节点和其左右两个子节点，再分配子节点的节点
   - 红黑树的插入
      - 插入元素比黑父大
         插在了黑父的右边，而黑父左边是红色儿子。这种情况会导致在红黑树中出现右倾红节点。对应着2-3树中出现了临时4节点这个临时4节点分裂，左右元素各自形成一个2节点，中间元素上升到上层跟父节点结合。所以，我们在红黑树中的动作是，将原本红色的左右儿子染黑（左右分裂），将黑父染红（等待上升结合）。
     - 插入元素比红父小，且红父为左倾
         插在红父左边导致连续的红节点，先右旋，再左右互换颜色，再到情况1
     - 插入元素比红父大，且红父为左倾
         插在红父右边，形成右倾，先左旋，再按情况2处理
   - 红黑树的删除
      和一般二叉搜索树一样，当我们要删除某个节点的时候选择它的前驱节点或者后继节点元素来替代它，转而删除它的前驱/后继节点
      **太复杂了不看了**
8. 红黑树和AVL树的区别
   - 调整平衡的实现机制不同
     - 红黑树根据节点颜色(同一父节点出发到叶子节点，所有路径上的黑色节点数目一样)，一些约定和旋转实现；
     - AVL根据树的平衡因子(所有节点的左右子树高度差的绝对值不超过1)和旋转决定
   - 红黑树的插入效率更高
     - 红黑树是用**非严格的平衡**(黑色完全平衡，整体高度差可以大于1)来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，空间开销比较小，即维护成本低
     - 而AVL是**严格平衡树**，因此在增加或者删除节点的时候需要大量的旋转操作来保持平衡，因此空间开销大，即维护成本高
   - 使用场景不同
     - 若查询的频率远远大于（>）插入和删除，应该选择AVL树
     - 若查询的频率小于等于（<=）插入和删除的频率，应该选择RB树
#### 二分法
1. 前提
   - 有序数组
   - 数组内无重复元素，有重复时下标不唯一
2. 循环不变量原则
   - [left,right]
   - [left,rigth)
3. 复杂度
    二分空间复杂度O(1),时间复杂度O(logn)
4. 解题
   - 注意[left,right]原则，while(left <= right),循环结束后left比right大1
   - 防止溢出:int middle = left + ((right-left)/2); 
   - 一些特殊情况，如数组大小为0或者为1时
5. 704二分查找
   一般的二分
6. 27移除元素
   不存在元素时，返回的位置应该是right + 1
7. 33搜索旋转排序数组
   按照[left, mid] 或者 [mid, right]查找，并且只查找这两个区间时有序的情况，要么左边有序要么右边有序，一直循环查找
8. 4寻找两个正序数组的中位数
   - 思路
      - 两个数组A,B大小：m,n;寻找中位数下标为(m+n)/2 或 (m+n)/2+1。即寻找第k小的值，k=(m+n)/2 + 1或 (m+n)/2+2，注意k代表的是第几个而不是下标!
      比较A[k/2−1]和B[k/2−1]，对于A[k/2−1]和B[k/2−1] 中的较小值，最多只会有(k/2-1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第k小的数了
      - 对于两种情况，排除了k/2个不可能是第k+1小的值，继续对剩下的元素二分
         A[k/2−1] <= B[k/2−1],排除A[0]到A[k/2−1]
         A[k/2−1] > B[k/2−1],排除B[0]到B[k/2−1]
      - 特殊情况
         - 越界时，k不能直接减去k/2
               int newIndex1 = min(index1 + k / 2 - 1, m - 1);
         - A或B排除完时，就直接从另一个数组内读取
         - k=1，即返回两个数组首元素的最小值
   - 注意
      偶数情况，要除以2.0而不是2！
9.  69x 的平方根 
   - 二分法，mid值连续逼近
      if(mid < x / mid)防止溢出
   - 牛顿迭代法，如果要保留小数的话就需要用牛顿迭代法O(logn)
      xi+1 = 1/2(xi + C / xi)
      当相邻两次迭代得到的交点非常接近1e-6时break
      fabs:<math.h>
      注意牛顿法定义值必须都定义为double，否则int相除还是为整数导致错误
10. 34在排序数组中查找元素的第一个和最后一个位置
    - 分别查找左右界，对于查找右界的情况，则左边界在nums[mid] == target的情况下也要右移，这样最后退出循环的右界就是左边界-1。左界同理。
    - 判断在前或者在后的情况：设定初值int rightBorder = -2;两个有一个为-2则说明没有该目标值
    - 判断在范围内并且有：(rightBorder - leftBorder)>1，这时两个边界一个在左一个在右
11. 162寻找峰值
   因为nums[-1] = nums[n] = −∞，所以如果单调递增必有峰值，如果先增后减也必有峰值。如果nums[mid] > nums[mid + 1]则左边必有峰值，right = mid。而nums[mid] < nums[mid + 1]则右边必有峰值，left = mid + 1。当left == right时就是要返回的峰值。
12. 240搜索二维矩阵II
    - 二分法O(mlogn)
      对每行进行二分
    - z字法O(m + n)
      从右上角开始，如果当前值大于target则向左走即col--，如果小于则向下走即row++,直到遇到target

#### 链表
1. 定义
   **一般手写输入为test(ListNode *head, ...){}**
   ```
   struct ListNode {
      int val;
      ListNode* next;
      ListNode(int x) : val(x), next(NULL) {}
   };
2. 性能分析
   - 数组
   插入/删除时间复杂度O(n)，查询时间复杂度O(1),适用于数据量固定，查找频繁，较少增删的场景
   - 链表
   插入/删除时间复杂度O(1)，查询时间复杂度O(n),适用于数据量不固定，频繁增删，较少查询的场景
3. 虚拟头结点
   便于统一处理链表中的节点
   ListNode* dummyNode = new ListNode(0);
   dummyNode->next = head;
   ...
   head = dummyNode->next;
   delete dummyNode;
   return head;
4. ACM链表写法
5. 203移除链表元素
   使用dummyNode，while(cur->next != NULL)循环删除节点，注意最后也要删除dummyNode，返回dummyNode->next作为头节点
6. 707设计链表
   class MyLinkedList {
      public:...
      private:
         int m_size;
         int m_dummyNode;
   }
   由于创建时都是通过new进行创建的，所以删除时使用ListNode *tmp = cut->next;再delete tmp;
7. 206反转链表
   - 双指针法，tmp用于记录cur->next的地址，pre用于记录之前的地址
   - 递归法,ListNode* reverse(ListNode* pre, ListNode* cur),思路一致，通过递归实现赋值
8. 24两两交换链表中的节点
   - 一般模拟：tmp记录第一个真实节点，tmp1记录第三个真实节点，使用dummyNode方便遍历
   - 递归法，ListNode* swapPairs(ListNode* head)，每次递归返回交换**完成后**的子链表的头节点  