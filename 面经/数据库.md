### 数据库

---

1.事务隔离级别, 并说明分别解决了什么问题   

2.事务的ACID特性

```
ACID
A(Atomicity): 
事物的原子性, 指一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，如果事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；

C(Consistency): 
指事务执行前后并不改变数据库中数据的一致性. 例如, 完整性约束了 a+b=10, 在一个事务中改变了a, 那么b也应该随之改变

I(Isolation): 
事物的独立性也称作隔离性, 是指两个以上的事务不会出现交错执行的状态, 因为这样可能会导致数据不一致.

D(Durability): 
事务的持久性是指事务执行成功以后, 该事务对数据所做的更改是持久的保存在数据库之中, 不会无缘无故的回滚.
```

3.介绍一下索引 B+树, B树  说一说区别    (B+树节点大, 开销为什么大)   **寄中寄中寄**

```
索引是帮助MySQL高效获取数据的数据结构.索引是对数据库表中一列或多列的值进行排序的一种结构。MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度
简单类比一下,数据库如同书籍，索引如同书籍目录，假如我们需要从书籍查找与 xx 相关的内容，我们可以直接从目录中查找，定位到 xx 内容所在页面，如果目录中没有 xx 相关字符或者没有设置目录（索引），那只能逐字逐页阅读文本查找，效率可想而知。

MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比既存储索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的时候磁盘 I/O次数会更少。(相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少。)
B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。
```

4.**如何保证ACID特性?**

```
1. MySQL如何保证一致性
数据库通过原子性（A）、隔离性（I）、持久性（D）来保证一致性（C）。其中一致性是目的，原子性、隔离性、持久性是手段。因此数据库必须实现AID三大特性才有可能实现一致性。

2. MySQL如何保证原子性
利用InnoDB的undo log
undo log（回滚日志）记录需要回滚的日志信息，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句

3. MySQL如何保证持久性
利用Innodb的redo log
Mysql修改数据的大概流程是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。
最直观的想法，事务提交前直接把数据写入磁盘
这么做有什么问题
浪费资源，只修改一个页面里的一个字节，就要将整个页面刷入磁盘（一个页面16kb，每次改动都需要将16kb的内容刷入磁盘）
速度慢，每个事务里可能涉及到多个数据页的修改，而这些数据可能是不相邻的，属于随机操作IO
于是，决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。
采用redo log的优点
redo log进行刷盘的效率要远高于数据页刷盘，具体表现如下
redo log体积小，只记录了哪一页修改的内容，因此体积小，刷盘快
redo log是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快

4.MySQL如何保证隔离性
利用锁和MVCC机制
...
```

5.数据库的三大范式, 为什么一定要有主键

```
我们可以通俗的将三大范式理解为在设计数据库时需要遵循的规则，它可以有效的帮助我们建立冗余小且结构合理的数据库。
第一范式:
数据库中所有的属性字段都是不可分解的，即我们创建的属性在此字段中一定是你设计表的最小的字段值，遵循数据的原子性

第二范式:
表中的属性字段必须依赖于表的主键

第三范式：
不能出现传递依赖

为什么一定要有主键?
没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行。
虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表有一个主键，以便于以后数据操纵和管理
表中的任何列都可以作为主键，只要它满足以下条件：
 1、任何两行都不具有相同的主键值
 2、每个行都必须具有一个主键值（主键列不允许NULL值）
```

6.MySQL的引擎你有什么了解?

```
目前MySQL使用的是InnoDB引擎, 它是一个事务安全的存储引擎, 具备提交, 回滚以及崩溃恢复的功能以保护用户数据. InnoDB的行级锁保证数据一致性的前提下提高了并发性能. InnoDB将用户数据存储在聚簇索引中以减少基于主键的普通查询所带来的I/O开销, 为了保证数据的完整性, InnoDB还支持外键约束, 默认使用B+ Tree数据结构存储索引.
在MySQL5.0版本之前, 使用的是MyISAM引擎, 它不支持事务, 也不支持外键, 其优势是访问速度快, 但是表级别的锁定限制了他在读写负载方面的性能, 因此它经常应用于只是读或者以读为主的数据场景, 默认使用B+树结构存储索引.
```

7.说一下InnoDB存储引擎和MyISAN存储引擎的区别

```
InnoDB:
支持事务, 支持4个事务隔离级别
行级锁定(更新时锁定当前行)
读写阻塞与事务隔离级别有关
既能缓存索引又能缓存数据
支持外键

MyISAM:
不支持事务
表级锁定(更新时锁定整个表)
读写互相阻塞(写入时阻塞读入, 读时阻塞写入, 但是读不会互相阻塞)
只能缓存索引, 不会缓存数据
不支持外键
读取速度快
```

8.对聚簇索引了解吗?

```
InnoDB 存储引擎根据索引类型不同，分为聚簇索引和二级索引。它们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，找到了索引也就找到了数据. 而二级索引的叶子节点存放的是主键值，而不是实际数据。所以如果我们使用二级索引列作为查询条件, 如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树.
在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，且一张表只允许存在一个聚簇索引。其它索引都属于二级索引。
如果没有定义主键, 那么存储引擎会自动选择第一列唯一且不为空的列作为聚簇索引, 如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引
```

9.了解慢SQL吗？ 一条SQL语句是如何执行的?

```
运行时间较长的SQL即为慢SQL, MySQL慢查询，是运行时间超过long_query_time值的SQL。
SQL运行快慢是一个相对的概念，不同的业务场景下要求不同，慢SQL的标准也就不同。
MySQL中long_query_time参数定义了SQL运行阈值，默认为10s，可通过设置该阈值来调整基准。

一条SQL语句的执行过程:
如上图所示，一条SQL语句执行时，分为以下几步：
1. 若查询缓存打开则会优先查询缓存，若命中则直接直接返回结果给客户端。
2. 若缓存未命中，此时MySQL需要搞清楚这条语句需要做什么，则通过分析器进行词法分析、语法分析。
3. 搞清楚要做什么之后，MySQL需要通过优化器进行优化执行计划。
4. 最后通过执行器与存储引擎提供的接口进行交互，将结果返回给客户端。
```

10.说一说EXPLAIN

```
MySQL 提供了一个 EXPLAIN 命令，它可以对 SQL 语句进行分析，并输出 SQL 执行的详细信息，以供开发人员针对性优化.
主要关注的字段:
type: 
这是最重要的字段之一，显示此次查询是何种类型. 比如ALL表示使用的全表扫描, 这是性能最差的, index 表示对索引进行了把索引从头到尾扫一遍, range表示索引范围查询
possible_keys:
可能会使用到的索引会在这里列出来
key:
查询真正使用到的索引
rows:
这是MySQL估算的需要扫描的行数, 这个值直观的显示了SQL的效率好坏, 原则上rows越少越好
extra:
EXPLAIN中的很多额外信息会在extra字段显示出来, 比如Using index表示"覆盖索引扫描", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错 Using temporary查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.
```

11.ACID是什么?C的具体含义, 如何保证?

```
ACID
A(Atomicity): 
事物的原子性, 指一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，如果事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；

C(Consistency): 
指事务的执行并不改变数据库中数据的一致性. 例如, 完整性约束了 a+b=10, 在一个事务中改变了a, 那么b也应该随之改变

I(Isolation): 
事物的独立性也称作隔离性, 是指两个以上的事务不会出现交错执行的状态, 因为这样可能会导致数据不一致.

D(Durability): 
事务的持久性是指事务执行成功以后, 该事务对数据所做的更改是持久的保存在数据库之中, 不会无缘无故的回滚.

数据库通过原子性（A）、隔离性（I）、持久性（D）来保证一致性（C）。其中一致性是目的，原子性、隔离性、持久性是手段。因此数据库必须实现AID三大特性才有可能实现一致性。
```

12.MVCC了解吗?原理是什么

```
MVCC即多版本并发控制, 数据库隔离级别读已提交、可重复读 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。

通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，这些旧版本都存放在undo log中. InnoDB存储引擎中每一条记录都有两个隐藏列, 一个是trx_id, 记录了最近一次修改本条记录的事务ID, 一个是roll_ptr, 指向undo_log中的旧版本记录, 这些旧版本记录通过链表连接起来, 可以通过roll_ptr可以找到修改前的记录。

Read View 在 MVCC中如何工作的?
在可重复读和读已提交隔离级别下, MVCCRead View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，称为实时读. 而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View, 称为快照读.

Read View中包含了四个字段, 比如当前本事务ID, read view创建时的其余活跃事务id列表(活跃事务”指的就是，启动了但还没提交的事务。), 活跃事务id中最小的id, 以及创建Read View时应当给下一个事务的id.

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：
如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。
如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。
如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：
如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。
如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。

根据不同的隔离级别, 生成Read View的时机不同, 因此造成的效果也不同
```

13.如果给你一个3阶B+树, 每行数据的大小为1KB, 那么B+树能存储多少个数据?

```
大概2000多万条数据
因为InnoDB存储引擎的最小存储单位是页, 为16kb, 页可以用于存放数据也可以用于存放键值+指针，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；

假设这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。

上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。

那么现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。

根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170*1170*16=21902400(2000多万)条这样的记录。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时 一次页的查找代表一次IO， 所以通过主键索引查询通常 只需要1-3次IO操作 即可查找到数据。
```

14.索引, 联合索引, 最左原则

```
索引是帮助MySQL高效获取数据的数据结构.索引是对数据库表中一列或多列的值进行排序的一种结构。MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度
简单类比一下, 简单类比一下，数据库如同书籍，索引如同书籍目录，假如我们需要从书籍查找与 xx 相关的内容，我们可以直接从目录中查找，定位到 xx 内容所在页面，如果目录中没有 xx 相关字符或者没有设置目录（索引），那只能逐字逐页阅读文本查找，效率可想而知。

多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引. 只会构建出一棵索引树, 每个节点的键值不是单个的, 而是组合值.
字典排序

最左匹配原则, 在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。
也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引  
```

15.事务的隔离级别, 具体展开讲讲

```
读未提交 读已提交 可重复读 串行化
安全性越来越高, 并发程度越来越低
读未提交隔离级别什么问题都没有解决, 它会发生读脏数据, 不可重复读, 幻读问题.
读已提交解决了脏读问题, 未解决不可重复读和幻读问题
可重复读隔离级别解决了脏读和不可重复读问题, 它是MySQL默认的隔离级别, 对于幻读问题, 使用next_key_lock解决
串行化三个问题都解决了, 但是使得数据库的并发性能大大降低, 一般不使用.
```

16.200w数据放数据库中层数多高

```
3层
因为InnoDB存储引擎中最小的存储单位为页, 一页默认16KB, 如果我们的一行数据大小为1KB, 那么一页就可以存放16条数据.
因为InnoDB存储引擎使用的是B+树来存储数据, 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引, 假如我们的主键为BigInt, 占8位, 对应的指针默认占6位, 那么一页可以存放 16KB / 14 = 1170, 所以会有1170子节点, 1170 * 16 =  两层不够
三层
```

17.数据库加锁的系统调用是什么?

```

```

18.行锁在什么情况下出现

```
只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁
在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。
————————————————

行级锁的类型主要有三类：
Record Lock，记录锁，也就是仅仅把一条记录锁上；		
Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；	 (左开右开)
Next-Key Lock：临键锁, Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。 (左开右闭)
```

19.联合索引是怎么存放在磁盘上的

```
我们创建了一个联合索引（b，c，d）也会生成一个索引树，同样是B+树的结构，只不过它的data部分存储的是联合索引所在行的主键值. 对于联合索引，存储引擎会首先根据第一个索引列排序，如上图我们可以单看第一个索引列，如，1 1 5 12 13....他是单调递增的；如果第一列相等则再根据第二列排序，依次类推就构成了上图的索引树，上图中的1 1 4 ，1 1 5以及13 12 4,13 16 1,13 16 5就可以说明这种情况。
字典排序
```

20.B树和B+树的区别

```
MySQL 默认的存储引擎 InnoDB 采用的是 B+ 树作为索引的数据结构，原因有：

B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比既存储索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的时候磁盘 I/O次数会更少。(相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少。)
B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。
```

21.**为什么要主从复制**

```
负载均衡和读写分离
对于主服务器（Master）来说，主要负责写，从服务器（Slave）主要负责读，这样的话，就会大大减轻压力，从而提高效率。

原理
MySQL 主从复制是基于主服务器在二进制日志跟踪所有对数据库的更改。因此，要进行复制，必须在主服务器上启用二进制日志。
每个从服务器从主服务器接收已经记录到日志的数据。当一个从服务器连接到主服务器时，它通知主服务器从服务器日志中读取最后一个更新成功的位置。
从服务器接收从那时发生起的任何更新，并在主机上执行相同的更新。然后封锁等待主服务器通知的更新。
从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新。
```

22.**主从复制的工作流程**

```
MySQL 的主从复制工作过程大致如下：
1. 从库生成两个线程，一个 I/O 线程，一个 SQL 线程；
2. I/O 线程去请求主库的 binlog，并将得到的 binlog 日志写到 relay log(中继日志) 文件中；
3. 主库会生成一个 log dump 线程，用来给从库 I/O 线程传 binlog；
4. 从库的SQL 线程会读取 relay log 文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致；
```

23.**主从复制的类型**

```
1. 同步复制
在 MySQL cluster 中特有的复制方式。
当主库执行完一个事务，然后所有的从库都复制了该事务并成功执行完才返回成功信息给客户端。
因为需要等待所有从库执行完该事务才能返回成功信息，所以全同步复制的性能必然会收到严重的影响。

2. 半同步复制
在异步复制的基础上，确保任何一个主库上的事物在提交之前至少有一个从库已经收到该事物并日志记录下来。
介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到 relay log 中才返回成功信息给客户端(只能保证主库的 Binlog 至少传输到了一个从节点上)，否则需要等待直到超时时间然后切换成异步模式再提交。
相对于异步复制，半同步复制提高了数据的安全性，一定程度的保证了数据能成功备份到从库，同时它也造成了一定程度的延迟，但是比全同步模式延迟要低，这个延迟最少是一个 TCP/IP 往返的时间。所以，半同步复制最好在低延时的网络中使用。

3. 异步复制
这种模式下，主节点不会主动推送数据到从节点，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理。
这样就会有一个问题，主节点如果崩溃掉了，此时主节点上已经提交的事务可能并没有传到从节点上，如果此时，强行将从提升为主，可能导致新主节点上的数据不完整。

4. 延迟复制
在异步复制的基础上，人为设定主库和从库的数据同步延迟时间，即保证数据延迟至少是这个参数。
```

24.**主从复制的支持两种不同的日志格式**

```
1. 语句复制
逻辑复制, 二进制日志记录的是操作, 在从数据库中进行重放
这种方式简单，二进制文件小，传输带宽占用小。但是基于语句更新依赖于其它因素, 比如基于时间的函数NOW()等等, 会发生错误
设表里有一百万条数据，一条sql更新了所有表，基于语句的复制仅需要发送一条sql，而基于行的复制需要发送一百万条更新记录

2. 行数据复制
基于行的复制相当于物理复制，即二进制日志中记录的是实际更新数据的每一行
这样导致复制的压力比较大，日志占用的空间大，传输带宽占用大。但是这种方式比基于语句的复制要更加精确。

3. 混合类型的复制
一般情况下，默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。
```

25.说一说什么是事务

```
事务就是一组原子性的SQL操作,或者说一个独立的工作单元.如果数据库引擎能够成功地对数据库应用该组查询的全部语句,那么就执行该组查询.如果有任何一条语句因为崩溃或者其他原因无法执行,那么所有的语句都不会执行.
也就是说事务内的语句,要么全部执行成功,要么全部执行失败
```

26.MySQL用的什么引擎

```
目前MySQL使用的是InnoDB引擎, 它是一个事务安全的存储引擎, 具备提交, 回滚以及崩溃恢复的功能以保护用户数据. InnoDB的行级锁保证数据一致性的前提下提高了并发性能. InnoDB将用户数据存储在聚簇索引中以减少基于主键的普通查询所带来的I/O开销, 为了保证数据的完整性, InnoDB还支持外键约束, 默认使用B+ Tree数据结构存储索引.
在MySQL5.0版本之前, 使用的是MyISAM引擎, 它不支持事务, 也不支持外键, 其优势是访问速度快, 但是表级别的锁定限制了他在读写负载方面的性能, 因此它经常应用于只是读或者以读为主的数据场景, 默认使用B+树结构存储索引.
```

27.InnoDB存储引擎的索引结构

```
InnoDB存储引擎使用的索引结构是B+树, 它是一个多路平衡搜索树,  
```

28.B+树和B树有什么区别(为什么使用B+树不使用B树)

```
MySQL 默认的存储引擎 InnoDB 采用的是 B+ 树作为索引的数据结构，原因有：

1. B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比既存储索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的时候磁盘 I/O次数会更少。(相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少。)
2. B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
3. B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。
```

29.说一说聚簇索引和二级索引

```
InnoDB 存储引擎根据索引类型不同，分为聚簇索引和二级索引。它们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户数据都存放在聚簇索引的叶子节点，找到了索引也就找到了数据. 而二级索引的叶子节点存放的是主键值，而不是实际数据。所以如果我们使用二级索引列作为查询条件, 如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树. 进行回表操作
在创建表时，InnoDB 存储引擎默认会创建一个主键索引，也就是聚簇索引，且一张表只允许存在一个聚簇索引。其它索引都属于二级索引。
如果没有定义主键, 那么存储引擎会自动选择第一列唯一且不为空的列作为聚簇索引, 如果没有这样的列存在, 那么会自动生成一个自增的主键id作为索引
```

30.回表是什么意思, 覆盖索引什么意思?

```
在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：

先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；
然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。
上述过程叫做回表

在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据就在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据就可以了, 不需要再回表, 这个过程叫做覆盖索引。
```

31.索引失效的几种原因

```
1.对索引使用左或者左右模糊匹配. 
也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。 like x% 这种不会
原因: 因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。

2.对索引使用函数
原因: 因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。
不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。

3.对索引进行表达式计算
原因跟对索引使用函数差不多。 ... WHERE id = 10 - 1; 可以  ... WHERE id - 1 = 10; 不行

4.对索引隐式类型转换
如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。

5.联合索引非最左匹配
原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。(类似于字典排序)
也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。

6.WHERE 子句中的 OR
因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。
```

32.什么是联合索引, 了解最左原则吗?

```
多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引. 只会构建出一棵索引树, 每个节点的键值不是单个的, 而是组合值

最左匹配原则, 在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。
也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引  
例如以下:
1 5 a
1 5 d
1 6 c
2 2 b
2 3 a
5 2 a
5 9 b
9 3 t
```

33.为什么使用联合索引

```
1.减少开销
建立一个联合索引, 实际上相当于建立了多个单列索引. 而每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！
比如我们对a, b, c三个字段建立一个联合索引(a, b, c), 其实就相当于建立了三个单列索引, 在我们做这样的查询时, 比如:
select * from user where a = 10 and b = 11, 我们只需要查询一颗联合索引树就可以得到结果, 不需要查询两个单列索引树, 然后再将各自所得的结果过滤合并, 这样可以大大减少磁盘I/O次数, 减少开销, 提高性能

2.覆盖索引
使用联合索引的话, 有可能出现覆盖索引的情况, 即我们要查询的数据全部在这一棵联合索引树中, 那么我们只要查询一次就可以从叶子节点中得到数据, 而不用再回表去聚簇索引树中查找

3.索引列越多，通过索引筛选出的数据越少, 更加高效

```

34.InnoDB引擎通过什么技术来保证事务的这四个特性?

```
持久性是通过 redo log （重做日志） 来保证的；
原子性是通过 undo log （回滚日志） 来保证的；
隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
一致性则是通过持久性+原子性+隔离性来保证；
```

35.读已提交和可重复读是怎么实现的?

```
MVCC即多版本并发控制, 数据库隔离级别读已提交、可重复读 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。

通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，这些旧版本数据都存放在undo log中. InnoDB存储引擎中每一条记录都有两个隐藏列, 一个是trx_id, 记录了最近一次修改本条记录的事务ID, 一个是roll_ptr, 指向undo_log中的旧版本记录, 这些旧版本记录通过链表连接起来, 可以通过roll_ptr可以找到修改前的记录。

Read View 在 MVCC中如何工作的?
在可重复读和读已提交隔离级别下,它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读已提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，称为实时读. 而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View, 称为快照读.

Read View中包含了四个字段, 比如当前事务ID, read view创建时的其余活跃事务id列表(活跃事务”指的就是，启动了但还没提交的事务。), 活跃事务id列表中最小的id, 以及创建Read View时应当给下一个事务的id.

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：
如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。
如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。
如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：
如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。
如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。

对于读已提交和可重复读隔离级别, 差别就在于生成Read View的时机不同, 
正是因为在读已提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
而在可重复读隔离级别下, 只在事务开始之初生成了Read View, 后面整个事务执行期间都是用的同一个Read View, 自然所有的数据都会是一致的, 当然如果在事务中要执行UPDATE, DELETE, INSERT这些操作时, 就必须要获取新的Read View, 那么就会产生我们所说的幻读问题. 普通的Select查询都是快照读, 其余的操作是实时读.
对于幻读问题, 我们使用next_key_lock(临键锁)来解决, 它是记录锁和间隙锁的组合, 锁住我们要修改的记录之间的间隙以及记录本身, 使得别的事务想要在此期间插入删除数据的话会被阻塞, 从而解决了幻读问题
```

36.幻读是怎么被解决的

```
读者做的实验之所以看不到幻读现象，是因为在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。
可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个视图，然后后续的查询语句都用这个视图，「快照读」读的就是这个视图的数据，视图你可以理解为版本数据，这样就使得每次查询的数据都是一样的。
MySQL 里除了普通查询是快照度，其他都是当前读，比如update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。
这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且 提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。
另外，select ... for update 这种查询语句是当前读，每次执行的时候都是读取最新的数据。

因此，要讨论「可重复读」隔离级别的幻读现象，是要建立在「当前读」的情况下。


Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了 next-key 锁，就是记录锁和间隙锁的组合。
记录锁，锁的是记录本身；
间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。(左开右开)
对于幻读问题, 我们使用next_key_lock(临键锁)来解决, 它是记录锁和间隙锁的组合, 锁住我们要修改的记录之间的间隙以及记录本身, (左开右闭) 使得别的事务想要在此期间插入数据的话会被阻塞, 从而解决了幻读问题
```

37.说一说redo, undo日志 binlog日志

```
redo log 是重做日志，提供 前滚 操作；undo log 是回退日志，提供 回滚 操作。

Undo log (逻辑日志)主要用于记录数据被修改之前的日志，在表信息修改之前会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。各个数据记录之间通过链表相连, InnoDB引擎下每个记录后都有两个隐藏列. roll_ptr可以找到旧版本的记录

redo log(w)主要用于在进行日志回放的时候把已经COMMIT的事务重做一遍，对于没有commit的事务交由undo log进行数据回滚操作。

redo log 通常是 物理 日志，记录的是 数据页 的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。
2.undo log 用来回滚行记录到某个版本。undo log 一般是逻辑日志，根据每行记录进行记录。


区别在于redo log关注的是已经commit的事务保证了持久性(已经commit的事务存放在内存中, 这时候掉电导致数据还没有更新回磁盘)，undo log是没有commit的事务需要进行回滚的, 保证了原子性。

那么对数据进行一系列的修改之前都会把其历史数据保存到undo log，undo log 是一个链表结构, 然后把更新的数据记录到redo log日志里。 当我们的事务进行commit后可以通过redo log日志来保证只要commit后的事务数据都会全部同步修改到数据库。当事务进行rollback时，我们可以通过undo log记录的历史版本来对整个事务关联的修改的数据进行回滚。

比如某一时刻数据库 DOWN 机了，有两个事务，一个事务已经提交，另一个事务正在处理。数据库重启的时候就要根据日志进行前滚及回滚，把已提交事务的更改写到数据文件，未提交事务的更改恢复到事务开始前的状态。即，当数据 crash-recovery 时，通过 redo log 将所有已经在存储引擎内部提交的事务应用 redo log 恢复，所有已经 prepared 但是没有 commit 的 transactions 将会应用 undo log 做 roll back。

为什么只用 redo-log 或者只用 undo-log 不可以
假设只有 undo-log：那么就必须保证提交前刷脏完成，否则宕机时有些修改就在内存中丢失了，破坏了持久性。（这样带来了一个问题，那就是前面提到的性能差）
假设只有 redo-log：那么就不能随心所欲地在事务提交前刷脏，即无法支持大事务。（假如、某张表有 100 亿的 8 字节整数数据，就算不考虑其他东西带来的损耗，光 update 整张表至少要消耗 80G 的内存。如前所述，有了 undo-log，就可以随便刷脏。）


主要作用是用于数据库的主从复制及数据的增量恢复。
1.啥是binlog? 记录数据库增删改,不记录查询的二进制日志.
2.作用:用于数据恢复.

层次不同。redo/undo log是innodb层维护的，而binlog是mysql server层维护的，跟采用何种引擎没有关系，记录的是所有引擎的更新操作的日志记录
记录时机不同。redo/undo日志在事务执行过程中会不断的写入
显然，我们执行SELECT等不涉及数据更新的语句是不会记binlog的，而涉及到数据更新则会记录。要注意的是，对支持事务的引擎如innodb而言，必须要提交了事务才会记录binlog。
binlog刷新到磁盘的时机跟sync_binlog参数相关，
```

38.binlog三种模式

```
1. 语句复制
逻辑复制, 二进制日志记录的是操作, 在从数据库中进行重放
这种方式简单，二进制文件小，传输带宽占用小。但是基于语句更新依赖于其它因素, 某些语句中含有一些函数，例如 UUID NOW 等在复制过程可能导致数据不一致甚至出错。

2. 行数据复制
基于行的复制相当于物理复制，即二进制日志中记录的是实际更新数据的每一行
这样导致复制的压力比较大，日志占用的空间大，传输带宽占用大。但是这种方式比基于语句的复制要更加精确。

设表里有一百万条数据，一条sql更新了所有表，基于语句的复制仅需要发送一条sql，而基于行的复制需要发送一百万条更新记录

3. 混合类型的复制
一般情况下，默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。
```

39.数据库是如何保证事务的隔离性的

```
加锁和MVCC
数据库是通过加锁，来实现事务的隔离性的。这就好像，如果你想一个人静静，不被别人打扰，你就可以在房门上加上一把锁。
加锁确实好使，可以保证隔离性。比如串行化隔离级别就是加锁实现的。但是频繁的加锁，导致读数据时，没办法修改，修改数据时，没办法读取，大大降低了数据库性能。
那么，如何解决加锁后的性能问题的？
答案就是,MVCC多版本并发控制！它实现读取数据不用加锁，可以让读取数据同时修改。修改数据时同时可读取。
...
```

40.MVCC是什么?

```
MVCC即多版本并发控制, 数据库隔离级别读已提交、可重复读 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。

通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，这些旧版本都存放在undo log中. InnoDB存储引擎中每一条记录都有两个隐藏列, 一个是trx_id, 记录了最近一次修改本条记录的事务ID, 一个是roll_ptr, 指向undo_log中的旧版本记录, 这些旧版本记录通过链表连接起来, 可以通过roll_ptr可以找到修改前的记录。

Read View 在 MVCC中如何工作的?
在可重复读和读已提交隔离级别下,它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，称为实时读. 而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View, 称为快照读.

Read View中包含了四个字段, 比如当前本事务ID, read view创建时的其余活跃事务id列表(活跃事务”指的就是，启动了但还没提交的事务。), 活跃事务id中最小的id, 以及创建Read View时应当给下一个事务的id.

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：
如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。
如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。
如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：
如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。
如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。
```

