### 计算机网络

---

1.说一下GET 和 POST, 二者之间的差别  	**寄中寄**

```
GET - 从指定的资源请求数据
POST - 向指定的资源提交要被处理的数据。

白话:
根据 RFC 规范,GET 的语义是从服务器获取指定的资源,这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中,URL 规定只能支持 ASCII,所以 GET 请求的参数只允许 ASCII 字符 ,而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。
根据 RFC 规范,POST 的语义是根据请求负荷（报文body）对指定的资源做出处理,具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中, body 中的数据可以是任意格式的数据,只要客户端与服务端协商好即可,而且浏览器不会对 body 大小做限制。
另一个呢, GET 方法就是安全且幂等的,因为它是「只读」操作,无论操作多少次,服务器上的数据都是安全的,且每次的结果都是相同的。所以,可以对 GET 请求的数据做缓存,POST 因为是「新增或提交数据」的操作,会修改服务器上的资源,所以是不安全的,且多次提交数据就会创建多个资源,所以不是幂等的。所以,浏览器一般不会缓存 POST 请求,也不能把 POST 请求保存为书签。
```

2.三次握手可以改成两次吗?

```
不行, 主要有以下两个原因.
我认为TCP三次握手主要有两个原因,首要原因是为了防止历史连接初始化造成混乱和资源浪费, 其次是为了同步双方的起始序列号.
对于第一个原因, 
我们考虑这样的情况,假设客户端先发了一个序列号为90的SYN请求报文, 但是它在网络中某个节点被阻塞了, 然后客户端又发送了另一个新的SYN请求报文, 序列号为100, 但是旧的请求报文比新的先到达服务端, 然后服务端回返回一个SYN ACK报文, 其中ack确认号为91, 这显然是错的, 客户端收到该ACK报文之后, 发现确认号为91而不是101, 判定这是一个历史连接, 客户端就发送一个RST报文回去告知服务端, 终止这次连接.
如果没有三次握手, 那么服务端在接收到请求报文之后立刻建立连接, 没有等待客户端的确认, 那么显然会出现混乱和资源浪费.
第二个原因就是, 
TCP 协议的通信双方， 都必须维护一个「序列号」， 以标识发送出去的数据包中, 哪些是已经被对方收到的。序列号是可靠传输的一个关键因素. 序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。
简单来说, 两次不可靠, 四次不高效
```

3.说一说键入网址到网页显示, 期间发生了什么

```
1.URL解析
首先浏览器做的第一步工作就是要对 URL 进行解析,判断你输入的是不是一个合法的 URL ,并且根据你输入的内容进行自动补全、字符编码等操作。浏览器还会进行一些额外的操作,比如安全检查、访问限制, 比如有时候需要强制使用HTTPS协议而不能使用HTTP协议.
接着从处理过的URL中提取出域名, 然后开始进行第二步 --- DNS查询

2.DNS查询
DNS查询就是寻找哪台机器上有我们所需要资源的过程. 就是将域名 映射到 具体的IP地址的过程
...
所以DNS根据域名查询IP地址的过程为：浏览器缓存 --> 操作系统缓存(本地Hosts文件) --> 路由器缓存-->本地（ISP）域名服务器缓存 --> 根域名服务器 --> 权限域名服务器等等。

3.TCP连接
浏览器终于得到了目的IP地址以后,可以开始向服务器发送TCP连接,经过三次握手之后建立了TCP连接之后, 我们可以开始正式的通信

4.浏览器发送HTTP请求
浏览器和服务器建立连接以后,浏览器接着按这个IP地址给服务器发送一个HTTP请求,方式为get,例如访问www.baidu.com。其本质是在建立起的TCP连接中,按照HTTP协议标准发送一个索要网页的请求。

4.服务器处理请求
服务器端收到了客户端的HTTP请求报文之后, 会对它进行相应的解析, 然后生成一个响应头和具体响应内容, 将客户端所需要的资源封装成一个HTTP响应报文发送回去

5.浏览器接受响应
浏览器接收到来自服务器的HTTP响应报文之后,会对其进行分析处理,z再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。

6.关闭TCP连接
当数据完成请求到返回的过程之后,根据Connection字段的Keep-Alive属性可以选择是否断开TCP连接,HTTP/1.1 版本的默认连接都是持久连接
```

4.HTTP和HTTPS有什么区别

```
HTTP 是超文本传输协议,信息是明文传输,存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷,在 TCP传输层 和 HTTP 应用层之间加入了 SSL/TLS 安全协议,使得报文能够加密传输。
HTTP 连接建立相对简单, TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后,还需进行 SSL/TLS 的握手过程,才可进入加密报文传输。
HTTP 的端口号是 80,HTTPS 的端口号是 443。
HTTPS 协议需要向 CA（证书权威机构）申请数字证书, 来保证服务器的身份是可信的。
```

5.HTTP五大类状态码

```
1xx: 提示信息, 表示目前是协议处理的中间状态, 还需要后续的操作
2xx: 成功, 报文已经收到并被正确处理				 
3xx: 重定向, 资源位置发生变动, 需要客户端重新发送请求
4xx: 客户端错误, 请求报文有误, 服务器无法处理
5xx: 服务器错误, 服务器在处理请求时内部发生了错误
```

6.HTTP常用字段

```
Host字段 客户端发送请求时，用来指定服务器的域名
Connection字段 最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。
User-Agent:客户端程序的信息，就是我发送请求的浏览器信息。
Accept：列出了浏览器可以接收的媒体数据类型：
Accept-Language:告知服务器浏览器能够处理的自然语言集（中文、英文等）。zh-CN中文简体。
Accept-Encoding:告知服务器 浏览器能够处理的压缩方式
Cookie：浏览器记录的用户相关信息。
Content-Length字段 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。
Content-Type字段 用于服务器回应时，告诉客户端，本次数据是什么格式。
Content-Encoding字段 说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式
```

7.你知道的 HTTP/1.1的优点有哪些,怎么体现的？

```
HTTP/1.1最突出的优点是: 简单, 灵活和易于拓展,应用广泛和跨平台
1.简单
HTTP 基本的报文格式就是 header + body,头部信息也是 key-value 简单文本的形式,易于理解,降低了学习和使用的门槛。

2.灵活和易于扩展
HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死,都允许开发人员自定义和扩充。同时 HTTP 由于是工作在应用层（ OSI 第七层）,则它下层可以随意变化。
例如 HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层,而HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。

3.应用广泛和跨平台
互联网发展至今,HTTP 的应用范围非常的广泛,从台式机的浏览器到手机上的各种 APP,从看新闻、刷贴吧到购物、理财、吃鸡,HTTP 的应用遍地开花,同时天然具有跨平台的优越性。
```

8.HTTP/1.1的缺点, 你知道什么不

```
双刃剑: 无状态, 明文传输
无状态:
无状态的好处,因为服务器不会去记忆 HTTP 的状态,所以不需要额外的资源来记录状态信息,这能减轻服务器的负担,能够把更多的 CPU 和内存用来对外提供服务。
无状态的坏处,既然服务器没有记忆能力,它在完成有关联性的操作时会非常麻烦。
cookie技术 贴纸例子

明文传输:
明文意味着在传输过程中的信息,是可方便阅读的,通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看,为我们调试工作带了极大的便利性。
但是这正是这样,HTTP 的所有信息都暴露在了光天化日下,相当于信息裸奔。在传输的漫长的过程中,信息的内容都毫无隐私可言,很容易就能被窃取,如果里面有你的账号密码信息,那...


缺点: 不安全
```

9.说说HTTP/1.1相比于HTTP/1.0提高了什么性能

```
HTTP/1.1 相比 HTTP/1.0 性能上的改进：

使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
支持管道（pipeline）网络传输,只要第一个请求发出去了,不必等其回来,就可以发第二个请求出去,可以减少整体的响应时间。
```

10.TCP和UDP的区别

```
1. 连接
TCP 是面向连接的传输层协议,传输数据前先要建立连接。
UDP 是不需要连接,即刻传输数据。

2. 服务对象
TCP 是一对一的两点服务,即一条连接只有两个端点。
UDP 支持一对一、一对多、多对多的交互通信

3. 可靠性
TCP 是可靠交付数据的,数据可以无差错、不丢失、不重复、按需到达。
UDP 是尽最大努力交付,不保证可靠交付数据。

4. 拥塞控制、流量控制
TCP 有拥塞控制和流量控制机制,保证数据传输的安全性。
UDP 则没有,即使网络非常拥堵了,也不会影响 UDP 的发送速率。

5. 首部开销
TCP 首部长度较长,会有一定的开销,首部在没有使用「选项」字段时是 20 个字节,如果使用了「选项」字段则会变长的。
UDP 首部只有 8 个字节,并且是固定不变的,开销较小。

6. 传输方式
TCP 是流式传输,没有边界,但保证顺序和可靠。
UDP 是一个包一个包的发送,是有边界的,但可能会丢包和乱序。

7. 分片不同
TCP 的数据大小如果大于 MSS 大小,则会在传输层进行分片,目标主机收到后,也同样在传输层组装 TCP 数据包,如果中途丢失了一个分片,只需要传输丢失的这个分片。
UDP 的数据大小如果大于 MTU 大小,则会在 IP 层进行分片,目标主机收到后,在 IP 层组装完数据,接着再传给传输层。
```

11.TCP和UDP应用场景

```
由于 TCP 是面向连接,能保证数据的可靠性交付,因此经常用于：
FTP 文件传输；
HTTP / HTTPS；

由于 UDP 面向无连接,它可以随时发送数据,再加上UDP本身的处理既简单又高效,因此经常用于：
包总量较少的通信,如 DNS 、SNMP 等；
视频、音频等多媒体通信；
广播通信；
```

12.四次挥手的过程

```
客户端打算关闭连接,此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文,也即 FIN 报文,之后客户端进入 FIN_WAIT_1 状态。
服务端收到该报文后,就向客户端发送 ACK 应答报文,接着服务端进入 CLOSED_WAIT 状态。
客户端收到服务端的 ACK 应答报文后,之后进入 FIN_WAIT_2 状态。
等待服务端处理完数据后,也向客户端发送 FIN 报文,之后服务端进入 LAST_ACK 状态。
客户端收到服务端的 FIN 报文后,回一个 ACK 应答报文,之后进入 TIME_WAIT 状态
服务器收到了 ACK 应答报文后,就进入了 CLOSED 状态,至此服务端已经完成连接的关闭。
客户端在经过 2MSL 一段时间后,自动进入 CLOSED 状态,至此客户端也完成连接的关闭。
你可以看到,每个方向都需要一个 FIN 和一个 ACK,因此通常被称为四次挥手。
需要注意的一点是, 主动关闭连接的一方才会有Time-Wait阶段
```

13.为什么挥手需要四次

```
再来回顾下四次挥手双方发 FIN 包的过程,就能理解为什么需要四次了。

关闭连接时,客户端向服务端发送 FIN 时,仅仅表示客户端不再发送数据了但是还能接收数据。
服务器收到客户端的 FIN 报文时,先回一个 ACK 应答报文,而服务端可能还有数据需要处理和发送,等服务端不再发送数据时,才发送 FIN 报文给客户端来表示同意现在关闭连接。
从上面过程可知,服务端通常需要等待完成数据的发送和处理,所以服务端的 ACK 和 FIN 一般都会分开发送,从而比三次握手导致多了一次。
```

14.为什么 TIME_WAIT 等待的时间是 2MSL？

```
MSL 是 Maximum Segment Lifetime,报文最大生存时间,它是任何报文在网络上存在的最长时间,超过这个时间报文将被丢弃。
TIME_WAIT 等待 2 倍的 MSL,我认为主要有两个原因:
1. 
为了保证客户端发送的最后一个ACK报文段能够到达服务端, 因为这个ACK报文段有可能丢失, 因为使处于LAST_ACK状态的服务端收不到对已发送的FIN报文段的确认, 服务端就会重传这个FIN报文段, 而客户端就能在2MSL时间内收到这个重传的FIN报文段.接着客户端重传一次确认, 重新启动2MSL计时器, 最后两者才能都正常进入Closed状态. 如果客户端在TIME-Wait状态下不等待一段时间, 而是在发送完ACK报文段后立即释放连接, 那么就无法收到服务端重传的FIN报文段, 因而也不会再发送一次确认报文段, 这样, 服务端就无法按照正常步骤进入Closed状态.
2.
客户端在发送完最后一个ACK报文之后, 在经过时间2MSL, 就可以使本连接持续的时间内所产生的所有报文段都从网络中消失, 这样就可以使下一个连接中不会出现这种已经失效的连接请求报文段.
```

15.既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

```
MTU：一个网络包的最大长度，以太网中一般为 1500 字节；(IP头部 + TCP头部 + TCP数据)
MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？

当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。
这看起来井然有序，但这存在隐患的，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。
因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。
当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。
因此，可以得知由 IP 层进行分片传输，是非常没有效率的。
所以，为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。
经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。
```

16.HTTPS解决了HTTP的哪些问题

```
HTTP 由于是明文传输，所以安全上存在以下三个风险：
窃听风险，比如通信链路上可以获取通信内容，用户号容易没。
篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
冒充风险，比如冒充淘宝网站，用户钱容易没。

HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：
信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。

混合加密的方式实现信息的机密性，解决了窃听的风险。
摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
将服务器公钥放入到数字证书中，解决了冒充的风险。
```

17.HTTP/1.1对HTTP/1.0的改进

```
(1) 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 	TCP 连接建立和断开，增加了通信开销。为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

(2) HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。
即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
```

18.HTTP/2对HTTP/1的改进

```
HTTP/1.1 还是有性能瓶颈：
请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
没有请求优先级控制；
请求只能从客户端开始，服务器只能被动响应。
    
改进措施:
1.头部压缩
HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。
这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

2.二进制格式
HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。

3.利用stre

4.服务器主动推送资源
HTTP/1.1 不支持服务器主动推送资源给客户端，都是由客户端向服务器发起请求后，才能获取到服务器响应的资源。
比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，而HTTP/2就会一次性将可能用到的资源文件主动推送过去, 减少了消息传递的次数。
```

19.说一说四次挥手全过程

```
客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。
服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。
客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。
等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。
客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态
服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。
客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。
你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。
```

20.为什么要等待2MSL

```
原因一: 确保本次TCP连接中产生的所有报文都消失在网络中, 从而防止历史连接中的数据，被后面相同四元组的新连接错误的接收.
假设不等待2MSL时间, 那么当此次TCP连接结束后, 网络中可能还存在这次连接中产生的数据包, 如果我们紧接着又重新开始一次新的TCP	连接, 那么很有可能上次历史连接中的数据包正好处于接收窗口中, 从而被接收, 这样会导致一些错误.

原因二: 使TCP连接双方都能够正常的关闭连接. 
如果客户端发送给服务端的ACK报文在网络中丢失了, 2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 在网络中丢失或阻塞, 没有传送到服务端，那么服务端会在2MSL的时间内重传FIN报文给客户端. 客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时. 等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。
```

21.HTTPS协议过程

```
SSL/TLS 协议基本流程：
    客户端向服务器索要并验证服务器的公钥。
    双方协商生产「会话秘钥」。
    双方采用「会话秘钥」进行加密通信。
前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。SSL/TLS 的「握手阶段」涉及四次通信，可见下图：
1. ClientHello
首先, 由客户端向服务器发起加密通信请求, 也就是ClientHello请求.
在这一步, 客户端主要向服务器发送如下信息:
（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。
（2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。
（3）客户端支持的密码套件列表，如 RSA 加密算法。

2. ServerHello
服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。
服务器回应的内容有如下内容：
（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。
（2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。
（3）确认的密码套件列表，如 RSA 加密算法。
（4）服务器的数字证书。

3. 客户端回应
客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。
如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。
（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。
上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

4. 服务器的最后回应

服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：
（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过使用「会话秘钥」加密内容。
```

22.GET, POST区别

```
GET - 从指定的资源请求数据
POST - 向指定的资源提交要被处理的数据。

白话:
根据 RFC 规范,GET 的语义是从服务器获取指定的资源,这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中,URL 规定只能支持 ASCII,所以 GET 请求的参数只允许 ASCII 字符 ,而且浏览器会对 URL 的长度有限制（但是HTTP协议本身对 URL长度并没有做任何规定）。
根据 RFC 规范,POST 的语义是根据请求负荷（报文body）对指定的资源做出处理,具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中, body 中的数据可以是任意格式的数据,只要客户端与服务端协商好即可,而且浏览器不会对 body 大小做限制。
另一个呢, GET 方法就是安全且幂等的,因为它是「只读」操作,无论操作多少次,服务器上的数据都是安全的,且每次的结果都是相同的。所以,可以对 GET 请求的数据做缓存,POST 因为是「新增或提交数据」的操作,会修改服务器上的资源,所以是不安全的,且多次提交数据就会创建多个资源,所以不是幂等的。所以,浏览器一般不会缓存 POST 请求,也不能把 POST 请求保存为书签。
```

23.TCP, UDP的应用场景

```
由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：
    FTP 文件传输；
    HTTP / HTTPS；
由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于包总量较少的通信，
	如 DNS 、SNMP 等；
	视频、直播等多媒体通信；
	广播通信
```

24.DNS查询的详细过程

```
DNS查询就是寻找哪台机器上有我们所需要资源的过程. 就是将域名 映射到 具体的IP地址的过程
...
所以DNS根据域名查询IP地址的过程为：浏览器缓存 --> 操作系统缓存(本地Hosts文件) --> 路由器缓存-->本地（ISP）域名服务器缓存 --> 根域名服务器 --> 顶级域名服务器 --> 权限域名服务器。
```

25.TCP, UDP的区别

```
1. 连接
TCP 是面向连接的传输层协议，传输数据前先要建立连接。
UDP 是不需要连接，即刻传输数据。
2. 服务对象
TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信
3. 可靠性
TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
UDP 是尽最大努力交付，不保证可靠交付数据。
4. 拥塞控制, 流量控制
TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
5. 传输方式
TCP 是流式传输，没有边界，但保证顺序和可靠。
UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
```

26.TCP的包丢了怎么办, 重传有哪几种类型?

```
TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。
重传主要有两种类型, 一种是超时重传, 一种是快速重传.
超时重传就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据. TCP会在两种情况下发生超时重传, 一是发送给对方的数据包丢失, 二是对方返回的ACK确认应答丢失.超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。
但是, 超时触发重传的问题是, 超时等待的时间可能相对较长,那么我们可以采用快速重传机制, 他不以时间为驱动, 而是以数据为驱动来进行重传动作.
例子:
发送方发出了1, 2, 3, 4, 5份数据, 第一份数据先送到了于是服务端返回ACK为2, 但是第二份数据在网络中丢失或者阻塞了, 后面的第三份数据, 第四份数据都陆续收到了, 但是这时候接收方都是返回ACK为2的确认应答. 这时发送方连续收到了三个ACK = 2的确认, 就知道第二份数据还没有送到接收方, 就在定时器过期之前, 立刻重传第二份数据. 这样可以节省了等待超时的时间.
但是关于是否只重传第二份数据, 还是重传之后的所有数据, 发送方并不清楚, 因为不知道是哪几份数据发回来的ACK = 2的确认, 
... SACK DSACK
```

27.TCP粘包怎么解决?

```
粘包出现的原因:
简单得说，在流传输中出现，UDP不会出现粘包，因为它有消息边界, UDP 报文中的数据部分就是完整的用户消息，也就是每个 UDP 报文就是一个用户消息的边界，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。

而对于TCP协议来说, 它是面向字节流的
也就是说, 当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文(超过MSS)，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。
我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议。
当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。

原因:
1发送端需要等缓冲区满才发送出去，造成粘包
2接收方不及时接收缓冲区的包，造成多个包接收
具体点：
（1）发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据Nagle优化算法(TCP默认开启, 为了避免网络充斥着过多的小包，提高网络传输的效率)把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。
（2）接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。

解决办法:
粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。
一般有三种方式分包的方式：

固定长度的消息；
特殊字符作为边界；
自定义消息结构。

1.固定长度的消息
这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。
但是这种方式灵活性不高，实际中很少用。

2.特殊字符作为边界
我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。
HTTP 是一个非常好的例子。HTTP 通过设置回车换行符作为 HTTP 报文协议的边界。有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。

3.自定义消息结构
我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。
```

28.TCP为什么要三次握手

```
我认为TCP三次握手主要有两个原因,首要原因是为了防止历史连接初始化造成混乱和资源浪费, 其次是为了同步双方的起始序列号.
对于第一个原因, 
我们考虑这样的情况,假设客户端先发了一个序列号为90的SYN请求报文, 但是它在网络中某个节点被阻塞了, 然后客户端又发送了另一个新的SYN请求报文, 序列号为100, 但是旧的请求报文比新的先到达服务端, 然后服务端回返回一个SYN ACK报文, 其中ack确认号为91, 这显示是错的, 客户端收到该ACK报文之后, 发现确认号为91而不是101, 判定这是一个历史连接, 客户端就发送一个RST报文回去告知服务端, 终止这次连接.
如果没有三次握手, 那么服务端在接收到请求报文之后立刻建立连接, 没有等待客户端的确认, 那么显然会出现混乱和资源浪费.
第二个原因就是, 
TCP 协议的通信双方， 都必须维护一个「序列号」， 以标识发送出去的数据包中, 哪些是已经被对方收到的。序列号是可靠传输的一个关键因素. 序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。
```

29.HTTP协议有哪几种请求方法

```
GET 请求指定的页面信息
POST 向指定资源提交数据进行处理请求(例如提交表单或者上传文件). 文件被包含在请求体中, POST请求可能会导致新的资源的建立或者已有资源的修改
HEAD 类似于get请求, 只不过返回的响应中没有具体的内容, 用于获取报头
DELETE 请求服务器删除指定的页面
PUT 向指定资源位置上传其最新内容
```

30.GET和POST哪个能传较大的数据

```
POST
使用GET方法时，请求参数和对应的值会附加在URL后面, 不同浏览器会对URL的长度有所限制, 当超过这个长度会报错. 一般来说, GET方法中请求体中不携带数据
而POST会将数据放在请求体中传过去
```

31.HTTP头部字段

```
Host字段 客户端发送请求时，用来指定服务器的域名
Connection字段 最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。
User-Agent:客户端程序的信息，就是我发送请求的浏览器信息。
Accept：列出了浏览器可以接收的媒体数据类型：
Accept-Language:告知服务器浏览器能够处理的自然语言集（中文、英文等）。zh-CN中文简体。
Accept-Encoding:告知服务器浏览器能够接收的压缩方式
Cookie：浏览器记录的用户相关信息。
Content-Length字段 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。
Content-Type字段 用于服务器回应时，告诉客户端，本次数据是什么格式。
Content-Encoding字段 说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式
```

32.HTTP版本的区别

```
https://blog.csdn.net/qq_40860852/article/details/93632106
HTTP/0.9：功能简陋，只支持GET方法，只能发送HTML格式字符串。
HTTP/1.0：支持多种数据格式，增加POST、HEAD等方法，增加头信息，每次只能发送一个请求（无持久连接）
HTTP/1.1：默认持久连接、请求管道化、增加缓存处理、增加Host字段、支持断点传输分块传输等。
HTTP/2.0：二进制分帧、多路复用、头部压缩(HPACK)、服务器推送
```

33.HTTP状态码

```
1xx 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少
2xx 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
	200 OK 是最常见的成功状态码, 表示一切正常。除了HEAD请求, body体都会带有数据
	204 No Content	和200 OK基本相同, 但响应头没有body数据
3xx 3xx 类状态码表示客户端请求的资源位置发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
	301 Moved Permanently 表示永久重定向, 说明请求的资源已经不存在了，需改用新的 URL 再次访问。
	302 Found 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
4xx 4xx类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义
	400 Bad Request 表示客户端请求的报文有错误，但只是个笼统的错误
	403 Forbidden 表示服务器禁止访问资源，并不是客户端的请求出错。
	404 Not Found 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
5xx  5xx类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。
	
```

34.说一下七层OSI模型

```
OSI七层模型: 物联         网    淑   慧试用
TCP/IP模型: 网络接口层  网络层 传输层 应用层
```

35.TCP, UDP的区别和适用场景

```
1. 连接
TCP 是面向连接的传输层协议，传输数据前先要建立连接。
UDP 是不需要连接，即刻传输数据。
2. 服务对象
TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信
3. 可靠性
TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
UDP 是尽最大努力交付，不保证可靠交付数据。
4. 拥塞控制, 流量控制
TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
5. 传输方式
TCP 是流式传输，没有边界，但保证顺序和可靠。
UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

适用场景:
由于 TCP 是面向连接,能保证数据的可靠性交付,因此经常用于：
FTP 文件传输；
HTTP / HTTPS；

由于 UDP 面向无连接,它可以随时发送数据,再加上UDP本身的处理既简单又高效,因此经常用于：
包总量较少的通信,如 DNS 、SNMP 等；
视频、音频等多媒体通信；
广播通信；
```

36.IP协议的报头

```
IP协议版本字段 头长度  服务类型 包总长度
  标志位(DF, MF) 片偏移量
源IP
目的IP
选项为非固定信息，可变长度，选项最长可达40个字节，这个字段主要用于测试。
```

37.说下三次握手的原理

```
1.一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态
2.客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。
3.服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。
4.客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。

从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题。
```

38.说一下SYN攻击

```
我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 请求报文发送给服务端，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端返回给客户端的 ACK + SYN 报文，全部都被客户端给有意忽略掉不进行确认，同时服务端还会不停重发SYN ACK报文, 久而久之就会占满服务端的半连接队列，服务端的内存, 带宽资源都会耗尽, 使得服务器不能为正常用户服务。
```

39.如何防范SYN攻击

```
如果不断受到 SYN 攻击，就会导致 SYN 队列（半连接队列）被占满，从而导致无法再建立新的连接。
第一个办法就是通过增加服务端SYN半连接队列的大小, 我们通过修改应用的listen函数调用和一个操作系统内核参数来显示的扩充SYN半连接队列的大小, 但显然这种方法本身并不能被完全认为是抵御SYN洪泛的有效方法，即使在一些能够有效支持超大SYN半连接队列分配的操作系统中，因为攻击者能够任意生成比其操作系统支持的队列上线还多得多的数据报。

其实最常用的一个手段就是优化主机系统设置。比如降低SYN timeout时间，使得主机尽快释放半连接的占用, 如果短时间内收到了某个IP的重复SYN请求，我们就认为受到了攻击。我们合理的采用防火墙设置等外部网络也可以进行拦截。

我们还可以采用SYN Cookies的策略, 当 「SYN 队列」满之后，后续服务器收到 SYN 包，就不再进入「 SYN 队列」；
TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来. 然后服务端再检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。
也就是说后续的合法的TCP连接不用再进入SYN半连接队列, 而是直接进入Accept全连接队列, 等待应用程序调用 accpet() socket 接口，从「 Accept 队列」取出连接。

请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。
```

40.说下TCP的拥塞控制机制

42.什么是Cookie 和 Session?

```
HTTP Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带(请求头的cookie字段)并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

Session是另一种记录客户状态的机制，不同于Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。每个用户访问服务器都会建立一个Session并自动分配一个SessionId，用于标识用户的唯一身份。这个 sessionID 会被保存在浏览器的会话 cookie 中
```

43.Cookie 和 Session 有什么不同？

```
作用范围不同，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。 Cookie 保存在客户端（浏览器），Session 保存在服务器端。
存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。
```

44.说一说拥塞控制和流量控制

```
主要区别：流量控制解决的是发送方和接收方速率不匹配的问题；拥塞控制解决的是避免网络资源被耗尽的问题。流量控制是通过滑动窗口来实现的；拥塞控制是通过拥塞窗口来实现的。

流量控制:
接收方和发送方都维护一个窗口, 即发送窗口和接收窗口
发送窗口被三个指针分为四段, 分别是已经发送并且收到确认的报文, 已经发送但是还没有收到确认的报文, 在发送窗口内但是还没有发送的报文以及不在发送窗口内的报文
每次接收方都会根据自身接收缓存区的实际大小来更新接收窗口的大小, 表示自己目前还能接收多少数据, 这个值由接收方发送的ACK报文中的windows字段表示, 所以每次发送方接收到ACK确认报文之后, 就根据其中的windows字段来动态的更新自己的发送窗口
流量控制解决的是端到端的问题, 即使接收方来得及接收发送方的数据


拥塞控制:
拥塞控制是一个全局性的概念, 拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；
慢启动 --> 拥塞避免 --> 拥塞发生算法
1）TCP连接初始化，将拥塞窗口设置为1
2）执行慢开始算法，cwind按指数规律增长，c直到wind == ssthresh(慢启动门限)开始执行拥塞避免算法，cwnd按线性规律增长
3）当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤（2）执行。

快重传和快恢复
一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。
快重传算法并非取消了重传机制，只是在某些情况下更早的重传丢失的报文段（如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时）。慢开始算法只是在TCP建立时才使用。
快恢复算法有以下两个要点：
1）当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半，这是为了预防网络发生拥塞。
2）由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把cwnd值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法，使拥塞窗口的线性增大。

总结：
没有发生拥塞之前使用前两种算法(慢启动, y)，发生拥塞之后根据是发生了超时重传还是快重传决定不同的拥塞发生算法, 即慢启动还是快恢复。
```

