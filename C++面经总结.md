#### C++面经总结
#### 1. C++基础
1. 在main执行之前和之后执行的代码可能是什么？
   - main函数执行之前，主要就是初始化系统相关资源
     - 初始化静态static变量和global全局变量，即.data段的内容
     - 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
     - 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容
     - 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
     - __attribute__((constructor))   
   - main函数执行之后，主要是释放一些系统资源
     - 全局对象的析构函数会在main函数之后执行；
     - 可以用 atexit 注册一个函数，它会在main 之后执行;
     - __attribute__((destructor))  
2. 结构体内存对齐问题
   - 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
   - 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐使**总大小**为8的倍数，其余如char则是占用4个字节）
   - 对齐的目的是
     - 硬件原因
        不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
     - 性能原因
        为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需一次访问
   - c++11以后引入两个关键字 alignas (opens new window)与 alignof (opens new window)。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式
3. 指针和引用的区别
   - 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
   - 指针可以为空，引用不能为NULL且在定义时必须初始化
   - 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
   - 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
   - sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
4. 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？
   - 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。
   - 类对象作为参数传递的时候使用引用，对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
5. 堆和栈的区别
   - 申请方式不同
        堆是自己申请和释放的，栈由系统自动分配
   - 空间大小不同
        堆是不连续的内存区域，受限于计算机系统中有效的虚拟内存（32位 4G）
        栈是一块连续的内存区域，大小固定，过ulimit -a查看，由ulimit -s修改
   - 管理机制不同
        堆由链表管理，当在堆中申请空间时，操作系统首先从空闲链表中找到第一个空间大于“申请空间”的节点，将其分配。多余的部分，系统自动放回空闲链表。在这块内存空间首地址处记录分配的大小，如此，之后的delete()才能正确释放内存空间。
        只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出
   - 碎片问题
        对于堆，频繁的new/delete会造成大量碎片，使程序效率降低
        对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。
   - 生长方向不同
        堆向上，向高地址方向增长。	栈向下，向低地址方向增长。
        (堆从低向高扩展，方便内存管理。栈从高向低是为了最大程度利用地址空间，否则必须指定栈堆的分界线，会导致分配不均。同时高向低也确定了栈空间的起始位置，避免了动态扩展栈空间时需要移动整个栈的数据
   - 分配效率不同
        堆由C/C++函数库提供在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。
        而计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。
        所以堆的效率比栈低很多
6. 区别以下指针类型？
    int *p[10]:指针数组，数组内每个元素都是指向int类型的指针变量
    int (*p)[10]:数组指针，指针类型，指向的是一个int类型，大小是10的数组
    int *p(int)：函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
    int (*p)(int)：函数指针，指向的函数具有int类型参数，并且返回值是int类型的
    const int *p1 = &a;或者 int const *p1 = &a指针常量（指向常量的指针），指针常量不可修改其指向地址的值
    int *const p2 = &a;常量指针，指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化
7. new / delete 与 malloc / free的异同
   - 相同点
        都可用于内存的动态申请和释放
   - 不同点
     - 前者是C++运算符，后者是C/C++语言标准库函数
     - new自动计算要分配的空间大小，malloc需要显式指定
     - new是类型安全的，malloc不是。因为malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。例如：
        int *p = new float[2]; //编译错误
        int *p = (int*)malloc(2 * sizeof(double));//编译无错误
     - new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL
     - new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者不具有调用构造函数和析构函数功能。
     - new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象
8. new和delete是如何实现的？
   - new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针
   - delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存
8. malloc与free的实现原理？
    - 操作系统将可用的内存块连接为空闲链表，调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二。接下来，将分配给用户的那块内存传给用户，并将剩下的那块返回到连接表上。如果空闲链上没有足够大的内存块，则将相邻的小空闲块合并成较大的内存块再使用。
    - 调用free函数时，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。它将用户释放的内存块连接到空闲链上。
    - 底层是使用了brk、mmap、，munmap这些系统调用来分配虚拟内存，之后在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；
9.  既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？
    动态创建对象时，malloc/free可以申请内存和回收内存，但无法指向构造函数和析构函数。会导致内存泄露。
10. 被free回收的内存是立即返还给操作系统吗？
    不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片
11. 宏定义和函数有何区别？
    - #define PI 3.1415926,  #define A(x) x
    - 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
    - 宏定义没有返回值；函数调用具有返回值。
    - 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
    - 宏定义不要在最后加分号
12. define宏定义和typedef区别？
    - 作用
        宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名
    - 编译阶段
        宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分
    - 安全性
        宏不检查类型；typedef会检查数据类型
    - 在有指针的场景不一样
        typedef char *pStr1;
        #define pStr2 char *;
        pStr1 s1, s2;
        pStr2 s3, s4;
        s1、s2、s3都被定义为char *，而s4则定义成了char
13. define宏定义和const的区别
    - 编译阶段
        define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用
    - 安全性
        define只做替换，不做类型检查和计算
        const常量有数据类型，编译器可以对其进行类型安全检查
    - 内存占用
        define只是将宏名称进行替换，在内存中会产生多份相同的备份。const在程序运行中只有一份备份但要分配内存空间
14. 变量声明和定义区别？
    - 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
    - 相同变量可以在多处声明（外部变量extern），但只能在一处定义。
15. strlen和sizeof区别？
    - sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
    - sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
    - 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。
16. 一个指针占多少字节？
    在64位的编译环境下的，指针的占用大小为8字节；而在32位环境下，指针占用大小为4字节。一个指针占内存的大小跟编译环境有关，而与机器的位数无关。
17. int a[10] 中a和&a有什么区别？
    - 假设数组int a[10]; int (*p)[10] = &a;其中：
        a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
        &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
        若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。
18. 数组名和指针（这里为指向数组首元素的指针）区别？
    - 数组名是常量指针，不能自增自建，但指向数组首元素的指针是变量指针
    - 数组名取地址得到的是数组名所指元素的地址。 对指针取地址得到的是指针变量自身的地址。
    - 当对数组名使用sizeof时，得到的是数组元素的个数乘元素类型的字节数，对指针sizeof得到的是指针类型的字节数
19. C++和Python的区别
    - Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。
    - Python使用缩进来区分不同的代码块，C++使用花括号来区分
    - C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等
    - Python的库函数比C++的多，调用起来很方便。比如在数据处理中。
20. C++和C语言的区别
    - C++是面向对象的，而C是面向过程的。c++支持面向对象程序设计、泛型程序设计等多种程序设计风格，而C没有类似的概念
    - C++中取代很多C中原有的功能
        C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。
        标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。
        C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。
        C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。
    - C++允许重载，而C不允许
    - C++增加了引用，而C没有
    - C++中存在命名空间的概念用于区分不同作用域的同名变量，而C没有命名空间的概念
21. C++中struct和class的区别
    - 相同点
        两者都拥有成员函数、公有和私有部分
        任何可以使用class完成的工作，同样可以使用struct完成
    - 不同点
        两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
        class默认是private继承， 而struct默认是public继承  
22. C++和C的struct区别
     - C：struct是用户自定义数据类型（UDT）；C++：struct是抽象数据类型（ADT），也可以用于自定义结构体类型。
     - C：struct没有权限，C++：有权限，支持继承，多态，以及成员函数的定义
     - C：typedef struct A{}; C++： struct A{}；
23. C++中static的作用
      - 不考虑类的情况
        - 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用.通过include使用。
        - 保持变量内容的持久。c语言中其在代码执行之前初始化，属于编译期初始化。静态变量在函数内定义，作用范围与局部变量相同，函数退出后仍然存在，但不能被别的函数使用。共有两种变量存储在全局初始化区：全局变量和static变量。
        - 默认初始化为0。包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
      - 考虑类的情况
        - static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
        - static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问
        - static成员函数不能被virtual修饰，static成员不属于任何对象或实例
24. C++中const的作用
    - 不考虑类的情况
        - const常量在定义时必须初始化，之后无法更改
        - const形参可以接收const和非const类型的实参，和引用结合时可以防止修改被引用的对象
    - 考虑类的情况
        - const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；类的不同对象对其const数据成员的值可以不同，所以不能在类中声明时初始化
        - const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值
    - 补充：
        - const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以声明使用。 因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。
        - const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；
25. C++的顶层const和底层const
    - 顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边
    - 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边
    - 顶层：const int a;int const a;int *const a;
    - 底层：const int *a;
26. final和override关键字
    - override：指定子类的虚函数必须是重写的父类的，如果父类没有对应的虚函数，编译器会报错
    - final：当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错
        void foo() override; class B final : A{};
27. 拷贝初始化和直接初始化
    直接初始化直接调用与实参匹配的构造函数
    拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象
        string str1("I am a string");//语句1 直接初始化
        string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化
        string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
        string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
28. 初始化和赋值的区别
    - 对于简单类型来说，初始化和赋值没什么区别
    - 对于类和复杂数据类型来说，这两者的区别就大了
       A a1 = a; 
       A b;  b = a;
       创建对象时初始化，分为直接初始化和拷贝初始化，使用"="的为拷贝初始化。分分布会调用构造函数和拷贝构造函数。而对于赋值，是在对象创建以后，在通过赋值擦除原值。如果重载了operator=，则会调用该重载
29. extern"C"的用法
    正确的在C++代码中调用C语言的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；
    extern "C" {

    }
30. 野指针和悬空指针
    - 野指针，指的是没有被初始化过的指针，为了防止出错，对于指针初始化时都是赋值为 nullptr
    - 悬空指针，指针最初指向的内存已经被释放了的一种指针
31. C和C++的类型安全
    - 类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。类型安全的编程语言与类型安全的程序之间，没有必然联系。
    - C是类型不安全的，比如malloc函数的返回值是空类型指针，如果我们使用显式的类型转换会产生问题，但是C并不会报错char* pStr=(char*)malloc(100*sizeof(char))
    - C++相对于C提供了一些新的机制保障类型安全
      - 操作符new返回的指针类型严格与对象匹配，而不是void*
      - C++模板函数支持类型检查
      - C++提供了dynamic_cast关键字，使得转换过程更加安全
32. C++中的重载、重写（覆盖）和重定义（隐藏）的区别
    - 重载（overload）
        重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关
    - 重写（覆盖）（override）
        重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数且：与基类的虚函数有相同的参数个数、参数类型、返回值类型
    - 重定义（隐藏）（hide）
        隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数
        - 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。
        - 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中
    - 重载与重写的区别：
        重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系
        重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
        重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体
33. C++有哪几种的构造函数
        默认构造函数
        初始化构造函数：有参数和参数列表
        拷贝构造函数（编译器也会生成）
        移动构造函数
            拷贝构造时，会调用拷贝构造函数产生临时对象，同时如果在函数内分配了内存，之后还需要对临时对象释放内存，存在不必要的开销。而移动构造函数可以通过它将临时对象的内存转移给后续对象，减少不必要的内存分配和释放。
            同时拷贝构造函数中指针是深拷贝的，而移动构造函数中指针是浅拷贝的，为了避免旧的指针释放空间，就将其置为NULL，这样析构的时候就不会回收空间
            A(A&& a):m_i(a.m_i){}
        委托构造函数
            委托构造函数是为了构造函数减少代码的重复,允许在同一个类中一个构造函数可以调用另外一个构造函数
            ClassA(int max, int min):ClassA(max) {}
        转换构造函数
            用于将其他类型的变量，隐式转换为本类对象。形参是其他类型变量，且只有一个形参
34. 内联函数和宏定义的区别
    - 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。
    - 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。
35. public，protected和private访问和继承的区别
    - 访问
        public的变量和函数在类的内部外部都可以访问。
        protected的变量和函数只能在类的内部和其派生类以及友元函数中访问。
        private修饰的元素只能在类内以及友元函数中访问 
    - 继承
       公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员
       保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
       私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。
    - 注意：派生类对基类成员的访问权限取决于两点：一、继承方式；二、基类成员在基类中的访问权限。基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
    - 派生类继承了所有的基类方法，除了
        基类的构造函数、析构函数和拷贝构造函数。
        基类的重载运算符。
        基类的友元函数
    - 恢复继承的成员在基类中的访问权限
        使用using 语句，这是C++标准建议使用的方式
36. 浅拷贝和深拷贝的区别
    - 浅拷贝
        浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。
    - 深拷贝
        深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的
        ```
        	Student(const Student &s){//拷贝构造函数
                //浅拷贝，当对象的name和传入对象的name指向相同的地址
                name = s.name;
                //深拷贝
                //name = new char(20);
                //memcpy(name, s.name, strlen(s.name));
                cout << "copy Student" << endl;
            };
        ```
37. 如何用代码判断大小端存储？
    0X12345678
    - 高低字节位：左边为高字节，右边为低字节
    - 大端存储：字数据的高字节存储在低地址中（符合人的阅读习惯）
    - 小端存储：字数据的低字节存储在低地址中（符合计算机处理）
    - 鉴别方式：使用强制类型转换
        ```
        #include <iostream>
        using namespace std;
        int main()
        {
            int a = 0x1234;
            //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
            char c = (char)(a);
            if (c == 0x12)
                cout << "big endian" << endl;
            else if(c == 0x34)
                cout << "little endian" << endl;
        }
        ```
38. volatile关键字的用法
    volatile定义变量的值是易变的，表明编译器不去优化该变量，每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。这样在多线程中使用被几个任务共享的变量就不会造成冲突。
    const char* cpch;volatile char* vpch;
    char* const pchc;char* volatile pchv;
39. mutable关键字的用法
    volatile定义变量的值是可变的，为了突破const的限制而设置的。可以在类中使用常量函数来修改被mutable修饰的变量。
    mutable int m_B;
40. explicit关键字的用法
    - explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换
    - 隐式转换即是可以由单个实参来调用的构造函数定义了一个从形参类型到该类类型的隐式转换。由默认的类型操作符或者重载的类型操作符来实现。
        operator int() {}
    - 注意
        explicit 关键字只能用于类内部的构造函数声明上
        explicit 关键字作用于单个参数的构造函数，多参数和无参数一遍都是显示调用的，所以不需要explicit
41. 什么情况下会调用拷贝构造函数
    - 拷贝初始化的时候，=
    - 非引用传递，函数的参数是类的对象时
    - 函数返回类的对象时
        产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象， 依然会调用拷贝构造函数
42. C++中有几种类型的new
    - plain new
        普通的new，就是我们常用的new
        int *p = new int(5);
        int *p = new int[5];
    - nothrow new
        char *p = new(nothrow) char[10];
        nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL
    - placement new
        - 主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组.placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。
        - placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。
            ADT *q = new(p) ADT; 
            q->ADT::~ADT();//显示调用析构函数,不能delete q;
	        delete[] p;
43. C++的异常处理的方法
    - 常见异常
        数组下标越界
        除法计算时除数为0
        动态分配空间时空间不足
    - try、throw和catch关键字
        try {
             throw -1；   
        }catch (int a) {

        }catch (...) {

        } 
    - 函数的异常声明列表
        int fun() throw(int,double,A,B,C){...};
    - C++标准异常类 exception
        #include <typeinfo>
        bad_typeid:指针为空抛出异常
        ```
        	try {
                cout << typeid(*a).name() << endl; // Error condition
            }
            catch (bad_typeid){
                cout << "Object is NULL" << endl;
            }
        ```
        bad_cast：bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常
        bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
        out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常
44. 形参与实参的区别？
    - 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
    - 实参在函数调用的时候必须要有确定的值
    - 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
45. 值传递、指针传递、引用传递的区别和效率
    - 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）
    - 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）
    - 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）
    效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。
46. C++初始化时机
    - 静态初始化
        是指用常量对变量进行初始化。其中未赋初值及初值为0的放在bss段，其他放在data段。静态初始化在程序加载时完成。
    - 动态初始化
        是指需要经过函数调用才能完成的初始化。 对于全局或者类的静态成员变量，是在main()函数执行前由运行时调用相应的代码进行初始化的。而对于局部静态变量，是在函数执行至此初始化语句时才开始执行的初始化。
    - 如果是静态初始化，是在main()函数之前，程序加载时初始化；如果是动态初始化，则要区分是局部静态变量还是全局变量或者全局静态变量，局部静态变量则在函数第一次执行到时初始化，否则在main()函数之前，运行时初始化。
47. 类与类之间的关系
    - 继承，is-a
        子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法
    - 依赖（dependence）既“use-a” 关系。
        类B作为参数被类A在某个method方法中使用
    - 聚合（aggergation） 即"has-a"关系。
        类B包含类A，整体与部分的关系，但是可以具有各自的生命周期。即成员对象不由整体对象初始化
    - 组合（composition） 
        类B包含类A，但整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。
48. malloc、realloc、calloc、allocator的区别
    - malloc就是一般的分配内存方式，需要传入申请的空间的大小
        int *p = malloc(20*sizeof(int));
    - calloc，省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；
        int *p = calloc(20, sizeof(int));
    - reallo：给动态分配的空间分配额外的空间，用于扩充容量
        void realloc(void *p, size_t new_size);
    - new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。
49. 类成员初始化方式？为什么用成员初始化列表会快一些？
    - 赋值初始化，通过在函数体内进行赋值初始化
    - 列表初始化，在冒号后使用初始化列表进行初始化
    - 列表初始化是给数据成员分配内存空间时就进行初始化,此时函数体还未执行。而赋值初始化会产生临时对象的。而赋值初始化会产生临时对象，额外调用构造函数。
50. 构造函数的执行顺序 ？
    - 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。
    - 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。
    - 类类型的成员对象的构造函数（按照初始化顺序）
    - 派生类自己的构造函数。
51. 有哪些情况必须用到成员列表初始化？作用是什么？
    - 四种情况
      - 当初始化一个引用成员时；
      - 当初始化一个常量成员时；
      - 当调用一个基类的构造函数，而它拥有一组参数时；
      - 当调用一个成员类的构造函数，而它拥有一组参数时；
    - 成员初始化列表做了什么
      - 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；
      - list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；
52. C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？
    - string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。
    - string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。
53. 什么是内存泄露，如何检测与避免
    - 的内存泄漏是指堆内存的泄漏，使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了
    - 避免内存泄露的几种方式
        - 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露
        - 一定要将基类的析构函数声明为虚函数
        - 对象数组的释放一定要用delete []
        - 有new就有delete，有malloc就有free，保证它们一定成对出现
        - 利用检测工具：Linux下可以使用Valgrind工具
54. 对象复用的了解
    对象复用其本质是一种设计模式：Flyweight享元模式。通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。
55. 零拷贝的了解
    零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。
    在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。
56. 介绍面向对象的三大特性，并且举例说明
    三大特性：继承、封装和多态
    - 继承
      -  让某种类型对象获得另一个类型对象的属性和方法。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
      - 常见的继承有三种方式：
        实现继承：指使用基类的属性和方法而无需额外编码的能力
        接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
        可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）
        例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法
    - 封装
        封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。
    - 多态
        - 同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。
      - 实现多态有二种方式：覆盖（override），重载（overload),重载实现编译时多态，虚函数实现运行时多态
        覆盖：是指子类重新定义父类的虚函数的做法。
        重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。
57. C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast
    - reinterpret_cast
        - reinterpret_cast<type-id> (expression)
        - type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。
    - const_cast
        - const_cast<type_id> (expression)
        - 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：
            常量指针被转化成非常量的指针，并且仍然指向原来的对象
            常量引用被转换成非常量的引用，并且仍然指向原来的对象
            const_cast一般用于修改底层指针。如const char *p形式
    - static_cast
       - static_cast < type-id > (expression)
       - 该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：
          - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换
          - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
          - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于**没有动态类型检查**，所以是不安全的
          - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
          - 把空指针转换成目标类型的空指针
          - 把任何类型的表达式转换成void类型
          - 注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。
    - dynamic_cast
        dynamic_cast <type-id> (expression)
          - 有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全
          - 该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用
          - dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）
          - dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换
                在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的
                在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全
58. C++函数调用的压栈过程
    顺序:main(),mian()中调用func(), func()中调用f()
    - 操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈
    - main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；
    - 当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈
    - 函数调用的过程
        从栈空间分配存储空间
        从实参的存储空间复制值到形参栈空间
        进行运算
    - 注意
        形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。
        数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。
        当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递
59. 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？
        coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。
        g++ coredumpTest.cpp -g -o coredumpTest
        ./coredumpTest
        gdb [可执行文件名] [core文件名]
60. C++中将临时变量作为返回值时的处理过程
    临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量.
    函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系
61. 如何获得结构成员相对于结构开头的字节偏移量
    使用<stddef.h>头文件中的，offsetof宏。
    struct  S
    {
        int x;
        char y;
        int z;
        double a;
    };
    cout << offsetof(S, x) << endl;
62. 静态类型和动态类型，静态绑定和动态绑定的介绍
    静态类型：对象在声明时采用的类型，在编译期既已确定；
    动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
    静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
    动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；    





#### 3. C++11新特性

#### 4. C++面向对象

#### C++内存管理

#### C++STL