### C++面经总结
### 1. C++基础
#### 1.1 综合问题
1. C++和Python的区别
   - Python是一种**脚本**语言，是**解释执行**的，而C++是**编译**语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。
   - Python使用缩进来区分不同的代码块，C++使用花括号来区分
   - C++中**需要事先定义变量**的类型，而**Python不需要**，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等
   - Python的**库函数**比C++的多，调用起来很方便。比如在数据处理中。
2. C++和C语言的区别
   - C++是**面向对象**的，而C是**面向过程**的。c++支持**面向对象程序设计**、**泛型程序设计**等多种程序设计风格，而C没有类似的概念。比如C++有重载，虚函数，模板的概念而C没有
   - C++中取代很多C中原有的功能
      - C++中**new和delete**是对内存分配的运算符，取代了C中的malloc和free。
      - 标准C++中的**字符串类**取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。
      - C++中用来做控制态输入输出的**iostream类库**替代了标准C中的stdio函数库。
      - C++中的**try/catch/throw异常处理机制**取代了标准C中的setjmp()和longjmp()函数。
   - C++的class和C的struct也有很大不同
   - C 是⼀种结构化的语⾔，重点在于算法和数据结构。 C 程序的设计⾸先考虑的是如何通过⼀个代码，⼀**个过程对输⼊进⾏运算处理输出**。⽽ C++ ⾸先考虑的是如何构造⼀个对象模型，让这个模型能够契合与之对应的问题领域，这样就能通过获取对象的状态信息得到输出
3. C和C++的类型安全
    - **类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域**。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。类型安全的编程语言与类型安全的程序之间，没有必然联系。
    - C是类型不安全的，比如malloc函数的返回值是空类型指针，如果我们使用显式的类型转换会产生问题，但是C并不会报错：char* pStr=(char*)malloc(100*sizeof(char))
    - C++相对于C提供了一些新的机制保障类型安全
      - 操作符new返回的指针类型严格与对象匹配，而不是void*
      - C++模板函数支持类型检查
      - C++提供了dynamic_cast关键字，使得转换过程更加安全
4. 在main执行之前和之后执行的代码可能是什么？
   - main函数执行之前，主要就是**初始化系统相关资源**
     - 初始化静态static变量和global全局变量，即.data段的内容
     - 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
     - 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容
     - 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
     - __attribute__((constructor)) 函数  
   - main函数执行之后，主要是释放一些系统资源
     - 全局对象的析构函数会在main函数之后执行；
     - 可以用 atexit 注册一个函数，它会在main 之后执行;
     - __attribute__((destructor))函数 
5. C++从代码到可执行程序经历了什么？（GCC工作流程）
    四步：预编译，编译，汇编，链接
   - **预编译（预处理代码.i）**
    主要处理源代码文件中的以“#”开头的预编译指令
        1.删除所有的#define，展开所有的宏定义。
        2.处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
        3.处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。
        4.删除所有的注释，“//”和“/**/”。
        5.保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。
   - **编译（汇编代码.s）**
       把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件(其分析的语义是**静态语义**——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义)
   - **汇编（二进制机器码.o）**
        将汇编代码转变成机器可以执行的指令(机器码文件)xxx.o(Linux 下)、xxx.obj(Window下)
   - **链接**
        将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接
6. main函数的返回值有什么值得考究之处吗？
    程序运行过程入口点main函数，main（）函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。
7. C++中struct和class的区别
    - 相同点
        两者都拥有成员函数、公有和私有部分
        任何可以使用class完成的工作，同样可以使用struct完成
    - 不同点
        两者中如果不对成员不指定公私有，**struct默认是公有的，class则默认是私有的**
        **class默认是private继承， 而struct默认是public继承**  
8. C++和C的struct区别
     - C：struct是用户**自定义数据类型**（UDT）；C++：struct是**抽象数据类型**（ADT），也可以用于自定义结构体类型。
     - C：struct没有权限，C++：**有权限，支持继承，多态，以及成员函数**的定义
     - C：typedef struct A{}; C++： struct A{}；  
9. 结构体内存对齐问题
   - 结构体内成员按照声明顺序存储，**第一个成员地址和整个结构体地址相同**。
   - 对齐原则
     - 第一个成员在与结构体变量偏移量为0的地址处。其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数 = min（编译器默认的一个对齐数 ，该成员大小）
        VS 中默认的值为 8
        Linux 中默认的值为 4
     - 结构体总大小为最大对齐数（每个成员变量除了第一个成员，都有一个对齐数）的整数倍。
     - 如果嵌套了结构体的情况，嵌套的结构体对齐到自己最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
     - 结构体的对齐数为结构体当中所有对齐数中的最大对齐数。
   - #pragma pack(n)
        n=1,2,4,8...偏移量要是n和当前变量大小中较小值的整数倍。整体大小要是n和最大变量大小中较小值的整数倍
   - 对齐的目的是
     - **硬件原因**
        不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
     - **性能原因**
        为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需一次访问
   - c++11以后引入两个关键字 alignas (opens new window)与 alignof (opens new window)。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式
10. C++结构体大小比较
   - 重载了 “==” 操作符
   - 元素的话，一个个比；
   - 指针直接比较，如果保存的是**同一个实例地址**，则(p1==p2)为真；
11. 如何获得结构成员相对于结构开头的字节偏移量
    ```
    使用<stddef.h>头文件中的，offsetof宏。
    struct  S
    {
        int x;
        char y;
        int z;
        double a;
    };
    cout << offsetof(S, x) << endl;
    ```
12. 说⼀下 ++i 和 i++ 的区别
    ++i （前置加加）先⾃增 1再返回， i++ （后置加加）先返回 i 再⾃增1。前置加加不会产⽣临时对象，后置加加必须产⽣临时对象，临时对象会导致效率降低
13. 为什么在使用循环语句的过程中，auto&& 是最安全的方式？
    因为当auto被推导为不同的左右引用时，与&&的坍缩组合是完美转发。

#### 1.2 指针与引用
1. C++中的值传递,指针参数传递,引用参数传递有什么区别？底层原理你知道吗？
   - 值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数**传递进来的实参值**，从⽽形成了实参的⼀个副本。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进⾏的，**不会影响主调函数的实参变量的值**。
   - 指针参数传递本质上是值传递，也就是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量形参指针变了，实参指针不会变。但是可以通过形参指针来改变指向的地址中对应的值。
   - 引⽤参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的**实参变量的地址**。被调函数对形参（本体）的任何操作都被处理成**间接寻址**，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，**被调函数对形参的任何操作都会影响主调函数中的实参变量**
    - 原理是：
      - 指针和引⽤都是⼀种内存地址的概念，但是指针是⼀个实体，引⽤只是⼀个别名。
      - 在程序编译的时候，将指针和引⽤添加到符号表中。指针它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“**指针变量名-指针变量的地址**”添加到符号表中，所以说，指针包含的内容是可以改变的。
      - ⽽对于引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将 **"引⽤变量名-引⽤对象的地址"**添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和⾮ const 区别。
2. 指针和引用的区别
   - 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
   - 指针可以为空，引用不能为NULL且在定义时必须初始化
   - 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
   - 指针参数传递本质是值传递，而引用参数传递则不同
   - sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
3. 什么时候该使用指针，什么时候该使用引用呢？
   - 一般原则
      - 如果数据对象很**小**，如内置数据类型或者小型结构，则按照值传递；
      - 如果数据对象是**数组**，则使用指针（唯一的选择），并且指针声明为指向const的指针；
      - 如果数据对象是较大的**结构**，则使用const指针或者引用，已提高程序的效率
      - 如果数据对象是**类对象**，则使用const引用
   - 需要返回函数内局部变量的内存的时候用指针，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。
4. 使用引用的好处与限制
   - 好处
     - **在函数内部可以对此参数进行修改**
     - **提高效率**
       - 引用作为形参时，避免了调用类中的拷贝构造函数在内存中创建临时对象的过程
       - 引用作为返回值时，避免了调用类中的拷贝构造函数在内存中创建临时对象的过程
     - 可以作为左值：fun(1) = 2;
   - 限制
     - 不能返回**局部变量的引用**
     - 不能返回**函数内部new分配的内存的引用**.
        如果引用只是作为临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由 new分配）就无法释放，造成memory leak
     - 可以返回类成员的引用，但是最好是const
5. 区别以下指针类型？
   - int *p[10]:**指针数组**，数组内每个元素都是指向int类型的指针变量
   - int (*p)[10]:**数组指针**，指针类型，指向的是一个int类型，大小是10的数组
   - int *p(int)：**函数声明**，函数名是p，参数是int类型的，返回值是int *类型的。
   - int (*p)(int)：**函数指针**，指向的函数具有int类型参数，并且返回值是int类型的
   - const int *p1 = &a;或者 int const *p1 = &a**指针常量**（指向常量的指针），指针常量不可修改其指向地址的值
   - int *const p2 = &a;**常量指针**，指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化
6. 一个指针占多少字节？
    在64位的编译环境下的，指针的占用大小为8字节；而在32位环境下，指针占用大小为4字节。一个指针占内存的大小跟编译环境有关，而与机器的位数无关。
7. int a[10] 中a和&a有什么区别？
   - 假设数组int a[10]; int (*p)[10] = &a;其中：
     - a是数组名，是**数组首元素地址**，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
     - &a是**数组的指针**，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
     - 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。
8. 数组名和指针（这里为指向数组首元素的指针）区别？
    - **数组名是常量指针，不能自增自减**，但指向数组首元素的指针是变量指针
    - 数组名取地址得到的是数组名所指元素的地址。 对指针取地址得到的是指针变量自身的地址。
    - 当对数组名使用sizeof时，得到的是**数组元素的个数乘元素类型的字节数**，对**指针sizeof得到的是指针类型的字节数**    
9. 继承机制中对象之间如何转换？指针和引用之间如何转换？
    - **向上类型转换**
        将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会**自动进行**，而且向上类型转换是安全的。
    - **向下类型转换**
        将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换**不会自动进行**，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以**在向下类型转换时必须加动态类型识别技术。用dynamic_cast进行向下类型转换**
10. 函数指针
    - 函数指针指向一个函数，而函数由其返回的数据类型和其参数列表共同决定，其返回的数据类型和其参数列表共同决定。在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。有了指向函数的指针变量后，可⽤该指针变量调⽤函数
    - int (*pf)(const int&, const int&);
    - 作用：
      - **将函数作为参数传递给函数**
      - **嵌入式中引用不在代码段中的函数，有些函数固化在ROM中，不能直接使用函数名调用**
11. 野指针和悬空指针
    - **野指针**，指的是没有被初始化过的指针，为了防止出错，对于指针初始化时都是赋值为 nullptr
    - **悬空指针**，指针最初指向的内存已经被释放了的一种指针，会导致不安全不可控的行为
    - 如何避免使⽤野指针？ 
        在平时的编码中，养成在定义指针后且在使⽤之前**完成初始化的习惯或者使⽤智能指针**。
12. 指针加减计算要注意什么？
    需要明确的是指针每移动一位，它实际跨越的内存间隔是**指针类型的长度**，不能越位
13. 形参与实参的区别？
    - 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
    - 实参在函数调用的时候**必须要有确定的值**
    - 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
#### 1.3 宏定义与内联函数
1. define宏定义和函数或者说inline函数有何区别？
    - #define PI 3.1415926,  #define A(x) x
    - 宏在**预处理阶段**完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在**运行时**需要跳转到具体调用函数。
    - 宏定义没有**返回值**；函数调用具有返回值。
    - 宏定义参数**没有类型**，不进行类型检查；函数参数具有类型，需要检查类型。
2. define宏定义和typedef区别？
    - 作用
        宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名
    - 编译阶段
        宏替换发生在预编译阶段，属于文本插入替换；typedef是编译的一部分
    - 安全性
        宏不检查类型；typedef会检查数据类型
    - 在有指针的场景不一样
        typedef char *pStr1;
        #define pStr2 char *;
        pStr1 s1, s2;
        pStr2 s3, s4;
        s1、s2、s3都被定义为char *，而s4则定义成了char
3. define宏定义和const的区别
    - 编译阶段
        define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用
    - 安全性
        define只做替换，不做类型检查和计算
        const常量有数据类型，编译器可以对其进行类型安全检查
    - 内存占用
        define只是将宏名称进行替换，在内存中会产生多份相同的备份。const在程序运行中只有一份备份但要分配内存空间
4. 为什么不能把所有的函数写成内联函数?
    - 内联函数的目的
        调用函数时**需要保存现场和执行的地址**，调用完成后要恢复现场并按照原地址继续执行。存在空间和时间上的开销。对于代码量不大，但被频繁调用的函数来说，效率不高
    - 什么情况下不可以使用内联
      - 函数体内有循环，**函数执行时间远大于函数调用的时间开销**
      - 内联函数调用需要复制代码，如果**函数体内的代码比较长，将导致内存消耗代价** 

#### 1.4 关键字      
1. C++中static的作用
   - 不考虑类的情况
     - **隐藏**。static的全局作用域只是自身编译单元，即单一源码+头文件中。一般将静态变量放在原文件中而不是头文件，否则会为每个包含该头文件的cpp源文件都创建一份变量。如果要在不同文件内共享一个全局变量，应当使用extern。
     - **保持变量内容的持久**。在代码执行之前初始化，属于**编译期初始化**。静态变量在函数内定义，作用范围与局部变量相同，函数退出后仍然存在，但**不能被别的函数使用**。
     - 默认初始化为0。包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区，而全局变量和static变量存储在全局初始化区
   - 考虑类的情况
     - static成员变量：**只与类关联，不与类的对象关联**。定义时要分配空间，不能在类声明中初始化，必须在**类定义体外部初始化**，初始化时不需要标示为static；**可以被非static成员函数任意访问**。
     - static成员函数：不具有this指针，**无法访问类对象的非static成员变量和非static成员函数**；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问
     - static成员函数不能被virtual修饰，static成员不属于任何对象或实例
2. static成员与普通成员的区别是什么
   - **生命周期**
        静态成员变量从类被加载开始到类被卸载，一直存在；
        普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；
   - **共享方式**
      静态成员变量是全类共享；普通成员变量是每个对象单独享用的；
   - **定义位置**
      普通成员变量存储在栈或堆中，而静态成员变量存储在全局区；
   - **初始化位置**
      普通成员变量在类中初始化；static修饰的变量先于对象存在，静态成员变量在类外初始化；
   - 默认实参
      可以使用静态成员变量作为默认实参
3. static函数和普通函数的区别
    - 作用域不同
        用static修饰的函数，本限定在本源码文件中，**不能被本源码文件以外的代码文件调用**。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。
    - 内存占用不同
        static函数在内存中只有一份，**普通函数在每个被调用中维持一份拷贝**
    - 好处
        - **其他文件中可以定义相同名字的函数，不会发生冲突**
        - **静态函数不能被其他文件所用**
4. C++中const的作用
    - 不考虑类的情况
        - const常量在定义时必须初始化，之后无法更改
        - const形参可以接收const和非const类型的实参，和引用结合时**可以防止修改被引用的对象**
    - 考虑类的情况
        - const成员变量：不能在类定义外部初始化，**只能通过构造函数初始化列表进行初始化**，并且必须有构造函数；类的不同对象对其const数据成员的值可以不同，所以不能在类中声明时初始化
        - const成员函数：**const对象不可以调用非const成员函数**；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值
    - 补充：
        - const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以声明使用。 因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。
        - const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；
5. 为什么常量对象可以调⽤类中的 const 成员函数，但不能调⽤⾮ const 成员函数？
   - 因为在调用类的成员函数中还会隐式传入一个指向当前对象的this指针。
   - 非const成员函数中的隐式参数为**常量指针**： int *const p
   - 而const成员函数中的隐式参数为指向常量的**常量指针**：const int *const p。
   - 所以如果使用常量对象调用非常量函数，会出现**类型不匹配的错误**。
6. C++的顶层const和底层const
    - 顶层const：指的是const修饰的**变量本身是一个常量**，无法修改，指的是指针，就是 * 号的右边
    - 底层const：指的是const修饰的变量**所指向的对象是一个常量**，指的是所指变量，就是 * 号的左边
    - 顶层：const int a;int const a;int *const a;
    - 底层：const int *a;
7. 返回值是const的情况
   - 返回值是const指针
        返回的是指针常量，不能修改指向的值。并且返回值只能被赋给const修饰的同类型指针
        ```
        const char *getString(){};
        const char *str = getString();
        ```
   - 返回值采用值传递方式
        没有意义，因为返回的是临时变量
   - 返回值是引用
        限制不能将函数表达式作为左值引用
        ```
        int &min ( int &i, int &j);
        min ( a , b )=4;
        const int &min( int & i, int &j);
        ```
8. 常量存放在内存的哪个位置？
   - 对于**局部常量**，存放在栈区；
   - 对于**全局常量**，存放在全局/静态存储区
   - 对于**字⾯值常量**，⽐如字符串，放在常量区。
9.  volatile关键字的用法
    volatile定义变量的值是易变的，表明编译器不去优化该变量.编译器对于没有更改过的变量会存储在高速缓存即**寄存器**中。加了volatile关键字后每次操作该变量时**一定要从内存中**真正取出，而不是使用已经存在寄存器中的值。这样在**多线程中**使用被几个任务共享的变量就不会造成冲突。
10. mutable关键字的用法
    - volatile定义变量的值是可变的，为了突破const的限制而设置的。可以在类中使用常量函数来修改被mutable修饰的变量。
    ```
    mutable int m_B;
    int getB() const {
       return this->m_B++;
    }
    ```
11. explicit关键字的用法
    - explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，**不能发生相应的隐式类型转换**，只能以显示的方式进行类型转换
    - 关键字explicit只对**一个实参**的构造函数有效，需要**多个实参的构造函数不能用于执行隐式转换**，所以无需将这些构造函数指定为explicit。
    - 除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数
    ```
    class CxString  // 使用关键字explicit的类声明, 显示转换  
    {  
    public:  
        char *_pstr;  
        int _size;  
        explicit CxString(int size)  
        {  
            _size = size;  
            // 代码同上, 省略...  
        }  
        CxString(const char *p)  
        {  
            // 代码同上, 省略...  
        }  
    };  
    
        // 下面是调用:  
    
        CxString string1(24);     // 这样是OK的  
        CxString string2 = 10;    // 这样是不行的, 因为explicit关键字取消了隐式转换  
        CxString string5 = "bbb"; // 这样也是OK的, 调用的是CxString(const char *p)  
        CxString string6 = 'c';   // 这样是不行的, 其实调用的是CxString(int size), 且size等于'c'的ascii码, 但explicit关键字取消了隐式转换  
        string1 = 2;              // 这样也是不行的, 因为取消了隐式转换  
        string3 = string1;        // 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符"="的重载  
    ```
12. extern的用法
    - extern
        用于**分离式编译时共享变量**。修饰符 extern ⽤在变量或者函数的声明前，⽤来说明 “此变量/函数是在别处定义的，要在此处**引⽤** 
        ```
        //a.h
        extern int x;//声明
        //a.cpp
        #include a.h
        int x = 1;//定义
        //b.cpp
        #include a.h
        cout << x << endl;
    - extern"C"
        正确的在C++代码中调用C语言的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；
        extern "C" {

        }

#### 1.5 一些函数
1. 说一说函数调用的执行过程
    函数调用**一般采用栈来实现**
   - 首先将函数调用语句的下一条语句的地址压入栈中
   - 再将函数的参数**从右往左**依次压入栈中
   - 执行函数体，将函数体内的变量压栈
   - 最后将栈内的变量依次取出释放，return返回从栈中取出刚开始调用函数时压入的地址，跳转到函数的下一条语句
   - 注意当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递
2. 为什么函数压栈参数是从右向左⼊栈？
    原因在于采⽤这种顺序，是为了让程序员在使⽤C/C++的“可变参数”这个特性时更⽅便。如果是从左向右压栈，第⼀个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第⼀步就需要解析可变参数，因此，将它放在栈底是很不⽅便的。
3. 函数的**可变参数列表**
   - c语言中print,printf就采用这种方法实现
   - #include <stdarg.h>中的三个宏来实现
     - va_list, va_start, va_arg, va_end
     - 缺点是输入参数数目必须和设定的一致
     - 可变参数可以不都是一个数据类型,但是数目必须一致
        ```
        /*
        charCount:字符串类型参数的数量
        intCount:整型参数的数量
        */
        void function(int count, ...) {

            va_list parameters; // 声明一个va_list变量

            va_start(parameters, count); // 初始化，count为形参的个数，所以需要提前知道形参的个数
            for (int i = 0; i < count; i++) {
                char* charParameter = va_arg(parameters, char*);  // 字符串取值
                int intParameter = va_arg(parameters, int);  // 整型取值
                cout << "字符串:" << charParameter << endl;
                cout << "整型:" << intParameter << endl;
            }
            va_end(parameters); // 清理内容

        }

        int main()
        {
            function(3, "张三", 4, "李四", 2, "王五", 1);

            return 0;
        }
        ```
   - 使用#include <initializer_list>标准库类型
     - 优点
        不需要指定list的长度，所以比方法一更加安全。在实际开发中，应该选择方案二
     - 要求
       - 元素必须具有相同的数据类型；
       - initializer_list在C++11才被引入；
       - 传递实参时，**参数需要放在｛｝（大括号）内**；
     - 例子
        ```
        void function(initializer_list<int> list) {
            for (auto ptr = list.begin(); ptr != list.end(); ptr++) {
                cout << "输出数字：" << *ptr << endl;
            }
        }

        int main()
        {
            function({3, 4, 5, 1});

            return 0;
        }
        ```
4. 你知道printf函数的实现原理是什么吗？
    int printf(const char *format,...);
    C++通过压入堆栈的方式给函数传参，参数从右往左依次压入栈中，这样最后参数就在栈底，第一个参数在栈顶。而栈是由高地址向低地址增长，所以结构上第一个参数就在低地址处，堆栈指针的上方，可以直接获取到。而printf的第一个参数就是字符指针，再通过字符串里控制参数的个数来判断参数个数及数据类型就可以计算出堆栈指针需要移动的偏移量了。
5. cout和printf有什么区别？
   - cout是ostream**对象**而printf是一个函数
   - cout<<可以自己**重载**来扩展，同时有**类型检查**更安全
6. 你知道strcpy，memcpy， sprintf的区别是什么吗？
    - 函数
        char * strcpy(char * dest,const char * src);
        void * memcpy (void * dest, const void * src, size_t n);
        int sprintf( char *buffer, const char *format [, argument,...] );
    - 实现功能不同
      - strcpy主要实现C格式字符串变量间的拷贝，
            char arr1[] = "abc";
      - sprintf主要实现其他数据类型格式到字符串的转化
            sprintf(s, "%.2f", (double)i);  
      - memcpy主要是内存块间的拷贝。
            void *memcpy(void *destin, void *source, unsigned n);
    - 操作对象不同
      strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串
    - 安全性不同
        strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
    - 执行效率不同
        memcpy最高，strcpy次之，sprintf的效率最低。
7. strcpy函数和strncpy函数的区别？哪个函数更安全？
    char* strcpy(char* strDest, const char* strSrc)
    char *strncpy(char *dest, const char *src, size_t n)
    - strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成**缓冲溢出**(buffer Overflow)的错误情况
    - strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符
8. strlen和sizeof区别？
    - sizeof是**运算符**，并不是函数，结果在编译时得到而**非运行**中获得；strlen是字符处理的库函数。
    - sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
    - 因为sizeof值在编译时确定，所以**不能用来得到动态分配（运行时分配）存储空间的大小**
9.  你知道回调函数吗？它的作用？
    - 回调函数就是一个**通过函数指针调用的函数**。把函数的指针（地址）作为参数传递给另一个函数。在这个函数内通过函数指针调用
    - 作用：相当于一个中断处理函数，由系统在符合你设定的条件时自动调用 
10. 说⼀下 fork， wait， exec 函数 
   - ⽗进程产⽣⼦进程使⽤ fork 拷⻉出来⼀个⽗进程的副本，此时只拷⻉了⽗进程的⻚表，两个进程都读同⼀块内存。当有进程写的时候使⽤写实拷⻉机制分配内存 
   - exec 函数可以加载⼀个 elf ⽂件去替换⽗进程，从此⽗进程和⼦进程就可以运⾏不同的程序了。exec 执⾏成功则⼦进程从新的程序开始运⾏，⽆返回值，执⾏失败返回 -1。
   - fork 从⽗进程返回⼦进程的 pid，从⼦进程返回 0，调⽤了 wait 的⽗进程将会发⽣阻塞，直到有⼦进程状态改变，执⾏成功返回 0，错误返回 -1。

#### 1.6 全局与局部，静态与动态，临时变量， 临时对象
1. 静态类型和动态类型，
   - 静态类型：对象在声明时采用的类型，在编译期既已确定；
   - 动态类型：通常是指一个**指针或引用**目前所指对象的类型，是在运行期决定的；A* pa = pc;  
2. 静态绑定和动态绑定（动态联编与静态联编）
   - 在 C++ 中，联编是指⼀个计算机程序的不同部分彼此关联的过程
   - 静态联编
     - 是指联编⼯作**在编译阶段**完成的，这种联编过程是在程序运⾏之前完成的，⼜称为早期联编。
     - 静态联编对函数的选择是**基于指向对象的指针或者引⽤的类型**。其优点是效率⾼，但灵活性差。
     - 比如**重载**，非虚函数，带有缺省参数值的虚函数
   - 动态联编
     - 是指联编在程序**运⾏时动态地进⾏**，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数的实现。
     - 动态联编对成员函数的选择是**基于对象的类型**，针对不同的对象类型将做出不同的编译结果。
     - 比如**虚函数**    
3. 动态链接与静态链接（动态库与静态库）
   - 库文件是二进制文件，保密源代码，并避免重复编译
   - 都是在最后一部链接阶段
   - 静态链接 .a，.lib
      - 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
      - 缺点
          - 浪费空间：多个程序用会重复加载静态库至内存浪费空间
          - 更新困难：改变库代码后就需要重新编译与链接
          - 运行速度快：库代码已经打包到可执行文件中
      - 创建
        g++ -c StaticMath.cpp
        ar -crv libstaticmath.a StaticMath.o
   - 动态链接 .so，.dll
      - 程序启动之后，动态库会被动态加载到内存中，再链接成一个完整的程序
      - 特点
          - 内存中只有一份共享库，节约空间
          - 程序运行时才载入，更新方便不需要重新编译
          - 有性能损失，链接推迟到了程序运行时
      - 创建
        不需要打包工具，使用编译器即可
        g++ -fpic -shared add.cc sub.cc   -o libmymath.so
   - 注意
     - 库非常小使用静态库，库比较大时使用动态库
     - 链接时加载的是**动态库的一些信息如名称**而不是动态库本身
     - 动态库运行时加载所以在内存中位置不确定，编译汇编时要加-fpic
     - 通过ldd命令检查动态库依赖关系
     - 如何**定位库文件**：通过设置环境变量LD_LIBRARY_PATH
     - 静态库：libxxx.a libxxx.lib, 动态库：libxxx.so,libxxx.dll
4. 静态类型检查与动态类型检查
   - 静态类型检查意味着在编译时进行类型检查.
   - 动态类型检查是在运行时验证程序的类型安全性的过程。
   - 在运行时使用类型信息时会发生动态类型检查.C++使用一种称为RTTI(运行时类型信息)的机制来实现它.使用RTTI的最常见示例是**dynamic_cast**运算符,它允许向下转换多态类型
5. C++是强类型语言吗？
   - 强类型指类型转换潜规则较少，尽量不允许未受益的类型转换
   - 弱类型指语言提高大量用作类型转换的潜规则，从而难以判断是否使用错误的类型
   - **C++是弱类型语言，静态语言，但相对C是强类型语言**。不过强弱是相对的，取决于定义的标准。C++中存在隐式转换，强制转换等操作，使得没那么强。
6. **指针和引用的动态绑定**
   - 对于非虚函数的情况
        基类指针（引用）指向派生类对象，由于是静态绑定，所以只能调用基类存在的函数
   - 对于虚函数的情况
        基类指针（引用）指向派生类对象，由于是动态绑定，所以执行的是派生类对象的虚函数而不是基类的虚函数，即可以根据对象类型的不同，执行不同的虚函数，这就是多态性！
   - **禁止重定义继承来的非虚函数**
        基类指针（引用）指向派生类对象，执行重定义后的非虚函数，由于是静态绑定，实际上执行的是基类的非虚函数而不是派生类重定义后的非虚函数。产生歧义的行为，不能使用！
7. 全局变量和局部变量有什么区别？
    - **生命周期不同**：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
    - **使用方式不同**：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。
    - **存储位置不同**：全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面   
8. 全局变量和static变量的区别
    - 作用域不同
        - 全局变量+extern声明就具有了全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件
        - 静态全局变量有文件作用域，只对当前定义该变量的源文件有效。两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量
9.  C++中将临时变量（局部变量）作为返回值
   - 不能返回指向栈内存的指针
   - 不能返回绑定栈内存的引用
   - 可以返回局部变量本身
   - 可以返回指向堆内存的指针
        比如函数内在堆申请内存，返回指向堆内存的指针。局部变量从栈中弹出被消耗，但内存还在。
11. 产生临时对象的场景
   - 以值传递的方式给函数传参
      - 会直接调用对象的拷贝构造函数，生成一个临时对象传参给函数。当临时对象销毁时候，也是函数形参销毁，也是函数执行完后，就会调用该临时对象的析构函数
      - 采用引用解决
   - 类型转换成临时对象
      - 类型转换产生临时对象, 这里没有给单参数的构造函数添加explicit，导致在**赋值**的时候，会产生隐式的类型转换导致的临时对象，再通过**默认的=赋值给P**
        ```
            Person(int a)
            { 
                m_age = a;
                cout << "有参构造函数!" << endl;
            }
            int main() {
                Person P;
                p = 1000; 
            }
        ```
     - 但是如果在初始化过程中发生的隐式转换，是不会产生临时对象的， `Person P = 1000`;
   - 以值返回的方式返回对象
     - 在函数返回对象时候，会创建一个临时对象接收这个对象;从而调用了**拷贝构造函数**，和析构函数
     - 注意由于编译器优化，如果返回临时对象时同时直接初始化另一个对象，即Person p2 = test(p);就不会调用拷贝构造函数。
     - 返回**右值引用**的方式来解决
#### 1.7 声明，定义，初始化
1. 声明和定义区别？
    - 对于变量：声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。相同变量可以在多处声明（外部变量extern），但只能在一处定义。
    - 对于函数：声明一般在头文件中，实现一般在源文件中
2. 初始化和赋值的区别
    - 对于简单类型来说，初始化和赋值没什么区别
    - 对于类和复杂数据类型来说，完全不同
       - 创建对象时初始化，
         - 直接初始化
            string str("abc");
            string str1(str2)l
         - 拷贝初始化（**拷贝构造不产生临时对象，拷贝初始化才产生！**）
            - 使用"="的为拷贝初始化，先调用构造函数产生临时对象，再调用拷贝构造函数拷贝。
            （有的编译器会优化这一步，直接调用构造函数，**不产生临时对象**，完全等价于直接初始化）
            - 注意当拷贝构造函数为private时，编译时会报错
                string str = "abc";//会直接调用构造函数，不调用拷贝构造函数，不产生临时对象
                string str1 = str2;//调用拷贝构造函数
       - 而对于赋值，是在对象创建以后，在通过赋值擦除原值。如果重载了operator=，则会调用该重载。
            A a = 1;
            a = 2;//发生了隐式转换，产生了临时对象
3. C++初始化时机
    - 静态初始化
        是指用常量对变量进行初始化。其中未赋初值及初值为0的放在bss段，其他放在data段。静态初始化在程序加载时完成。
    - 动态初始化
        是指需要经过函数调用才能完成的初始化。 对于全局或者类的静态成员变量，是在main()函数执行前由运行时调用相应的代码进行初始化的。而对于局部静态变量，是在函数执行至此初始化语句时才开始执行的初始化。
4. 类成员初始化方式？为什么用成员初始化列表会快一些？
    - 赋值初始化，通过在函数体内进行赋值初始化
    - 列表初始化，在冒号后使用初始化列表进行初始化
    - 列表初始化是给数据成员分配内存空间时就进行初始化,此时函数体还未执行。
5. 有哪些情况必须用到成员列表初始化？作用是什么？
    - 四种情况
      - 当初始化一个**引用**成员时；
      - 当初始化一个**常量**成员时；
      - 当调用一个**基类的构造函数**，而它拥有一组参数时；
      - 当调用一个**成员类的构造函数**，而它拥有一组参数时；
    - 成员初始化列表做了什么
      - 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；
      - list中的项目顺序是由类中的成员**声明顺序**决定的，不是由初始化列表的顺序决定的；

#### 1.8 显式转换，隐式转换
1. 隐式转换，如何消除隐式转换？
    - 隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为,
      - 内置数据类型
        ```
        int int_value = 8;
        double dou_value = 10.7;
        double dou_Sum = int_value + dou_value; // int_value会被自动转换为double类型，用转换的结果再与dou_value相加.
        
        int value = true; // bool类型被转换为int类型
        
        void func(double dArg); // 声明函数
        func(1); // 调用函数。整型数值1被默认转换为double类型数值1.0
        
        double add(int num1, int num2)
        {
        return (num1 + num2); // 运算结果会被隐式转换为double类型返回
        }
        ```
      - C++类对象的隐式转换：
        ```
        void fun(CTest test); 

        class CTest 
        { 
        public: 
            CTest(int m = 0); 
        } 
        fun(20);//隐式转换
        ```
    - 隐式转换容易发生一些错误
        ```
        class Test
        {
        public:
            Test(int a);
            bool isSame(Test other)
            {
                return m_val == other.m_val;
            }
        private:
            int m_val;    
        }

        Test a(10);
        if(a.isSame(10));                   // 该语句将返回true, 发生隐式转换，Test类型和10相等了！
        ```
    - 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换
        ```
        void fun(CTest test); 
        class CTest 
        { 
        public: 
            explicit CTest(int m = 0); 
        } 
        fun(20);//error 隐式转换
        fun(static_cast<CTest>(20)); //ok 显式转换
        ```
    - 也可以通过重载转换函数如operator int()的方式来完成**类向基本类型**的转换
        ```
        class A {  
        public:  
            ......  
            operator int(){return num;};  // 在需要情况下， A对象可以转成int类型对象。  
            ......  
            int num;  
        }; 
        cout<<c+12<<endl; //其中c是A类型的对象  
        ```
    - 举例：
        Person p1(100);
        Person p1 = 100; //隐式转换
        Person p2 = Person(100.00);//显式调用
2. C++的四种强制类型转换（显式类型转换）reinterpret_cast/const_cast/static_cast /dynamic_cast
    - C风格
        (type)expression
    - reinterpret_cast
        - reinterpret_cast<type-id> (expression)
        - 和C风格差不多，约束了**整型、浮点型和枚举类型**的相互转换
        - 但是还是支持指针和整型的转换。它存在转换后运行时出错的隐患。
            ```
            double b = reinterpret_cast<double>(a);				// 整型向浮点型转换
            int a1 = reinterpret_cast<int>(b);					// 浮点型向整型转换
            ```
    - const_cast
        - const_cast<type_id> (expression)
        - 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：
            常量指针被转化成非常量的指针，并且仍然指向原来的对象
            常量引用被转换成非常量的引用，并且仍然指向原来的对象
            const_cast一般用于修改底层指针。如const char *p形式
    - **static_cast**
        - static_cast < type-id > (expression)
        - 约束了**指针和整型**的相互转换。
        - 约束了**无关系类型的指针**的相互转换。（无类型指针除外）
        - 要求指针转换时的类存在继承关系（void*除外）。它也存在转换后运行时出错的隐患。
        - 用于基类和派生类之间指针或引用引用的转换
        - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
        - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于**没有动态类型检查**，所以是不安全的
    - **dynamic_cast**
      - dynamic_cast <type-id> (expression)
      - dynamic_cast只可以用于指针之间的转换
      - 要求操作的指针类型具有**多态特性**。它解决了指针转换后使用出现运行时出错的问题，但是使用该方法要付出运行时计算的代价。如果能明确转换是安全的，建议使用static_cast方法
      - 有类型检查，基类向派生类转换比较安全，可以识别出不安全的下行转化，并将转化的结果设置为空指针
      - dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换
      - 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的
      - 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全
3. 哪些转换是不安全的？
   - 类型的窄化转换，会导致数据位的丢失
   - 下行转换，父类对象的指针强制转化为子类的指针，因为下行转换会调用到子类的方法、引用子类的成员变量，这些父类都没有，所以会导致指向不存在的内存空间
4. static_cast比C语言中的转换强在哪里？
    - 更加安全,C++风格在**编译阶段**就会针对错误的转换报错，而C风格不会
    - 更直接明显可读性更好，可清楚地辨别代码中每个显式的强制转换
#### 1.9 其他
1. 说一说**一致性哈希**
    - 普通hash算法具有缺陷
        比如在服务器缓存的场景中，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，造成了缓存的雪崩，服务器压力过大而崩溃
    - 一致性哈希
      - 一致性哈希算法是对 2^32 取模。**一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个哈希环**，将各个服务器与数据使用相同的Hash算法映射到哈希环上，对于每个数据，从其位置沿环顺时针查找，遇到的第一台服务器就是其应该定位到的服务器
      - **避免雪崩**
        一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性  
      - 环的倾斜与虚拟节点
        当服务器节点分布不均即大多数缓存集中于服务器上时，也容易导致缓存雪崩。就需要采用对每一个服务节点计算多个哈希，一个物理节点对应多个虚拟节点，这样缓存就可以尽量均匀分布。具体做法可以**在服务器ip或主机名的后面增加编号来实现。**
2. 浅拷贝和深拷贝的区别
    - 浅拷贝
      - 浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。
      - 默认的拷贝构造函数为浅拷贝
    - 深拷贝
      - 深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。
      - 在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的
        ```
            A(A& a): m_ptr(new int(a.m_data)){} //拷贝构造函数,从堆中分配内存，用h.m_data初始化
        ```
3. 零拷贝的了解
   - 零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。
   - 在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。
4. 如何用代码判断大小端存储？
    0X12345678
    - 高低字节位：左边为高字节，右边为低字节
    - 大端存储：字数据的高字节存储在低地址中（符合人的阅读习惯）
    - 小端存储：字数据的低字节存储在低地址中（符合计算机处理）
    - 鉴别方式：使用强制类型转换
        ```
        #include <iostream>
        using namespace std;
        int main()
        {
            int a = 0x1234;
            //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
            char c = (char)(a);
            if (c == 0x12)
                cout << "big endian" << endl;
            else if(c == 0x34)
                cout << "little endian" << endl;
        }
        ```
5. C++的异常处理的方法
    - 对于**语法错误（编译错误）**，如变量未定义、括号不匹配、关键字拼写错误编译器可以发现。
    - 对于**运行时错误**，如数组下标越界、系统内存不足可以通过编译但运行时会报错。C++通过**try(检查)、throw(抛出)、catch(捕获)异常处理机制来处理**。执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。
    - 常见异常
      - 数组下标越界
      - 除法计算时除数为0
      - 动态分配空间时空间不足
    - try、throw和catch关键字
        ```
        double m ,n;
        cin >> m >> n;
        try {
            if( n == 0)
                throw -1; //抛出int类型异常
            else
                cout << m / n << endl;
        }
        catch(double d) {
            cout << "catch(double) " << d <<  endl;
        }
        catch(int e) {
            cout << "catch(int) " << e << endl;
        }
        cout << "finished" << endl;
        return 0;
        ```
    - 函数的异常声明列表
        int fun() throw(int,double,A,B,C){...};
    - C++**标准异常类** exception
        #include <typeinfo>
        bad_typeid:指针为空抛出异常
        ```
        	try {
                cout << typeid(*a).name() << endl; // Error condition
            }
            catch (bad_typeid){
                cout << "Object is NULL" << endl;
            }
        ```
        - bad_cast：bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果**转换是不安全**的，则会拋出此异常
        - bad_alloc：在用 new 运算符进行**动态内存分配**时，如果没有足够的内存，则会引发此异常
        - out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果**下标越**界，则会拋出此异常
6. 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？
    coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。
        ```
        g++ coredumpTest.cpp -g -o coredumpTest
        ./coredumpTest
        gdb [可执行文件名] [core文件名]
        ```
7.  你知道Debug和Release的区别是什么吗？
    - 调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。
    - 发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。
    - 本质上没有区别，只是一组编译选项的集合
8.  怎样判断两个浮点数是否相等？
    对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于**两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注**意。与浮点数的表示方式有关。
9.  说一下你理解的 ifdef endif代表着什么？
    - **条件编译**，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句
    - 多个文件同时包含一个头文件，防止重定义
10. 如何在不使用额外空间的情况下，交换两个数？
    - 算数法:浮点型会有精度损失
        x = x + y;
        y = x - y;
        x = x - y;
    - 异或法:无法交换浮点型
    　a ^= b; // a=a^b
    　b ^= a; // b=b^(a^b)=b^a^b=b^b^a=0^a=a
    　a ^= b; // a=(a^b)^a=a^b^a=a^a^b=0^b=b
    - 相除法:浮点型会有精度损失，且b != 0
        a = a * b;
        b = a / b;
        a = a / b;
11. 分别写出 bool， int， float，指针类型的变量 a 与“零”的⽐较语句。
    - bool:if ( !a ) or if(a)
    - int: if ( a == 0)
    - float: const EXPRESSION EXP = 0.000001 if ( a <= EXP && a >= -EXP)
    - pointer : if ( a != NULL) or if(a == NULL)
        ⽆论是 float 还是 double 类型的变量，都有精度限制。所以⼀定要**避免将浮点变量⽤“==”或“！ =”与数字⽐较**，应该设法转化成“>=”或“<=”形式。
12. 对象复用的了解
    对象复用其本质是一种设计模式：Flyweight享元模式。通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。 
13. perro()函数的使用
    - 定义
        ```
        #include <stdio.h>//包含perror的头文件
        void perror(const char *s); 
        perror ("open_port");
        ```
    - 用于将你输入的一些信息和errno所对应的错误一起输出
        ```
        #include <stdlib.h>
        #include <string.h>
        int main(int argc, char *argv[])
        {
            FILE *fp;
            fp=fopen("/root/myfile","r+");
            if(NULL==fp)
            {
                perror("/root/myfile");
                printf("errno=%d\n",errno);
                char * mesg = strerror(errno);
                printf("/root/myfile:%s\n",mesg);
            }
            return 0;
        }
        ```
14. switch的使用
    - 必须要有break，否则会继续指向
    ```
    int main() {
        int a = 1;
        switch (a)
        {
        case 1: a++; 
        case 2: a++; break;
        default: a++; cout << "default" << endl; 
        }
        cout << a << endl;
        return 0;
    }

    ```
15. while内自增
    - n--:先执行判断语句，再--，最后执行while中的语句
    - --n:先--，再执行判断语句，最后执行while中的语句
        ```
        //结果是4, 3, 2, 1, 0。一共循环5次
        int main() {
            int n = 5;
            while(n--) {
                cout << n << endl;        
            }
        }

        //结果是4, 3, 2, 1。一共循环4次
        int main() {
            int n = 5;
            while(--n) {
                cout << n << endl;        
            }
        }
        ```
### 2. C++面向对象
#### 2.1 面向对象
1. 介绍面向对象的三大特性，并且举例说明
    **三大特性：继承、封装和多态**
    - 继承
      - **让某种类型对象获得另一个类型对象的属性和方法**。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
      - 常见的继承：
        实现继承：指使用基类的属性和方法而无需额外编码的能力
        接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
    - 封装
        封装，也就是**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的**进行信息隐藏**，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。
    - 多态
      - **同一事物表现出不同事物的能力**，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。
      - 实现多态有二种方式：重写（override），重载（overload),**重载实现编译时多态，虚函数实现运行时多态**
2. 多态性底层的原理是什么？
   - 对于重载本质是静态绑定，而对于**重写本质是通过虚表和虚指针实现动态绑定**
   - 虚表
     - 虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表
     - 每个虚类，都有一个虚函数表；
     - 本质上是一个指针数组，其中元素为指向该类的虚成员函数的函数指针；
     - **属于类**，为该类的所有对象所共用；
     - 在**编译阶段就已经被确定**了
   - 虚指针
     - 在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针
     - 属于对象，是编译器自动添加的一个指针成员变量；
     - 虚表指针，在构造函数中初始化
   - 实现多态的过程
     - 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是指针数组，其中元素为指向该类的虚成员函数的函数指针
     - 每个对象中保存一个虚表指针vptr，指向对象所属类的虚表。构造对象的时候，基类先于派生类构造，基类构造函数初始化对象虚指针后，也会先将虚指针指向基类虚表，再在派生类构造中将虚指针指向派生类虚表
     - 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，会在自己的虚表中将此虚函数地址添加在后面
3. 如果有一个空类，它会默认添加哪些函数？
   - Empty(); // 缺省构造函数//
   - Empty( const Empty& ); // 拷贝构造函数//
   - ~Empty(); // 析构函数//
   - Empty& operator=( const Empty& ); // 赋值运算符// 
4. 类与类之间的关系
    - **继承**，is-a
        子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法
    - **依赖**（dependence）既“use-a” 关系。
        类B作为参数被类A在某个method方法中使用
    - **聚合**（aggergation） 即"has-a"关系。
        类B包含类A，整体与部分的关系，但是**可以具有各自的生命周期**。即成员对象不由整体对象初始化
    - **组合**（composition） 
        类B包含类A，但整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。
5. 组合相比继承有什么优缺点？ 
    - 继承
        - 优点：
            子类可以重写父类的方法来方便地实现对父类的扩展。
        - 缺点：
            **父类的内部细节对子类是可见的**
            高度耦合。父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。
    - 组合
        - 优点：
           ** 对象成员细节不可见**
            低耦合
        - 缺点：
            容易产生过多的对象
            使用对象要仔细定义接口 
6. public，protected和private访问和继承的区别
    - 访问
       - public的变量和函数在类的内部外部都可以访问。
       - protected的变量和函数只能在类的内部和其派生类以及友元函数中访问。
       - private修饰的元素只能在类内以及友元函数中访问 
    - 继承
       - 默认继承是私有继承：`class Derived : public Base{}`
       - 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员
       - 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
       - 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。
    - **派生类成员及其友元都不能访问基类的私有成员，派生类外部的用户只能访问公有属性的成员**
    - 派生类继承了所有的基类方法，除了
       - 基类的构造函数、析构函数和拷贝构造函数。
       - 基类的重载运算符。
       - 基类的友元函数
    - 恢复继承的成员在基类中的访问权限
        使用using 语句，这是C++标准建议使用的方式 
7. 友元函数和友元类的基本情况
    - 作用
        友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以**访问类中的私有成员和保护成员**。
    - 缺点
        友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。
    - 友元函数
        定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。需要在类的定义中声明所有可以访问它的友元函数。
    - 友元类
        友元类的所有成员函数都是另一个类的友元函数，另一个类里面也要相应的进行声明
    - 注意
        友元关系不能被继承，不能被传递，单向            
8. C++中的重载、重写（覆盖）和重定义（隐藏）的区别
    - 重载（overload）
        重载是指在**同一范围**定义中的同名成员函数才存在重载关系。
        主要特点是**函数名相同，参数类型和数目有所不同**，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关
    - 重写（覆盖）（override）
        重写指的是**在派生类中覆盖基类中的同名函数**，重写就是重写函数体，要求基类函数**必须是虚函数**且：与基类的虚函数有**相同的参数个数、参数类型、返回值类型**
    - 重定义（隐藏）（hide）
        隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数
        - **两个函数参数相同，但是基类函数不是虚函数**。和重写的区别在于基类函数是否是虚函数。
        - **两个函数参数不同，无论基类函数是不是虚函数**，都会被隐藏。和重载的区别在于两个函数不在同一个类中
    - 重载与重写的区别：
      - 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系
      - 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
      - 重写关系中，调用方法根据对象类型动态决定，重载则是静态绑定  
9. 如果想将某个类用作基类，为什么该类必须定义而非声明？
    派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么     
10. 类如何实现只能静态分配和只能动态分配
    - 类的静态建立就是直接建立，直接调用构造函数，在栈中分配内存。]
    - 方法是将操作符new、delete重载为私有的.
        ```
        class A
        {
        private:
            void* operator new(size_t t){}          //注意函数的第一个参数和返回值都是固定的
            void operator delete(void* ptr){}       //重载了new就需要重载delete
        public:
            A(){}
            ~A(){}
        };
        ```
    - 类的动态建立就是先使用operator new()，在堆空间中搜索一块内存并进行分配；第二步调用类的构造函数构造对象。这种方法是间接调用类的构造函数。
    - 方法是将类的构造函数和析构函数设为protected属性，这样类对象不能够访问，但是派生类能够访问，能够正常的继承。同时创建另外两个create和destory函数类创建对象。
        ```
        class A  
        {  
        protected:  
            A(){}  
            ~A(){}  
        public:  
            static A* create()  //create设置为静态成员函数，这样就可以通过类名来访问了，而不需要创建对象
            {  
                return new A();  
            }  
            void destory()  
            {  
                delete this;  
            }  
        };
        ```
11. 如何设计一个计算仅单个子类的对象个数
    - 为类设计一个static静态变量count作为计数器；
    - 类定义结束后初始化count;
    - 在构造函数中对count进行+1;
    - 在析构函数中对count进行-1；
12. 如何阻止一个类被实例化
    - 将类定义为抽象基类，即使用有定义的pure virtual析构函数
    - 将构造函数声明为private；    
13. 抽象基类为什么不能创建对象？
   - 定义
      - 称带有纯虚函数pure virtual的类为抽象类，方便实现多态特性
      - 有时有的类不能生成对象，如动物本身不可以生产对象，而老虎可以
   - 作用
        作为**公共基类定义接口函数**
   - 原因
        存在纯虚函数，其实现由派生类给出
14. 成员函数里memset(this,0,sizeof(*this))会发生什么
    - 有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0 
    - 以下情况不能使用
      - **类含有虚函数表**：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；
      - 类中含有C++类型的对象，由于在**构造函数体的代码执行之前就对list对象完成了初始化**，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存
15. 你知道重载运算符吗？
    - 我们只能重载已有的**运算符（又叫操作符**），而无权发明新的运算符
    - 两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数
      - 成员运算符比如+，-（左操作数是类的对象，this）
      - 非成员运算符如<<流运算符,必须使用友元函数实现（左操作数不是类的对象，没有this）
16. 当程序中有函数重载时，函数的匹配原则和顺序是什么？
    - 名字查找
    - 确定候选函数
    - 寻找最佳匹配   
17. 多继承的优缺点
   - 优点：对象可以调用多个基类中的接口
   - 缺点：派生类所继承的多个基类有相同的基类会产生二义性，需要通过显示指定或者采用虚拟继承        
18. 什么是虚拟继承
   - **虚拟继承**是多重继承中特有的概念。虚拟基类是为解决多重继承导致的**二义性问题**而出现的。在访问公共基类的对象时，会导致二义性，需要显示指定，如obj.A::get()或obj.B::get();。而在虚拟继承中，虚基类只用同一个（共享）对象表示。
   - 虚拟继承的实现是通过虚基类指针vbptr和虚基类表。该指针指向了一个虚基类表，虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。
   - 如:类C继承自类B1、B2，而类B1、B2都继 承自类A，因此在类中两次出现类A中的变量和函数。
        ```
        class A
        {
            public:
                void disp(); 
            private:
                int a;
        };
        
        class B1:virtual public A
        {
            public:
                void dispB1();
            private: 
                int b1;
        };
        class B2:virtual public A
        {
            public:
                void dispB2();
            private: 
                int b2;
        };
        
        class C:public B1,public B2
        {
            public:
                void dispC();
            private: 
                int c;
        };
        ```
#### 2.2 虚函数，虚指针
1. 哪些函数不能是虚函数？把你知道的都说一说
   - 构造函数
   - 内联函数看情况
   - 静态函数
   - 友元函数
   - 普通函数
2. 基类的虚函数表和虚函数存放在内存的什么区
   - 虚函数表是全局共享的元素，即**全局仅有一个，不占用对象存储空间，在编译时就构造完成**
   - 虚函数表存储虚函数的地址,类中虚函数的个数在编译时期可以确定，即虚函数表的大小是在编译时期确定的，所以不在堆中
   - 虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，所以**虚函数表位于C++内存模型中的全局存储区中；而虚函数则位于代码区**
3. 虚表指针vptr的初始化时间
    在**构造函数执行时**会对虚表指针进行初始化，并且存在对象内存布局的最前面。注意多继承情况下会初始化多个虚指针，指向不同的虚函数表
4. 编译器建立虚函数表的步骤
    对于派⽣类来说，编译器建⽴虚函数表的过程其实⼀共是三个步骤
   - **拷⻉**基类的虚函数表，如果是多继承，就拷⻉每个有虚函数基类的虚函数表
   - 查看派⽣类中是否有重写基类中的虚函数， 如果有，就**替换**成已经重写的虚函数地址；
   - 查看派⽣类是否有⾃身的虚函数，如果有，就**追加**⾃身的虚函数到⾃身的虚函数表中。
5. 虚函数的代价是什么？
    - 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类
    - 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；
    - 虚函数大多数情况下无法内联
6. 纯虚函数和虚函数区别
    - 作用不同
    - 在虚表中内容不同
        纯虚函数并没有具体的函数体，因此它在**虚函数表中的值就为0**，而具有函数体的虚函数则是函数的具体地址
7. 为什么一般要使用多态即基类指针调用派生类虚函数，而不直接使用派生类对象调用虚函数？
    Base *bp = new Derive();
    bp->func();
    - 体现多态性，通过这个基类指针或者引用来调用虚函数的时候，实际执行的是派生类对象的函数，**使用这个指针或者引用的一方的代码不必随着派生类的不同而改变，使程序模块具有很好的可替换性**
    - 比如基类A有三个派生类B,C,D，都有一个虚函数func(),这样在同一个函数内分别传入三个派生类的指针或者引用，通过多态性分别调用func(),而不需要写三个函数
8. 为什么**析构函数一般写成虚函数**？
    - 由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用派生类析构函数，而**派生类的析构函数又自动调用(非显示)基类的析构函数**，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，**只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏**。
    - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数
        `virtual  类型  函数名(参数列表）= 0`
    - （但存在一种特例，在CRTP模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应 该声明为虚函数，因为这种继承方式，不需要虚函数表）
9. 为什么**构造函数不能是虚函数**?
    - 虚函数对应一个虚指针，虚指针在存储在对象的内存空间的。如果构造函数是虚函数，就需要通过虚函数表中对应的虚函数指针来调用，可对象目前还没有实例化，也即是还没有内存空间，虚指针还没有创建完成
    - 虚函数的作用在于通过父类的指针或者引用来调用它的成员函数的时候，能够根据动态类型来调用子类相应的成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，所以构造函数不能是虚函数
10. 虚函数能定义为静态函数吗？
    不能。
   - static成员**不属于任何类对象**或类实例，所以即使给此函数加上virutal也是没有任何意义的
   - 静态函数**没有this指针**，无法通过this指针调用隐藏的成员虚指针vptr，也就无法调用虚函数了
12. 虚函数可否声明为内联函数
    看情况。如果虚函数在编译时就能够决定将要调用哪个函数时，就能够内联。但是如果**指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开**，当然前提依然是函数并不复杂的情况下。因为前者虚函数具有多态性，后者没有。 
13. 什么情况下调用虚函数不会有多态性
    - 在构造函数或者析构函数里面调用虚函数，不会有多态性。所以一般**不要在构造函数或者析构函数里面调用虚函数**。
        - 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；因为父类对象会在子类之前进行构造，此时**子类部分的数据成员还未初始化**，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；
        - 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以**在调用基类的析构函数时，派生类对象的数据成员已经销毁**，这个时候再调用子类的虚函数没有任何意义
    - 还有基类的默认实参和子类的默认实参，也不会有多态性。
        基类指针指向派生类对象，调用的是派生类的虚函数。但是对于**参数有缺省值的情况是静态编译的**。
        比如⼀个基类的指针指向⼀个派⽣类对象，在派⽣类的对象中针对虚函数的参数缺省值进⾏了重定义。因为缺省参数值是静态绑定的，静态绑定绑定的是静态类型相关的内容，所以会出现⼀种**派⽣类的虚函数实现⽅式结合了基类的缺省参数值**的调⽤效果
    - 通过对象调用不会有多态性
        ```
        Base *p=new Derived();
        p->fun();//假定fun是虚函数，会调用子类的fun函数实现
        Derived d;
        Base b=d;
        b.fun();//会调用基类的fun函数。
        ```
14. 如果基类函数不定义为virtual会发生什么？
    发生**重定义**。不再动态绑定而是静态绑定。如果通过派生类对象调用会调用派生类函数，如果通过指向派生类对象的基类指针调用，会调用基类函数。因为在**进⾏类型转换时，直接截取基类的部分的内存**，编译器认为类型就是基类，那么函数符号表中绑定的函数地址也就是基类中函数的地址，所以执⾏的是基类的函数

#### 2.3 构造函数，析构函数
1. C++有哪几种的构造函数
   - **默认构造函数**
      - 即无参数构造函数，未提供显式初始值时用来构建对象的构造函数。如果没有明确写出⽆参数构造函数，编译器会视情况⾃动⽣成默认的⽆参数构造函数，该函数为空，不做任何事情，只保证程序能够正常运行。
      - 自定义默认构造函数
         `A() {}`
   - **一般构造函数**
        也称重载构造函数，⼀般构造函数可以有各种参数形式
   - **拷贝构造函数**
      - 拷⻉构造函数的函数参数为对象本身的引⽤，⽤于根据⼀个已存在的对象复制出⼀个新的该类的对象。
            `Complex(const Complex &c);`
      - 如果没有显示的写拷⻉构造函数，则系统会默认创建⼀个拷⻉构造函数，但当类中有指针成员时，最好不要使⽤编译器提供的默认的拷⻉构造函数，最好⾃⼰定义并且在函数中执⾏**深拷⻉**
   - **移动构造函数**
      - 拷贝构造函数可以使用深拷贝解决浅拷贝的问题。但是如果初始化的过程中产生了临时对象并且涉及的堆内存很大，那么拷贝构造的开销就很大。
      - 移动构造函数,采用**浅拷贝加移动语义**，避免了额外的开销。即是在用原对象指针对新对象指针进行赋值后,将原对象成员指针置为空指针,使得其无法指向内存数据,从而保证在析构的时候不会产生内存泄漏。
            ```
            A a = getA();
            A(A& a): m_ptr(new int(a.m_data)){} //拷贝构造函数,从堆中分配内存，用h.m_data初始化
            A(A&& a):m_ptr(a.m_ptr){a.m_ptr = nullptr;}
            ```
   - **委托构造函数**
        用于代码复用，简化代码,允许**在同一个类**中一个构造函数可以调用另外一个构造函数
   - **转换构造函数**
      - 根据⼀个指定类型的对象创建⼀个本类的对象，也可以算是⼀般构造函数的⼀种
      - 形参是其他类型变量，且只有一个形参
            ClassA(int i) {}
2. 类的六个默认成员函数
   - 构造函数
   - 析构函数
   - 拷贝构造函数
   - 赋值运算符重载
   - 取地址符重载
   - const取地址操作符重载  
        ```        
        Date* operator&()
        {
            return this ;
        }
        const Date* operator&()const//后面那个const算重载，常量成员函数，这样就可以取常量对象的地址
        {
            return this ;
        }
        ```
3. 构造函数的执行顺序 ？
    - **虚基类**的构造函数（多个虚基类则按照继承的顺序执行构造函数）。
    - **基类**的构造函数（多个普通基类也按照继承的顺序执行构造函数）。
    - **成员对象**的构造函数（按照初始化顺序）
    - **派生类**自己的构造函数
      - （在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；）
      - 对象的vptr初始化；
      - 成员初始化列表，**必须在vptr被设定之后才做**，防止在初始化列表出现调用虚函数的情况，没有vptr的话就会访问基类的虚函数；
      - 执行程序员所提供的代码                 
4. 什么情况会自动生成默认构造函数？（默认构造函数的作用是什么？）
    - 在没有显示定义构造函数的时候，编辑器**不一定**会自动生成默认的构造函数
    - **含有类对象数据成员**，该类对象类型有默认构造函数，因为需要在构造函数的初始化列表内初始化对象成员
    - **基类带有默认构造函数**，因为需要初始化基类和虚指针
    - 虚拟继承下，因为需要初始化虚表指针
5. 那什么时候需要自动生成拷贝构造函数呢？
    - 和默认构造函数的生成场景一样
    - 如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；
    - 如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；
    - 如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；
    - 如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数
6. 什么情况下会调用拷贝构造函数
    - 拷贝初始化的时候，=：`string str1 = str2;` 
    - 值传递，函数的参数是类的对象时
    - 函数返回类的对象时
        产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象
7. 拷贝构造函数和赋值运算符重载的区别？
    - 拷贝构造函数是函数，赋值运算符是运算符重载
    - 拷贝构造函数会生成新的类对象，赋值运算符是对已存在的对象进行赋值
    - 并不是所有出现"="的地方都是使用赋值运算符
    - 类中有指针变量时要重写**析构函数、拷贝构造函数和赋值运算符**。
8.  为什么拷贝构造函数必须传引用不能传值？
    因为如果拷贝构造函数中的参数不是一个引用，当于采用了传值的方式，传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。
    **不是因为会产生临时对象！**
9.  如何禁止程序自动生成拷贝构造函数？
    - 设置为私有
    - 或者直接=delete
10. 成员初始化列表
    - 效率更高
        在构造函数内赋值，相当于想要先要调用一遍默认构造函数，再进行赋值操作。而列表初始化相当于只调用了拷贝构造函数
    - 有些情况下必须使用初始化列表来进行初始化
      - const常量成员，只能初始化不能赋值
      - 引用，必须在定义的时候就初始化，不能重新赋值
      - 没有默认构造函数的类，就需要在初始化列表中初始
11. 类什么时候会析构？
   - 对象生命周期结束，被销毁时；
   - delete指向对象的指针时，或delete指向对象的基类类型指针，而其**基类析构函数是虚函数**时；
   - 组合关系时，对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。
14. 构造函数,析构函数可否抛出异常（**会造成内存泄露**）
    - C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏
    - 如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情，也可能造成内存泄露
    - 使用**智能指针**取代指针类成员，除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源
15. 构造函数、析构函数可否声明为内联函数
   - class中的函数默认是inline型的，编译器有选择性的inline
   - 构造函数和析构函数声明为内联函数是没有意义的，因为**编译器会在构造和析构函数中添加额外的操作（**申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。
16. 解释一下什么是trivial destructor
    - “trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数如果申请了新的空间一定要显式的释放，否则会造成内存泄露
#### 2.4 模板
1. C++模板是什么，你知道底层怎么实现的？
   - 模板是c++的一种特性，允许函数或者类（对象）通过泛型（generic types）的形式表现或者运行模板可以**使得函数或类在对应不同的类型（types）的时候正常工作，而无需为每一种类型分别写一份代码**。
   - **二次编译**来实现。因为函数模板要被实例化后才能成为真正的函数，编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。
2. 模板会写吗？写一个比较大小的模板函数
    ```
        template <class T, class U>
        bool compare(T num1, U num2) {
            return a > b ? true : false;//不同类型的比较需要重载>
        }
    ```
3. 模板类和模板函数的区别是什么？
    - 函数模板允许隐式调用和显式调用而类模板只能显示调用
        cout << compare(1, 2) << endl;
        cout << compare<int, int>(1, 2) << endl;
    - 在使用时类模板必须加<T>，而函数模板不必
4. 模板函数和模板类的特例化
   - 引入原因
        编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于**某种特定类型，如果要实现其特有的功能**，单一模板就无法做到，这时就需要**模板特例化**
   - 定义
     对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值
   - 模板函数特例化
     - 对于函数模板,只支持模板的完全特例化,不支持模板的部分特例化,只有类模板支持模板的部分特例化
        ```
        //比较大小的函数模板
        template <class T, class U>
        bool compare(T a, U b) {
            return a > b ? true : false;//不同类型的比较需要重载>
        }
        //模板特例化
        template <>
        bool compare(int, int) {
            cout << "模板特例化" << endl;
            return true;
        }
        ```
   - 类模板特例化（特化）
      - 我们可以对模板进行特例化，也可以对类进行部分特例化
      - 不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参
        ```
        //部分特例化（偏特化）
        template<class T, class U> 
        class ClassA {
            T a;
            U b;
        };
        template<class T> 
        class ClassA<T, int> {
            
        };

        ```
   - 本质
       - 特例化的本质是**实例化一个模板，而非重载它**。
       - 特例化不影响参数匹配。参数匹配都以最佳匹配为原则。
       - 注意二者函数体的语句不一样了，实现不同功能
       - 模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本
5. 模板和实现可以写在不同文件内（分离式编译）吗？为什么？
    - 不能。c++程序生成的步骤是，预编译，编译，汇编，链接。在编译阶段，cpp文件是单独编译的，在链接阶段才链接为可执行文件。
    - 一般过程中编译main.cpp时，编译器只知道其包含的头文件中的函数void f()的声明。也就是外部连接，函数的具体实现在另一个.o文件中。需要连接器在.h头文件对应的cpp文件中寻找函数f的具体实现。这样main.o中才能够找到函数二进制代码的实际的地址再调用。
    - 而在模板声明和实现分开的情况下，由于模板只有用到时才会实例化，所以连接器找不到对应模板的二进制代码的具体地址，会报连接错误




### 3. C++内存管理
#### 3.1 内存分布
1. 简要说明C++的内存分区
   - 由低地址到高地址分别为代码区，常量区，全局（静态）数据区，堆区，未使用内存，栈区
       - **栈**：由编译器管理分配和回收，存放局部变量和函数参数。
            运行时分配，局部变量，局部const
       - **堆**：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。
       - **全局和静态存储区**：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。
            编译时分配，全局static，局部static，全局const
       - **常量区**：存储常量，⼀般不允许修改。
            字符串常量
       - **代码区**：存放程序的⼆进制代码
   - 注意
     - C++存储不区分全局变量和静态变量，C会分别存储
     - 自由存储区与堆并不等价，通过new来申请的内存区域可称为自由存储区，自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
2. 类的对象存储空间？
   - **非静态成员**的数据类型大小之和。
   - 编译器加入的**额外成员变量**（如虚指针，虚基指针）。
   - **内存对齐**额外需要的空间。
   - 当该类是某类的派生类，那么派生类继承的**基类部分的数据成员**也会存在在派生类中的空间中，也会对派生类进行扩展
3. C++中类的数据成员和成员函数内存分布情况
   - 一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。
   - 静态成员函数与一般成员函数的唯一区别就是没有this指针，因此不能访问非静态数据成员。**所有函数都存放在代码区，静态函数也不例外**。所以有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。
4. 空类的大小是多少吗？
   - C++空类的大小不为0，不同编译器设置不一样，vs设置为1；原因是C++中要求对于**类的每个实例都必须有独一无二的地址**,那么编译器自动为空类分配**一个字节大小**来区分不同的实例。
   - 对于空白类作为基类时，该类的大小为0
   - **带有虚函数的C++类大小不为1**，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
5. allocator类
   - 即**STL空间按配置器**，本质上是一个内存池
   - 在STL中默认如果要分配的内存大于128个字节的话就是大块内存，调用一级空间配置器直接向系统申请，如果小于等于128个字节的话则认为是小内存，则就去内存池中申请。
   - 采用哈系统加自由链表来实现（原理见下文）
   - STL中用于vector，string的动态扩展
   - 为什么要有allocator?
     - new和delete内存分配和释放与对象的构造与析构组合在了一起，具有局限性。
     - allocator底层使用了哈希桶加自由链表实现的内存池来分配内存内存池，优点：...
6. 什么是**内存池**，如何实现
    - new、malloc 等申请内存的缺点（怎么实现看操作系统面经）：
       由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片进而降低性能。
    - 内存池（Memory Pool）
        - 是一种改进后的动态内存分配方式。内存池则是在真正使用内存之前，先申请分配一定数量的的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。
        - 优点是尽量避免了内存碎片，使得内存分配效率得到提升
        - 并且由于设计在应用层面上，避免了频繁申请内存导致的系统调用的开销
    - 内存池实现机制
        - allocate 包装 malloc，deallocate包装free。通过哈希桶加自由链表实现的内存池来分配内存
        - 维护16条链表，8~128字节，以8字节递增。将传入所需要的内存大小，映射到对应链表。如果对应自由链表不为空，则从中取出内存块。
        - 链表为空则查看内存池是否为空，如果内存池不为空，查看剩余空间是否够20个节点大小，如果足够则将1个分配给用户，其余挂到相应的自由链表下。
        - 如果不够20个大小，查看是否至少有1个，将其分配给用户，其余挂到相应的自由链表下。
        - 如果一个都没有，则二级空间配置器会使用malloc()从heap上申请内存，申请40块，一半拿来用，一半放内存池中。
        - 如果malloc()失败则从其他内存块较大的链表上取出一个来使用。
        - 如果这都没有，就调用一级适配器，让系统的内存不足机制来处理
7. 堆和栈的区别
   - **申请方式不同**
      - 堆：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问题
      - 栈：由编译器进⾏管理，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等
   - **空间大小不同**
      - 堆是不连续的内存区域，受限于计算机系统中有效的虚拟内存（32位 4G）
      - 栈是一块连续的内存区域，大小固定，过ulimit -a查看，由ulimit -s修改
   - **管理机制不同（底层原理）**
      - 堆由链表管理，当在堆中申请空间时，操作系统首先从空闲链表中找到第一个空间大于“申请空间”的节点，将其分配。多余的部分，系统自动放回空闲链表。在这块内存空间首地址处记录分配的大小，如此，之后的delete()才能正确释放内存空间。
      - 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出
   - **碎片问题**
      - 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低
      - 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。
   - **生长方向不同**
      - 堆向上，向高地址方向增长。	
      - 栈向下，向低地址方向增长。
      - 堆从低向高扩展，方便内存管理。栈从高向低是为了**最大程度利用地址空间**，否则必须指定栈堆的分界线，会导致分配不均。同时高向低也确定了栈空间的起始位置，避免了动态扩展栈空间时需要移动整个栈的数据
   - **分配效率不同**
        - 堆由C/C++函数库提供在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。
        - 而计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。
        - 另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的,所以堆的效率比栈低很多
8. 程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？
   - 参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char类型输入的，依次存在字符串数组argv[]内，数组的中元素的个数为 argc 个，第一个参数为程序的名称.
   - char *a = "123";是字符串,而char *a[] = {"123", "456"};是字符串数组
9. 什么是内存泄露，如何检测与避免
    - 内存泄漏是指堆内存的泄漏，使用malloc,、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则就会造成内存谢咯
    - 后果
      - 短进程的偶发内存泄漏危害不大
      - 周期性的内存泄漏会导致程序在长期运行后的某个时间点崩溃,尤其是守护进程
      - 大量内存泄漏会导致操作系统无内存可用
    - 原因
      - new的对象没有delete
      - 基类指针指向派生类对象,派生类中申请了动态内存,但是没有将析构函数定义为虚函数,使用delete只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏
      - new了数组,只调用了delete而不是delete[],导致只释放了数组的第一个对象
    - 避免内存泄露的几种方式
        - 有new就有delete，有malloc就有free，保证它们一定成对出现
        - 一定要将基类的析构函数声明为虚函数
        - 采用RAII思想,比如智能指针
        - 对象数组的释放一定要用delete []
        - 采用日志计数法定位,统计分配和释放的次数
        - 利用检测工具：Linux下可以使用Valgrind工具
#### 3.2 this指针
1. 关于this指针你知道什么？全说出来
   - 概念
     当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。
   - 特点
     - this指针是类的指针，指向对象的首地址。
     - this指针是常量指针,不能改变其指向的对象
     - this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
     - this指针本质上其实是**一个成员函数的形参**，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以**对象中不存储this指针。**
     - this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的
   - 用处
      - 访问类对象成员 
      - **返回对象本身return *this;**
      - 区分相同变量名，如this->n = n
2. this指针是什么时候创建的？
    - this在成员函数的开始执行前构造，在成员的执行结束后清除。
    - 在栈里分配内存，这时候this指针的值就是这块内存的地址。
    - 采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。
3. this指针存放在何处？堆、栈、全局存储区，还是其他？
    this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。
4. this指针是如何传递类中的函数的？
   this指针本质上其实是**一个成员函数的形参**，是对象调用成员函数时，将对象地址作为实参传递给this 形参。所以对象中不存储this指针。
5. this指针调用成员变量时，堆栈会发生什么变化？
    当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。    
6. 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？
    **this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。
7. 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？
    普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数(比如通过直接对象来调用而非父类指针)。
8. 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？
    - 在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容也不包含this指针,类的成员函数单独放在代码段中,而this指针本质上是成员函数的形参。
    - 当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他**任何函数调用，只要不涉及到this指针的内容，都能够正常运行**。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。
9. 为什么是不可预期的问题？
    delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限错误。**可能是缓冲或者其他什么原因**，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的。
10. 如果在类的析构函数中调用delete this，会发生什么？
    会导致堆栈溢出。原因很简单，delete的本质是“**为将被释放的内存调用一个或多个析构函数，然后，释放内存”**。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃

#### 3.3 new, delete, malloc, free
1. new和delete是如何实现的？
   - new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针
   - delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存
2. malloc与free的实现原理？（**虚拟内存如何从堆中动态分配和释放内存**）
    - malloc 
      - **采用brk/mmap+内存池实现**
      - 从操作系统层面上看，malloc主要是通过两个系统调用来实现的： **brk和mmap**。
        - malloc小于128k内存时，采用brk分配内存。brk是将进程数据段(.data)的最高地址指针向高处移动，扩大堆空间，但这时只完成了虚拟内存的分配，但是没有分配物理页，当进程第一次读写这块虚拟内存，触发缺页中断，才真正分配物理页
        - malloc大于128k内存时，采用mmap分配内存。mmap是堆和栈的中间分配一块内存。因为 brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。
      - 但是如果每次申请内存都要调用brk和mmap系统调用，都会产生系统调用开销和内存碎片。因为堆从低地址到高地址分配，如果高地址的内存没有释放那么低地址的内存就不能被回收。
      - 所以malloc采用内存池的方式类似于STL分配器，先申请一大块内存，再将这些内存分割为内存块，连接在空闲链表上。调用malloc()函数时，它沿着连接表寻找一个大到可以满足用户请求要求的连续的内存块，然后将内存块一分为二，一用户申请的那块传递给用户，将另一块返回到空闲链表上。　 
    - free
      - 调用free函数时，被free回收的内存会首先被链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回，也就是说实际free的内存并没有还给内核内存空间还在用户空间中。这样就避免了频繁的系统调用。同时也会尝试对小块内存进行合并，避免过多的内存碎片。再将用户释放的内存块连接到空闲链上。
3. new / delete 与 malloc / free的异同
   - 相同点
        都可用于内存的动态申请和释放
   - 不同点
     - 前者是C++运算符，后者是C/C++语言标准库函数
     - new自动计算要分配的空间大小，malloc需要显式指定
     - new是**类型安全的**，malloc不是。因为malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。例如：
        int *p = new float[2]; //编译错误
        int *p = (int*)malloc(2 * sizeof(double));//编译无错误
     - new内存分配失败时，会抛出**bac_alloc异常**。malloc分配内存失败时返回NULL
     - new调用名为operator new的标准库函数分配足够空间**并调用相关对象的构造函数**，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者不具有调用构造函数和析构函数功能。
     - new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象
4. delete和delete[]区别？
   - delete只会调用一次析构函数。
   - delete[]会调用数组中每个元素的析构函数  
5. 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？
    动态创建对象时，malloc/free可以申请内存和回收内存，但无法执行构造函数和析构函数。会导致内存泄露。
6. C++中有几种类型的new
    - plain new
        普通的new，就是我们常用的new
        int *p = new int(5);
        int *p = new int[5];
    - nothrow new
        char *p = new(nothrow) char[10];
        nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL
    - placement new
        - 在用户指定的内存位置上构建新的对象，这个构建过程不需要额外分配内存，只需要调用对象的构造函数即可。
        - placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），不能对构造的对象使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。
            ```
            Foo foo;
            char *buff = new char[sizeof(foo) * 5];
            memset(buff, 0, sizeof(foo) * 5);
            Foo *p = new(buff) Foo;
            p->~Foo();
            delete []buff;
            ```
        - placement new的好处：
          - 在已分配好的内存上进行对象的构建，构建速度快。
          - 已分配好的内存可以反复利用，有效的避免内存碎片问题。
7. malloc、calloc、realloc、allocator的区别
    - malloc就是一般的分配内存方式，需要传入申请的空间的大小
        int *p = malloc(20*sizeof(int));
    - calloc，省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；
        int *p = calloc(20, sizeof(int));
    - realloc：给动态分配的空间分配额外的空间，用于扩充容量
        void realloc(void *p, size_t new_size);
    - allocator
      - 即**STL空间按配置器**，本质上是一个内存池
      - new和delete内存分配和释放与对象的构造与析构组合在了一起，具有局限性。
      - allocator底层使用了哈希桶加自由链表实现的内存池来分配内存内存池，优点：...
8. 被free回收的内存是立即返还给操作系统吗？
    不是,调用free函数时，被free回收的内存会首先被链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回，也就是说实际free的内存并没有还给内核内存空间还在用户空间中。这样就避免了频繁的系统调用。同时也会尝试对小块内存进行合并，避免过多的内存碎片。再将用户释放的内存块连接到空闲链上。


### 4. C++11新特性
1. C++ 11有哪些新特性？
   - 语法上：空指针nullptr、Lambda 表达式、范围for循环、统一的初始化方式、类型推导(auto, decltype)、静态assertion
   - 和类相关：初始化列表、default和delete、final和override、委托构造、继承构造
   - 性能提升：**右值引⽤**、**移动语义**、**完美转发**
   - 标准库更新：**智能指针**
2. 空指针nullptr
   - 用于替代NULL，区分空指针和0
   - C中，NULL被定义为(void*)0,而在C++中，指针必须有明确的类型定义，所以不允许直接将(void*)隐式转换到其他类型。
   - 所以在C++中NULL定义为0，无法与整数0区分。而C++中允许有函数重载，比如对于两个同名函数，参数分别为int和char *，如果传入NULL值，由于**C++不允许指针的隐式转换**，会调用int的重载，违反直观
        void func(int);
        void func(char *);//C++不允许隐式指针的隐式转换
   - nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，**能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型。**
   - 为什么不允许指针的隐式转换？
        不安全的，上行转换是安全的但是下行转换是不安全的
3. lambda函数（匿名函数）
   - 利用lambda表达式可以编写内嵌的匿名函数，用来替换独立函数
   - lambda函数是通过**仿函数对象**实现的。每当你定义一个lambda表达式后，编译器会自动生成一个匿名的仿函数即闭包类型。运行时返回闭包实例，而lambda函数捕捉列表，其实就是仿函数中带参数的构造函数，通过构造函数来初始化成员变量。
   - [capture] （parameters） mutable ->return-type {statement};
     - []不捕获任何变量
     - [&]按引用捕获外部作用域中所有变量，并作为引用在函数体中使用
     - [=]按值捕获外部作用域中所有变量，并作为副本在函数体中使用。
     - [=,&foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。
     - [bar]按值捕获bar变量，同时不捕获其他变量。
     - [this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。
        ```
        int a=0 , b=1;
        auto f1 = [] { return a; };                         //error,没有捕获外部变量    
        auto f2 = [&] { return a++ };                      //OK
        auto f3 = [=] { return a; };                        //OK
        auto f4 = [=] {return a++; };                       //error,a是以复制方式捕获的，无法修改
        auto f5 = [a] { return a+b; };                      //error,没有捕获变量b
        auto f6 = [a, &b] { return a + (b++); };                //OK
        auto f7 = [=, &b] { return a + (b++); };                //OK
        ```
   - 使用时应当注意
     - 如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为mutable。原因是仿函数重载的operator()默认是const的，一个const成员函数是无法修改成员变量的值的。而mutable的作用，就在于取消operator()的const。
     - 在多种捕获方式中，最好不要使用[=]和[&]默认捕获所有变量。因为引用捕获不会延长引用的变量的生命周期，不能捕捉临时变量的引用
   - lambda函数的功能
     - 常用于内嵌，对变量进行状态监控，使得代码可读性更好
     - 可以⽤于函数的参数，通过这种⽅式可以实现回调函数，比如在STL算法中传递比较函数
        ```
        int value = 3;
        vector<int> v {1, 3, 5, 2, 6, 10};
        int count = std::count_if(v.beigin(), v.end(), [value](int x) { return x > value; });
        //count_if统计满足条件的值
        ```
4. 基于范围的for循环
    ```
    int arr[5];
    std::vector<int> v;
    for(int x: arr);
    for(const int &x: arr);
    for(int x: v);
    for(auto &x: v)
    ```
5. 统⼀的初始化语法
    C++11给出了统⼀的初始化语法：均可使⽤“{}-初始化变量列表
    ```
    X x1 = X{1,2};
    X x2 = {1,2}; // 此处的'='可有可⽆
    X x3{1,2};
    X* p = new X{1,2};
    struct D : X {
    D(int x, int y) :X{x,y} { /* … */ };
    };
    ```
6. 初始化列表
   - 效率更高
        在构造函数内赋值，相当于想要先要调用一遍默认构造函数，再进行赋值操作。而列表初始化相当于只调用了拷贝构造函数
   - 有些情况下必须使用初始化列表来进行初始化
     - const常量成员，只能初始化不能赋值
     - 引用，必须在定义的时候就初始化，不能重新赋值
     - 没有默认构造函数的类，就需要在初始化列表中初始 
7. default与delete与0
    - default
      - 显式要求使用默认构造函数，即使已经定义了有参构造函数
      - 仅用于类的特殊成员函数，且该特殊成员函数没有默认参数
    - delete
      - 禁止默认构造函数
      - 禁止拷贝函数:` A(const A&) = delete;  `
      - 禁止隐式转换:`void func(double a) = delete;`
      - 在模板特例化中，可以用delete来过滤一些特定的形参类型
    - 0
      将虚函数定义为纯虚函数 
8. final与override
    - override：指定子类的虚函数**必须是重写的父类的**，如果父类没有对应的虚函数，编译器会报错。因为接口中只会写入声明，避免忘记了具体的实现。
    - final：当**不希望某个类被继承**，或**不希望某个虚函数被重写**，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错
    ```
    子类中：void foo() override;
    禁止类被继承：class B final{};
    禁止虚函数被重写： virtual void func() final;
    ```
9. 类型推导(auto, decltype)
   - auto
     - auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 **auto 定义的变量必须有初始值**。
     - 规则
        - 和具体类型混合使用，相当于半个类型
            ```
            int  x = 0;
            auto *p1 = &x;   //p1 为 int *，auto 推导为 int
            auto  p2 = &x;   //p2 为 int*，auto 推导为 int*
            auto &r1  = x;   //r1 为 int&，auto 推导为 int
            auto r2 = r1;    //r2 为  int，auto 推导为 int
            ```
        - 和const使用
            ```
            int  x = 0;
            const  auto n = x;  //n 为 const int ，auto 被推导为 int
            auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
            const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
            auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
            ```
        - 当=右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。    
        - 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；
        - 当类型为引用时，auto 的推导结果将保留表达式的 const 属性。
     - 限制(由于auto使用时必须初始化)
       - 不能再函数的参数中使用
       - 不能用于类的非静态成员变量
       - 不能用于模板参数`A<auto> c2= c1;`
     - 常见场景
       - 迭代器：`for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr);`
       - `auto i = 5;             // i 被推导为 int`
   - decltype 
      - 解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似：decltype(表达式)。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。
      - 规则
        - decltype一般保留const，引用&
        - 可以用于推导非静态成员的类型
        - 一般情况decltype类型和exp类型一致
        - 如果exp是函数调用，decltype和其返回值一致
        - 如果exp是一个左值，那么类型为引用
            ```
            int n = 0, m = 0;
            decltype(n + m) c = 0;  //n+m 得到一个右值，符合推导规则一，所以推导结果为 int
            decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&
            ```
      - 例 
        ```
        auto x = 1;
        auto y = 2;
        decltype(x+y) z;
        ```    
10. 静态assertion
    - C++ 提供了两种⽅式来 assert ：⼀种是 assert 宏，另⼀种是预处理指令 #error 。 前者在运⾏期起作⽤，⽽后者是预处理期起作⽤。它们对模板都不好使，因为模板是编译期的概念。
    - assert
        <assert.h>
        void assert(int expression);
        停用：#define NDEBUG
        ```
        assert(n==1);
        ```
    - #error
        ```
        #ifdef Win32
        #error:This programme cannot compile at Windows Platform
        #endif
        ```
    - static_assert
        ```
        template< class T >
        struct Check {
            static_assert(sizeof(int) <= sizeof(T), "T is not big enough!" ) ;
        } ;
        ```        
11. 委托构造函数
    用于代码复用，简化代码,允许**在同一个类**中一个构造函数可以调用另外一个构造函数
    ```
    class myBase {
        int number; 
        string name;
        myBase( int i, string& s ) : number(i), name(s){}
        public:
        myBase() : myBase( 0, "invalid" ){}
        myBase(int i) : myBase( i, "guest" ){}
        myBase(string& s) : myBase( 1, s ){ PostInit(); }
    }
    ```
12. 继承构造
    - 构造函数与基类的其他成员不同，不能被派生类继承，因此为了初始化基类中的成员变量，需要在派生类中调用基类的构造函数(即显式调用)，如果派送类没有调用则默认调用基类的无参构造函数(即隐式调用
    - 在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明
        ```
        struct A {
            A(int i) {}
            A(double d,int i){}
            A(float f,int i,const char* c){}
            //...等等系列的构造函数版本
        }；
        struct B:A {
            B(int i):A(i){}
            B(double d,int i):A(d,i){}
            B(folat f,int i,const char* c):A(f,i,e){}
            //......等等好多个和基类构造函数对应的构造函数
        }；
        ```
    - 假若基类拥有为数众多的不同版本的构造函数,就要写很多个，C++11定义了更简洁的写法
        ```
        struct A{
            A(int i) {}
            A(double d,int i){}
            A(float f,int i,const char* c){}
            //...等等系列的构造函数版本
        }；
        struct B:A{
        using A::A;
        //关于基类各构造函数的继承一句话搞定
        //......
        }；
        ```
    - 注意如果派生类又定义了相同的构造函数，则会直接电压派生类的构造函数而不是基类的构造函数
13. 右值引用
   - 左值与右值
      - 左值
        - 表达式左边的值，是表达式结束后依然存在的对象
        - 可以获取地址
        - 可以用来初始化左值引用
      - 右值
        - 纯右值：非引用返回的函数返回的临时变量值；一些运算表达式，如1+2产生的临时变量，a++；不跟对象关联的字面量值，如2，'c'，true，"hello"。不能够被取地址。
        - 将亡值：C++11新增的和右值引用相关的表达式，这样的表达式通常是将要移动的对象、T&&函数返回值、std::move()函数的返回值等
   - 左值引用与右值引用
      - 左值引用
        - C++11之前的引用被称为左值引用
            `int &b = a;`
      - 右值引用
        - C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置
        - 右值虽然无法获取地址，但是**右值引用是可以获取地址**的，该地址表示临时对象的存储位置
        - 生命周期与右值引用类型变量的生命周期一样长，只要**该变量**还活着，该右值临时量将会一直存活下去
        - 绑定右值的右值引用，其变量本身是个左值，即具名右值引用，编译器会认为是个左值
            `int &&b = 1;\\b本身为左值`
      - 规则
        - 左值引用，使用T&，只能绑定左值
        - 右值引用，使用T&&，只能绑定右值
        - 常量左值，使用const T&,既可以绑定左值，又可以绑定右值，但是不能对其进行修改,其生命周期被延续
        - T&& t在发生**自动类型推断**的时候，它是未定的引用类型。用左值初始化就是左值，用右值初始化就是右值
14. 移动语义
    - 作用
       - 用于性能优化，将内存的所有权从一个对象转移到另外一个对象，避免深拷贝带来的重新分配内存以及拷贝数据的开销
       - 移动语义通过移动构造函数与移动赋值操作符来实现
       - 想要深拷贝的就T(const T&)实现;想要移动拷贝的就实现T(T&&)。两者都实现时，一旦传入是个右值，就优先触发移动拷贝构造调用，使用移动语意，转移资源，减少拷贝
    - 移动构造函数
      - 移动构造函数的参数是一个右值引用，对参数进行移动而不是拷贝
      - 参数的符号必须为右值引用符号，即为&&
      - 参数不可以是常量，因为函数内需要修改参数的值
      - 参数的成员转移后需要修改（如改为nullptr），避免临时对象的析构函数将资源释放掉
        ```
        A(A &&a){
            pdata = a.pdata;
            a.pdata = nullptr;
        }
        ```
    - 移动赋值运算符
        ```
        A &operator=(A &&a) {
            if(this != &a) { //避免 a = move(a);
                delete []pdata;
                pdata = a.pdata;
                a.pdata = nullptr;
            }
            return *this;
        }
        ```
    - 注意
      - 如果一个类定义了自己的拷贝构造函数,拷贝赋值运算符，编译器就不会生成默认的移动构造函数或者移动赋值运算符
      - 如果类中没有提供移动构造函数和移动赋值运算符，且编译器不生成默认的，通过move()调用的移动构造或者移动赋值的行为将被转换为调用拷贝构造或者赋值运算符。**也就是说调用move()不一定会使用移动语义**
15. move()类型转换函数
    - 作用
      - move()本身并没有移动任何东西，它只进行类型转换，真正进行资源转移的是程序员实现的移动操作
      - 如果传递的是左值，则推导为左值引用，然后由static_cast转换为右值引用
      - 如果传递的是右值，则推导为右值引用，然后static_cast转换为右值引用
    - 注意
      - 使用move之后
        - 原对象不再被使用，如果对其使用会造成不可预知的后果
        - 所有权转移，资源的所有权被转移给新的对象
      - 对int等基础类型进行move()操作，不会改变其原值，因为没有定义移动构造和移动赋值
      - move构造或者赋值函数中，需要将原对象恢复默认值
      - 不要在函数中使用move()进行返回，回合编译器的优化相矛盾
    - 实现原理
      - 主要采用**引用折叠T &&和static_cast强制类型转换**来实现
      - 函数参数T&&是**万能引用**，通过引用折叠，此参数可以**与任何类型的实参匹配**。只有发生类型推导的时候，T&&才表示万能引用 ；否则，表示右值引用。
      - 即**万能引用即引用折叠发生的场景只存在模板中**，模板中的&&不代表右值引用，而是万能引用，其既能接收左值又能接收右值。而对于**普通函数形参int &&就只代表右值**。
      - 原型
        ```
        //注意是T被替换为传入参数的类型
        //typedef typename visitor::type type;用于声明，那么typename remove_reference<T>::type本身就相当于一个类型，即T类型去除所有引用后的类型
        template <typename T> 
        typename remove_reference<T>::type&& move(T&& t) {
            return static_cast<typename remove_reference<T>::type&&>(t);
        }
        ```
      - X& &、X&& &、X& &&都折叠成X&，用于处理左值。
        ```
        string s("abc");
        std::move(s) => std::move(string& &&) => 折叠后 std::move(string& )
        move被实例化为：
        string &&move(string &t) {
            return static_cast<string &&>(t);
        }
        ```
      - X&& &&折叠成X&&，用于处理右值
        ```
        move(string(s));
        string &&move(string &&t) {
            return static_cast<string &&>(t);
        }
        ```
    - 隐式移动
        只有当一个非常量的可移动对象被传递、返回或赋值，并且即将被自动销毁时，才会发生隐式移动
    - 应用场景
      - vector<>
        标准库中很多容器都支持移动语义，以std::vector<>为例，vector::push_back()定义了两个重载版本，一个将const T&用于左值参数，另一个将T&&类型的参数用于右值参数。
        ```
        v.push_back(obj); // 此处调用push_back(T&)
        v.push_back(move(obj)); // 此处调用push_back(T&&)
        ```
      - 优化swap函数
        如果T是可移动的，那么整个操作将非常高效。如果它是**不可移动的，也就是没有定义移动构造和移动赋值**，那么它和普通的swap函数一样，调用拷贝和赋值操作，不会出错，且是安全可靠的。
        ```
        //优化前
        template<class T>
        void swap(T &a, T &b) {
            T temp = a; // 调用拷贝构造函数
            a = b; // 调用operator=
            b = temp; // 调用operator=
        }
        //优化后
        template<class T>
        void swap(T &a, T &b) {
            T temp = move(a);
            a = move(b);
            b = move(temp);
        }
        ```
      - 智能指针unique_ptr<>
16. forward()完美转发
    - 作用
        函数模板可以将自己的参数“完美”地转发给内部调用的其它函数，保证被转发参数的左、右值属性不变
    - 实现原理
      - **引用折叠T &&和static_cast强制类型转换实现**。
      - 注意和move()的写法相区分，move的参数是T&& t，只返回右值，所以不用重载
      - 而forward()参数是typename remove_reference<T>::type &t，要根据左右值的不同，返回不同的值，所以要重载 
        ```
        template <class T>
        T&& forward(typename remove_reference<T>::type &t) {
            return static_cast<T&&>(t);
        }

        template <class T>
        T&& forward(typename remove_reference<T>::type &&t)  {
            return static_cast<T&&>(t);
        }

        传入左值string &，相当于T变为string &，T&&就折叠为 T&，而typename remove_reference<T>::type转换为string，同理string &&相当于重载了两个
        左值和右值的输入
        ```
    - 举例
        对于普通传参，会丢失右值引用的属性，即使调用pass(1),输出的也为左值，即失去了右值引用的属性
        ```
        void reference(int &v){
            printf("左值\n");
        }

        void reference(int &&v){
            printf("右值\n");
        }

        template <typename T>
        void pass(T &&v){
            reference(v);//普通传参，无论左右值都表现为左值
            reference(move(v));//转换为右值
            reference(forward(v));//根据v的类型传入左右值
            reference(static_cast<T&&>(v));//效果和forward(v)相同
        }
        ```
17. 智能指针
   - 原理
        智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，当类对象声明周期结束时，自动调用析构函数释放资源，从而防止堆内存泄漏。
   - 源代码（见cpp文件）
   - auto_ptr
     - 利用RALL思想实现资源管理
     - 特点
       - 有拷贝和赋值语义，拷贝或赋值后源对象无效，**对原对象操作会导致不可预料的行为，所以废弃**(类似于移动赋值)
       - 不能共享所有权，会传递所有权
       - 不能用在STL标准容器中，STL容器中的元素经常要支持拷贝、赋值操作
     - 举例
            auto_ptr<int> a1(new int(1));
            auto_ptr<int> a2(a1);//支持拷贝
   - shared_ptr
       - 允许共享所有权，使用引用计数的方式实现多个shared_ptr对象之间共享资源
       - 特点
         - 对象被销毁也就是调用析构函数时，计数减1，如果计数为0，说明自己是最后一个使用该资源的对象，必须释放该资源
         - 存在**循环引用的问题**：比如动态分配（new）的对象A内如果存在指向对象B的智能指针，而B内也存在指向A的智能指针。由于计数本身也是申请在堆内存上的，会导致哪怕程序结束后，A,B的引用计数都为1，不会调用A和B的析构函数，造成了内存泄露
         - **存在多线程安全问题**，智能指针中引用计数++、–需要加锁，也就是说引用计数的操作需要是线程安全的
   - weak_ptr
       - 弱引用，为了解决shared_ptr中的循环引用的问题。
       - 特点
         - 只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，weak_ptr对象指向shared_ptr对象时，不会增加shared_ptr中的引用计数。当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。
         - 所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针
   - unique_ptr
       - 独享所有权，不能拷贝，但可以通过move移动将权限转移
       - 注意unique_ptr支持移动构造与移动赋值
            std::move()能够将一个unique_ptr赋给另一个。这样转移所有权后 还是有可能出现原有指针调用就崩溃的情况。但是这个语法能强调你是在转移所有权，让你清晰的知道自己在做什么，从而不乱调用原有指针
       - 特点
         - 禁止拷贝和赋值
         - 不能用在STL标准容器中
         - unique_ptr做为STL容器的元素时，不能直接进行传递，因为不可以进行拷贝和赋值操作
            ```
            vector<unique_ptr<int>> a;
            a.push_back(new int(20));    //错误
            a.emplace_back(new int(20)); //错误
            a.emplace_back(make_unique<int>(20)); //错误
            ```
         - 但可以通过move()转换为右值实现 
            ```
            unique_ptr<int> a(new int(20));
            vector<unique_ptr<int>> b;
            b.push_back(move(a));    //正确
            ```
       - 举例
            unique_ptr<int> a1(new int(1));
            unique_ptr<int> a2(a1);          //失败! 不允许拷贝
   - 注意
     - 不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的
     - 初始化：
        auto_ptr<int> a1(new int(1));
        auto_ptr<int> a2(a1);
18. 说说你了解的auto_ptr
   - auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏
   - auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；
   - 由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针
   - Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组
   - 可以通过*和->运算符对auto_ptr所有用的指针进行提领操作；
   - T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。
19. 手写实现智能指针类需要实现哪些函数？
    构造函数、拷贝构造函数、重载赋值运算符、析构函数、移动构造函数、移动赋值函数
20. RAII思想
    - RAII全称是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。
    - 而智能指针即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。


### 5. C++STL标准模板库
#### 5.1 综合问题
0. 注意考虑不同的容器区别时，应针对
   - 逻辑结构（功能）
   - 底层物理存储结构
   - 查询和删除效率
   - 迭代器区别与失效情况
1. C++中**标准库**是什么？
   - **标准函数库**
     - 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。
     - 输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数
   - **面向对象类库**
     - 这个库是类及其相关函数的集合。
     - 标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库
2. 什么是**STL标准模板库**？
   - C++ STL从广义来讲包括了三类：**算法，容器和迭代器**。
   - 算法
        是用来操作容器中的数据的模板函数。包括排序sort()，查找find()，反转reverse()等常用算法
   - 容器
        一种数据结构，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。
   - 迭代器
       提供了访问容器中对象的方法,能够在不暴露容器内部结构的情况下对容器的遍历。从实现的⻆度来看，迭代器是⼀种将 operator*,operator->,operator++, operator--等指针相关操作赋予重载的**类模板**。
   - 仿函数
        从实现的⻆度看，仿函数是⼀种重载了 operator()的类或者类模板。 可以帮助算法实现不同的策略。
   - 配置器
        负责对象的创建与销毁，内存的获取与释放
   - 配接器
        ⼀种⽤来修饰容器或者仿函数或迭代器接⼝的东⻄，用于特化和扩展对象
3. STL的特点(好处)
   - 数据结构和算法的分离
        使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组；
   - 不是面向对象的
        STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征
   - STL是C++的一部分，因此你不用额外安装什么，它被内建在你的编译器之内
   - 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了，我们可以把精力放在程序开发的别的方面
4. traits技法
   - traits即特性萃取技术，本质上是一个struct，利用模板的特例化来提取“被传进的对象”对应的返回类型。这样就可以用于将容器数据的类型从容器的迭代器中提取出来，传递给算法，从而调用合适的算法。
   - 实现
    ```
    template<class T>
    struct traits {
        typedef typename T::value_type value_type;
    };

    template<class T>
    struct traits<T *> {
        typedef T value_type;
    };
    //测试
    void fun(int a) {
        cout << "fun(int) is called" << endl;
    }
    void fun(double a) {
        cout << "fun(double) is called" << endl;
    }
    void fun(char a) {
        cout << "fun(char) is called" << endl;
    }
    traits<vector<int>::iterator>::value_type a;
    fun(a);
    traits<vector<double>::iterator>::value_type b;
    fun(b);
    traits<char*>::value_type c;
    fun(c);
    ```
#### 5.2 迭代器
1. 迭代器如何实现
    提供了访问容器中对象的方法,能够在不暴露容器内部结构的情况下对容器的遍历，因此迭代器内部**必须保存一个与容器相关联的指针**，然后重载各种运算操作来遍历，其中最重要的是*运算符与->运算符，以及++、--等可能需要重载的运算符重载
2. 迭代器的类型
    - 输入迭代器input_iterator
        只读，且只能一次读操作，支持操作：++p,p++,!=,==,=*p,p->；（即放在=右边）
    - 输出迭代器
        只写，且只能一次写操作，支持操作：++p,p++；（即放在=左边）
    - 正向迭代器forward_iterator
      - 可多次读写，支持输入输出迭代器的所有操作；
      - unordered_(multi)set/map、forward_list
    - 双向迭代器bidirectional_iterator
      - 支持正向迭代器的所有操作，且支持操作：--p,--p；
      - list、(multi)set/map
    - 随机访问迭代器random_access_iterator
      - 除了支持双向迭代器操作外，还支持：p[n],p+n,n+p,p-n,p+=n,p-=n,p1-p2,p1<p2,p1>p2,p1>=p2,p1<=p2；
      - 在常量时间内访问容器任意位置
      - vector、deque
    - 没有迭代器
        stack、queue、priority_queue
3. 迭代器：++it、it++哪个好，为什么
   - 前置返回一个引用，后置返回一个对象
        ```
        // ++i实现代码为：
        int& operator++(){
            *this += 1;
            return *this;
        }
        ```
   - 前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低
        ```
        //i++实现代码为：                 
        int operator++(int){//有参数仅仅是为了区分前置与后置，实际中没有被使用
            int temp = *this;                   
            ++*this;                       
            return temp;                  
        }
        ``` 
4. 为什么有了指针为何还要迭代器（迭代器和指针的区别）
    迭代器不是指针，是类模板，通过重载指针的一些操作符来表现的像指针。迭代器本质是封装了原⽣指针，但可以根据不同类型的数据结构来实现不同的++， --等操作。
5. STL中迭代器失效的情况有哪些？
    - vector
      - 原因是vector是顺序存储结构而list是链式存储结构
      - 尾后插入
            size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，**所有迭代器均失效**（需要重新分配空间）。
      - 中间插入
            size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。
      - 尾后删除
            只有尾迭代失效。
      - 中间删除
          - 删除位置之后所有迭代失效
          - 后边每个元素都会往前移动⼀个位置，但erase 会返回下⼀个有效的迭代器
                ```
                for (iter = container.begin(); iter != container.end(); ) {
                    if (*iter > 3)
                    iter = container.erase(iter);//erase的返回值是被删除元素的下一个元素的迭代器
                    else{
                        iter++;
                    }
                }
                ```
    - deque 
      - 和 vector 的情况类似
    - list
      - 双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效
      - erase返回下一个有效迭代器cont.erase(iter++);
    - map/set等
      - 关联容器底层是红黑树删除节点会使得树产生调整，但是是**单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系**。所以仅仅会使当前的iterator失效,不会影响其他节点的迭代器。
      - 使用递增方法获取下一个迭代器 erase(iter++);
            ```
            for (iter = cont.begin(); it != cont.end();) {
            (*iter)->doSomething();
            if (shouldDelete(*iter))
                cont.erase(iter++);
            else
                ++iter;
            }
            ```
    - unordered_(hash) 
        迭代器意义不大, rehash之后, 迭代器应该也是全部失效
#### 5.3 配置器与配接器
1. STL的两级空间配置器
   - 原因
        频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片。内存分配器在找不到合适内存情况下需要合并空闲块，降低效率
   - 方式
        当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。大于128字节则调用一级空间配置器
   - 一级配置器
     - 实际以malloc()，free()，realloc()等C函数执行实际的内存配置。
     - 流程：直接allocate分配内存，其实就是malloc来分配内存，成功直接返回，失败产生异常。用户有自定义异常处理的化就调用处理函数
   - 二级配置器
        - allocate 包装 malloc，deallocate包装free。通过哈希桶加自由链表实现的内存池来分配内存
        - 维护16条链表，8~128字节，以8字节递增。将传入所需要的内存大小，映射到对应链表。如果对应自由链表不为空，则从中取出内存块。
        - 链表为空则查看内存池是否为空，如果内存池不为空，查看剩余空间是否够20个节点大小，如果足够则将1个分配给用户，其余挂到相应的自由链表下。
        - 如果不够20个大小，查看是否至少有1个，将其分配给用户，其余挂到相应的自由链表下。
        - 如果一个都没有，则二级空间配置器会使用malloc()从heap上申请内存，申请40块，一半拿来用，一半放内存池中。
        - 如果malloc()失败则从其他内存块较大的链表上取出一个来使用。
        - 如果这都没有，就调用一级适配器，让系统的内存不足机制来处理
   - 缺点：
        - 内部碎片：因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节
        - 占用内存空间：内存池申请的所有内存只有在进程结束才会释放内存，还给操作系统。导致其他进程无法使用内存
2. STL中的allocator、deallocator
    - 主要用在二级配置器上，大于128bytes调用一级配置器，否则调用二级配置器，具体过程见上
    - 空间配置函数allocate()
    - 空间释放函数deallocate()
3. 如何在共享内存上使用STL标准库？
    使用map映射的方式。进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后将其他容器的名称和地址一并保存到map容器内。进程B只需要获取了该map容器后，就可以通过名称的映射获得其他容器
4. 配接器(adaoter)
   - ⼀种⽤来修饰容器或者仿函数或迭代器接⼝的东⻄，用于特化和扩展对象,本质上是一种设计模式
   - 容器
        queue和stack为容器配置器，修饰了deque的接口
   - 迭代器
        reverse iterators可以将一般迭代器的行进方向逆转
#### 5.3 算法
1. 回答⼀下 STL ⾥ resize 和 reserve 的区别
    - resize()
      - **改变当前容器内含有元素的数量size()**
      - eg: vector v; v.resize(len);v的size变为len,如果原来v的size⼩于len，那么容器新增len-size个元素，元素的值为默认为0.
    - reserve()
      - **改变当前容器的最⼤容量capacity**,它不会⽣成元素，只是确定这个容器允许放⼊多少对象
      - 如果reserve(len)的值⼤于当前的capacity()，那么会重新分配⼀块能存len个对象的空间，然后把之前v.size()个对象通过拷贝构造函数复制过来，并销毁之前的内存；
    
#### 5.2 vector，list，deque, queue
1. 序列式容器
    - 特点
      - 需要高效的随即存取，而不在乎插入和删除的效率，使用vector
      - 需要大量的插入和删除，而不关心随即存取，则应使用list
      - 需要随即存取，而且关心两端数据的插入和删除，则应使用deque。
      - **deque更适合空间的动态扩展和释放** 
    - vector 
      - 支持快速随机访问
      - 动态分配的数组，当数组空间内存不足时，都会执行: 分配新空间-复制元素-释放原空间)
      - 当删除元素时，不会释放限制的空间，所以向量容器的容量(capacity)大于向量容器的大小(size);
      - 对于删除或插入操作，执行效率不高，越靠后插入或删除执行效率越高
    - deque
      - 双端队列(double-ended queue)
      - 支持首尾（中间不能）快速增删，也支持随机访问
      - 具有分段数组、索引数组, 分段数组是存储数据的，索引数组是存储每段数组的首地址;
      - 若向两端插入元素，如果两端的分段数组未满，既可插入;如果两端的分段数组已满，则创建新的分段数组，并把分段数组的首地址存储到deque容器中即可
    - list
      - 双向链表
      - 支持快速增删
    - stack 
      - 底层一般用list或deque实现，封闭头部即可
      - 不用vector的原因应该是容量大小有限制，扩容耗时
      - 适配器，是对容器的再封装
    - queue 
      - 底层一般用list或deque实现，封闭头部即可
      - 适配器，是对容器的再封装
    - priority_queue
      - 底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
2. 关联式容器
    - 特点
      - 关联式容器都是有序的，升序排列，自动排序;
      - 实现的是一个平衡二叉树，每个元素都有一个父节点和两个子节点，左子树的所有元素都比自己小，右子树的所有元素都比自己大;
    - set
      - 底层数据结构为红黑树，有序，不重复
      - 主要用途是为了快速检索,去重与排序
      - 不允许修改set值，因为会严重破坏红黑树结构
    - multiset 
      - 底层数据结构为红黑树，有序，可重复
    - map
      - 底层数据结构为红黑树，有序，不重复
      - 不允许修改map键值，因为会严重破坏红黑树结构
    - multimap
      - 底层数据结构为红黑树，有序，可重复
      - map为单重映射、multimap为多重映射，即一个键值可以对应多个值。
    - unordered_set
      - 底层数据结构为hash表，无序，不重复
    - unordered_multiset
      - 底层数据结构为hash表，无序，可重复
    - unordered_map
      - 底层数据结构为hash表，无序，不重复
    - unordered_multimap
      - 底层数据结构为hash表，无序，可重复
3. 容器的内存分布
   - 堆栈分离存储
     - 对象（如容器）本身的存储位置和其数据的存储位置往往不是在一起的，比如堆栈存储分离的模式
     - 在栈区定义容器变量，变量本身存储在栈区，但是变量存储的数据在堆区；
     - 在堆空间定义的容器变量，变量本身存储在堆区，存储的数据也在堆区
   - vector、set和map容器其数据都是动态存储在堆空间的内存；
4. vector的实现（和array的区别）
    - array占用的是**静态空间**，不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放
    - vector则使用**动态空间配置**，在空间不足时，可以自动扩展空间容纳新元素，需要经历**重新配置空间，移动数据，释放原空间**等操作。而动态扩容的规则是以原大小的两倍配置另外一块较大的空间
5. STL中的deque的实现
    - deque则是一种双向开口的连续线性空间，由一段段定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，所以**deque没有容量的概念**。
    - deque具有分段数组、索引数组,其中索引数组的每个元素都存放了一个指针，指向另一段较大的连续空间即分段数组，这里就是实际存放数据的区域
    - deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，**因此除非必要，否则一般使用vector而非deque**。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque 
6. STL中slist（forward_list）的实现 
    slist为单向链表和list双向链表区别在于前者的迭代器是单向的前向迭代器，只支持在头部插入数据push_front()。元素插入到slist后，存储的次序和输入的次序是相反的。1<-2<-3<-4<-5
7. STL中list的实现
    - list是双向链表，即链式存储结构，插入或删除都只作用于一个元素空间，对任何位置元素的插入和删除都是常数时间。
    - list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作
    - list提供的迭代器类型是双向迭代器。此外list也是一个**环形链表**，因此只要一个指针便能完整表现整个链表。
8. STL中stack的实现
    - stack是一种先进后出的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，不提供迭代器。
    - stack是容器适配器，由双向开口的deque和list形成，只需要根据stack的性质对应移除某些接口即可实现
        `stack<int, deque<int>>`\\默认用deque,不用vector是因为vector扩容麻烦
        `stack<int, list<int>>`
9.  STL中queue的实现
    - queue是一种先进先出的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素,不提供迭代器。
    - queue容器适配器，由双向开口的deque和list形成，只需要根据stack的性质对应移除某些接口即可实现
10. STL中的priority_queue的实现
    - priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面
    - priority_queue是容器配置器，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。
11. vector如何扩容？为什么是1.5或者是2倍？
   - 新增元素
     vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要**分配**一块更大的内存，将原来的数据**复制**过来，**释放**之前的内存，在插入新增的元素；
   - 原因
      采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。
11. vector频繁调用push_back()的影响
    - 频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响 
12. emplace_back()和push_back()的区别
    emplace_back()，性能比push_back()好，包括在内存优化⽅⾯和运⾏效率⽅⾯。内存优化主要体现在使⽤了就地构造（直接在容器内构造对象，不⽤拷⻉⼀个复制品再使⽤） +强制类型转换的⽅法来实现，在运⾏效率⽅⾯，由于省去了拷⻉构造过程，因此也有⼀定的提升
13. vector删除的方式
   - pop_back()删除最后一个元素.
   - 成员函数erase()可以删除由一个iterator指出的元素，也可以删除一个指定范围的元素。
   - 通用算法remove()来删除vector容器中的元素
   - 不同之处
      - remove不会改变容器的大小size()，将**待删除元素之后的元素**移动到vector的前端而不是真的删除，返回未被删除的元素的下一位的迭代器。而pop_back()与erase()等成员函数会改变容器的大小。
      - 一般组合使用，如vec.erase(remove(vec.begin(), vec.end(), 10), vec.end());
14. Vector如何**释放空间**?
    - vector的**内存占用空间只增不减**，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在**vector析构**时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。
    - 如果需要**空间动态缩小**，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。
        vector(Vec).swap(Vec); //将Vec的内存清除；  
        vector().swap(Vec); //清空Vec的内存；
15. vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？
    - 通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。
    - map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某人值插入这个map。
    - erase()函数，只能删除内容，改变size(),不能改变容量大小capcity;**如果要想在删除内容的同时释放内存，应当选择deque容器**
16. vector与list的区别？
   - 内存分配方式不同
        vector内存空间是连续的，list内存空间是不连续的。vector一次性分配好内存，不够时才进行2倍扩容；listlist内存空间是不连续的。
   - 随机访问效率不同
        vector:O(1), list:O(n)
   - 插入和删除效率不同
        vector：O(n), list:O(1)
   - 迭代器失效场景不一样
        vector在插入和删除时可能会导致迭代器失效；list在删除的时候会导致当前迭代器指向的结点失效
17. vector与deque的区别
   - 内存分配方式不同
        vector内存空间是连续的，而deque是动态地以分段连续空间组合而成，段与段之间不一定连续。
   - 应用场景不同 
        vector适用于元素的快速随机访问，而**deque更适合空间的动态扩展和释放**。
   - 插入和删除效率不同 
        deque对于头端元素的插入和删除效率是O(1)，而vector是O(n)
18. deque与list的区别
   - 内存分配方式不同
   - 随机访问效率不同
   - 插入和删除效率不同
   - 迭代器失效场景不一样


#### 5.2 set，map
1. STL中哈希表的实现？(STL中hash table扩容发生什么？)
   - STL中的哈希表使用**vector容器和链表**来实现，同时使用**开链法**解决hash冲突问题
   - hash table表内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器是具有动态扩容能力的vector容器。
   - 而每一个节点都对应一个自由链表。如果插入哈希表的元素个数超过了桶的容量，就要进行重建哈希表操作，即找出下一个质数，创建新的vector，重新计算元素在新哈希表的位置。
2. 哈希表中解决冲突有哪些方法？
   - 线性探测
     - 使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位
     - 优点：节省空间
     - 缺点：需要处理溢出，容易产生堆聚现象（存入哈希表的记录在表中连成一片），会更容易导致冲突
   - 开链
     - 每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中
     - 优点：处理冲突简单，无堆聚，即非同义词决不会发生冲突；各链表上的 结点空间是动态申请的 ，故它更适合于造表前无法确定表长的情况；
     - 缺点：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间
   - 再散列
        发生冲突时使用另一种hash函数再计算一个地址，直到不冲突
3. STL中set的实现
    - set属于关联式容器。所有元素都会根据元素的值自动被排序（默认升序）,不允许有两个相同的键值,不允许迭代器修改元素的值，其迭代器是一种**常量迭代器**
    - 底层采用红黑树实现
4. STL中map的实现
    - map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key。一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value。
    - 标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map
5.  map插入方式有哪几种？
    - 用insert函数插入pair数据，
        mapStudent.insert(pair<int, string>(1, "student_one")); 
    - 用insert函数插入value_type数据
        mapStudent.insert(map<int, string>::value_type (1, "student_one"));
    - 在insert函数中使用make_pair()函数
        mapStudent.insert(make_pair(1, "student_one")); 
    - 用数组方式插入数据
        mapStudent[1] = "student_one";
6. 为什么set不允许修改元素的值，map不允许修改key?
    因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么⾸先需要删除该键，然后调节平衡，再插⼊修改后的键值，调节平衡，如此⼀来，严重破坏了map和set的底层的红黑树结构，导致iterator失效
7. map中[]与find的区别？
   - map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。
   - map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器
8.  红黑树是怎么能够同时实现set和map？ 为什么使用红黑树？
    - 在这里我们定义了一个**模版参数**，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value
    - 因为map和set要求是**自动排序**的，红黑树能够实现这一功能，而且**插入删除等操作都在O(logn)**时间内完成，因此可以完成高效的插入删除
9.  set和map的区别
    - map是键值对，set是值的集合
    - set用于数组去重，map用于数据的映射
10. map/multimap,set/multiset的区别
    - 主要区别在于是否允许重复元素 
    - 底层的实现区别：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样
11. unordered_map和map的区别和应用场景
   - 功能不同，底层机制不同，查询和维护时间不同，空间占用不同
   - map支持键值的自动排序，底层机制是红黑树，红黑树的**查询和维护时间复杂度**均为$O(logn)$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息
   - unordered_map底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是**建立hash表耗时较大**
   - 从两者的底层机制和特点可以看出：**map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景**

#### 5.3 string
1. string的实现（string和char*的区别）
   - string是C++的一个类，类内部封装了char*。数据类型为string，字符串结尾没有\0字符。而char*是C语言中的字符串，用char数组实现，类型为const char *,字符串结尾以\0结尾
   - string是动态字符数组，可以进行**动态扩展**，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^然后将原字符串拷贝过去，并加上新增的内容。
2. string和char*的转换
   - string s(char*);
   - char *p = string.c_str();
    ```
    char *cstr = "abc";
    string str(cstr);
    cout << "str = " << str << endl;
    const char *cstr_ = str.c_str();
    cout << "cstr_ = " << cstr_ <<endl;
    ```

### 补充
#### C++基础
1. atexit函数
   - 当进程正常退出时，将调用使用atexit注册过的函数
   - 注册过的函数的执行顺序就像压栈一样，先进后出，也就是最先注册的最后执行，最后注册的最先执行
   - 必须是进程正常退出时才会调用atexit注册过的函数，例如进程调用_exit或_Exit退出时就不会调用atexit注册过的函数
2. __attribute__详解
   - attribute是一个编译属性，用于向编译器描述特殊的标识、错误检查或高级优化
   - attribute可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)
   - 例__attribute__ ((attribute-list))
     - format
            使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配
     - constructor与destructor
            constructor属性可以指定函数在main函数执行之前进行调用，与之对应destructor可以指定某个函数在main函数执行结束之后再执行
     - objc_subclassing_restricted
            指明当前类型不能有子类，相当于final关键字
3. 头文件中全局变量，extern，const，static
   - extern 全局变量
      A.h:extern int a;声明
      A.cpp: int a = 1;定义
      B.cpp: include "A.h"包含
      否则直接在头文件定义a，在多处include该头文件，会导致重复定义而无法编译
   - const 常量
      定义在头文件中，在多处include该头文件，对于const全局变量，C++会默认认为其为内部连接，不会导致重复定义
   - static 静态变量
      定义在源文件.cpp中
      如果定义在头文件.h中，不会出现重定义错误，因为在每个编译单元都对它开辟了额外的空间进行存储。每个值互相不影响。
      

#### C++标准库
1. 万用头文件
     #include<bits/stdc++.h>
2. 一般数组
   - 定义
        int arr[10];
        int arr[10] = {1, 2, 3, 4, 5};剩下的默认用0填充
        int arr[] = {1, 2, 3, 4, 5};
   - 注意
     - **统计整个数组的长度**：sizeof(arr) / sizeof(arr[0])
     - 获取数组首地址：arr 或 &arr[0]
   - 二维数组
        int arr[2][3] = { {1,2,3}, {4,5,6} };
3. 字符串数组
   - 定义
        char c[3];
        char c[3] = {'a','b','c'};剩下的默认用'\0'填充
        char c[] = {'a','b','c'};
        char c[] = {"abc"};
        char c[] = "abc";注意数组长度为4，编译器默认最后加'0'
   - 获取字符串长度 strlen(c);结果为3
   - 如果sizeof(c)结果为4，因为包括一个'\0'，4个字符 * 1个字节，大小为4字节
4. vector
   - 简介
       #include <vector>
       可变数组，内存空间连续，支持随机访问，不支持在任意位置O(1)插入。 
       在中间进行插入和删除会造成内存块的拷贝，另外，当插入较多的元素后，预留内存空间可能不够，需要重新申请一块足够大的内存并把原来的数据拷贝到新的内存空间。
   - 定义
        vector<int>num;
        vector<int> v(n);//定义一个长度为n的数组，动态定义
        **vector<int> v(n, 0);**
        vector<int> a{1, 2, 3, 4, 5};
        vector<int> b(a);//拷贝初始化, 两个数组中的类型必须相同
        vector<int>num[5];//定义可变长二维数组
        //注意：行是不可变的（只有5行），而列可变可以在指定行添加元素
        //第一维固定长度为5，第二维长度可以改变
        vector<vectot<int>>num;//定义一个行和列均可变的二维数组
        **vector<vector<int>> a(n + 1, vector<int>(m + 1, 0));**
   - 方法
        **c.front()	返回第一个数据**
        **c.pop_back()	删除最后一个数据 O(1)**
        **c.push_back(element)	在尾部加一个数据 O(1)**
        **c.size()	返回实际数据个数（unsigned类型） O(1)**
        c.clear()	清除元素个数 O(N),N为元素个数
        c.resize(n) 改变数组大小为n,如果没有默认赋值为0
        c.resize(n,v)	改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0
        **c.insert(it,x)	向任意迭代器it之前插入一个元素x，并返回表示新插入元素位置的迭代器 O(N)**
        例：c.insert(c.begin()+2,-1)	将-1插入c[2]的位置
        c.erase(first,last)	删除[first,last)的所有元素
        **c.erase(pos)删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器。该容器的大小（size）会减 1**
        **c.begin()	返回首元素的迭代器（通俗来说就是地址）**
        c.end()	返回最后一个元素后一个位置的迭代器（地址）
        c.empty()	判断是否为空，为空返回真，反之返回假
   - 访问
     - 下标访问
        v[i]
     - 迭代器访问
        vector<int>::iterator it;
        for(it = v.begin(); it != v.end(); it++) {
            cout << *it << ' ';
        }
     - 智能指针访问
        for(const auto &a : v) {
            cout << a << ' ';
        }
     - **通过迭代器删除元素会导致迭代器失效，那么如何通过迭代器删除特定元素？**
           ``` 
            while( itor != vec.end() )
            {
                  if( *itor == 300 )
                  {
                        itor = vec.erase(itor);//重新获取迭代器，之前的itor指向状态不确定
                  }
                  else
                  {
                        itor++;
                  }
            }
           ```
5. list
   - 简介
       #include <list>
       双向链表
       list<T> lt;
       list<T> lt(n);
       list<T> lt(n, val);
   - 方法
       begin()和end()
       push_back() 和push_front()
       empty()
       resize()
       clear()
       front()和back()
       pop_back和pop_front()
       insert()
       erase()
6. stack
   - 简介
        #include<stack>
        栈，先进后出，后进先出
        栈底，栈顶
   - 方法
        push()	压栈，增加元素 O(1)
        pop()	移除栈顶元素 O(1)
        top()	取得栈顶元素（但不删除）O(1)
        empty()	检测栈内是否为空，空为真 O(1)
        size()	返回stack内元素的个数 O(1)
   - 访问
      - 栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中
      - **可以通过一个数组对栈进行模拟，一个存放下标的变量top模拟指向栈顶的指针**
        ```
            vector<int> a(100);
            int top = 0;
            for(int i = 0; i < 5; i++) {
                a[top++] = i;
            }
            int k = 5;
            while(k--) {
                cout << a[--top];
            }
        ```
7. queue
   - 简介
        #include<queue>
        队列，先进先出，后进后出
        只能尾进，头出
   - 方法
        front()	返回队首元素 O(1)
        back()	返回队尾元素 O(1)
        push()	尾部添加一个元素副本 进队O(1)
        pop()	删除第一个元素 出队 O(1)
        size()	返回队列中元素个数，返回值类型unsigned int O(1)
        empty()	判断是否为空，队列为空，返回true O(1)
8. deque
   - 简介
          #include<deque>
          双端队列，首尾都可以插入和删除
   - 方法
          push_back(x)/push_front(x)	把x压入后/前端
          back()/front()	访问(不删除)后/前端元素
          pop_back() pop_front()	删除后/前端元素
          erase(iterator it)	删除双端队列中的某一个元素
          erase(iterator first,iterator last)	删除双端队列中[first,last）中的元素
          empty()	判断deque是否空
          size()	返回deque的元素数量
          clear()	清空deque
   - 排序
          deque可以排序
          sort(d.begin(),d.end())
          //从大到小排序
          sort(q.begin(), q.end(), greater());
9.  priority_queue
   - 简介
          #include <queue>
          priority_queue<int> pq;
   - 方法
          top()	访问队首元素
          push()	入队
          pop()	堆顶（队首）元素出队
          size()	队列元素个数
          empty()	是否为空
   - 设置优先级
     - **priority_queue<int, vector<int>, less<int> >pq;//最后两个>之间要有空格**
     - 第二个参数
          vector< int > 是用来承载底层数据结构堆的容器，若优先队列中存放的是double型数据，就要填vector< double >
     - 第三个参数
          大顶堆：less< int > 表示数字大的优先级大，堆顶为最大的数字
          小顶堆：greater< int >表示数字小的优先级大，堆顶为最小的数字
     - 自定义排序
          大顶堆: < 小于号
          小顶堆: > 大于号
          ```
          struct cmp1
          {
               bool operator()(int x,int y)
               {
                    return x>y;//小的优先级高 ,从小到大排 
               }
          }; 
          struct cmp2
          {
               bool operator()(const int x,const int y)
               {
                    return a[x]>a[y];
               }
          }; 
          priority_queue<int,vector<int>,cmp1>pq1;
          priority_queue<int,vector<int>,cmp2>pq2;
          ```
     - **sort的排序规则和优先队列的排序规则是相反的**
11. map
   - 简介
          #include <map>
          映射,键值对，key-value
          **有序且不重复，map会按照键的顺序从小到大自动排序**
   - 定义
          map<string, string> mp;
          map<string, int> mp;
   - 方法
          **mp.find(key)	返回键为key的映射的迭代器 O(logN) 注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()**
          **mp.count(kry)返回的是被查找元素的个数。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值只能是1或0。**
          **mp.erase(it)	删除迭代器对应的键和值O(1)**
          **mp.erase(key)	根据映射的键删除键和值 O(logN)**
          mp.erase(first,last)	删除左闭右开区间迭代器对应的键和值 O(last-first)
          mp.size()	返回映射的对数 O(1)
          mp.clear()	清空map中的所有元素 O(N)
          **mp.insert()	插入元素，插入时要构造键值对**
          mp.empty()	如果map为空，返回true，否则返回false
          mp.begin()	返回指向map第一个元素的迭代器（地址）
          mp.end()	返回指向map尾部的迭代器（最后一个元素的下一个地址）
          **mp.lower_bound()	返回一个迭代器，指向键 >= key的第一个元素**
          **mp.upper_bound()	返回一个迭代器，指向键 > key的第一个元素**
   - 注意
     - 赋值方式
          mp["学习"] = "看书";
          **mp.insert(pair<string,string>("fruit","水果"));**
          **mp.insert({"hahaha","wawawa"});**
     - 访问
          下标访问：mp["菜哇菜"] = "强哇强";
          迭代器访问：map<string,string>::iterator it;
                    for(it = mp.begin(); it != mp.end(); it++) {
                         cout << it->first;
                         cout << it->second;
                    }
          智能指针访问：for(auto i : mp)
          指定元素访问:map<char,int>::iterator it = mp.find('a');
                    **cout << it -> first << " " <<  it->second << "\n";**
11. mutimap, unordered_map
12. set
    - 简介
          #include<set>
          set<int> se;
          **有序且不重复，由小到大排序**
    - 方法
          s.begin()	返回set容器的第一个元素的地址（迭代器）
          s.end()	返回set容器的最后一个元素的地址（迭代器）
          **s.rbegin()	返回逆序迭代器，指向容器元素最后一个位置**
          **s.rend()	返回逆序迭代器，指向容器第一个元素前面的位置**
          s.clear()	删除set容器中的所有的元素,返回unsigned int类型O(N)
          s.empty()	判断set容器是否为空
          s.insert()	插入一个元素
          s.size()	返回当前set容器中的元素个数O(1)
          **erase(iterator)	删除定位器iterator指向的值**
          erase(first,second）	删除定位器first和second之间的值
          **erase(key_value)	删除键值key_value的值**
          查找	
          **s.find(元素)	查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器**
          **s.lower_bound(k)	返回大于等于k的第一个元素的迭代器**
          **s.upper_bound(k)	返回大于k的第一个元素的迭代器**
    - 访问
        - 迭代器访问
        - 智能指针访问
        - **访问最后一个元素：**
          set<int>::iterator iter = s.end();
          iter--;
          cout<<(*iter)<<endl; 
    - **重载<运算符**
          ```
          struct cmp {
               bool operator () (const int& u, const int& v) const {
                    return u < v;
               }
          };
          set<int, cmp> se;
          ```
13. multiset:元素可以重复，且元素有序
unordered_set ：元素无序且只能出现一次
unordered_multiset ： 元素无序可以出现多次
14. pair
    - 简介
          **#include <utility>**
          pair只含有两个元素，可以看作是只有两个元素的结构体。
    - 作用
          作为map键值对进行插入
    - 定义
          pair<string,int> p("wangyaqi",1);//带初始值的
          pair<string,int> p;//不带初始值的
          p = {"wang",18};//赋值
    - 访问
          pair<int,int>p[20];
          cout << p[i].first << " " << p[i].second;    
15. string
    - 简介
          #include <string>
      字符串,其中每个字符为char类型
    - 定义
          string str1; //生成空字符串
          string str2("123456789"); //生成"1234456789"的复制品 
          string str3("12345", 0, 3);//结果为"123" ，从0位置开始，长度为3
          string str4("123456", 5); //结果为"12345" ，长度为5
          string str5(5, '2'); //结果为"22222" ,构造5个字符'2'连接而成的字符串
          string str6(str2, 2); //结果为"3456789"，截取第三个元素（2对应第三位）到最后
    - 特性
          支持比较运算符，从前往后逐一比较
          支持+运算符，代表拼接字符串
    - **string与C语言字符串（C-string）的区别**
      - string是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为string，字符串结尾没有\0字符
      - C-string，C语言中的字符串，用char数组实现，类型为const char *,字符串结尾以\0结尾
      - string转char[]
          string s = "xing ma qi";
          **char s2[] = s.c_str();**
    - 方法
          s.size()  返回string对象的字符个数
          **s.push_back()	在末尾插入一个字符**
          **iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置**
          **basic_string& insert (size_type pos, const basic_string& str);在原串下标为pos的字符前插入字符串str**
          **erase(iterator p)	删除字符串中p所指的字符**
          erase(iterator first, iterator last)	删除字符串中迭代器区间[first,last)上所有字符
          **erase(pos, n)	删除字符串中从索引位置pos开始的n个字符**
          clear()	删除字符串中所有字符, 实质是把字符串空间首字符设置为了“\0”
          **s.replace(pos,n,str)	把当前字符串从索引pos开始的n个字符替换为str**
          **s.replace(it1,it2,str)	把当前字符串[it1,it2)区间替换为str**
          **tolower(s[i])	转换为小写**
          **toupper(s[i])	转换为大写**
          **s.substr(pos,n)	截取从pos索引开始的n个字符**
          **s.find (str, pos)	在当前字符串的pos索引位置(默认为0)开始，查找子串str，返回找到的位置索引，-1表示查找不到子串**
          **s.find (c, pos)	在当前字符串的pos索引位置(默认为0)开始，查找字符c，返回找到的位置索引，-1表示查找不到字符**
    - 排序：sort(s.begin(),s.end());  //按ASCII码排序
16. bitset
    - 简介
          #include <bitset>
          类似数组，并且每一个元素只能是0或1，每个元素只用1bit空间
    - 声明
            bitset <n>a;	a有n位，每位都为0     
            string s = "100101";
            bitset<10>a3(s);//长度为10，前面用0补充
            bitset<9> bitset2(12);　//长度为9，二进制保存，前面用0补充
            bitset<10> bitset3(string("100101));　　//长度为10，前面用0补充
    - 运算
      cout << (foo^=bar) << endl;       // 1010 (foo对bar按位异或后赋值给foo)
      cout << (foo&=bar) << endl;       // 0010 (按位与后赋值给foo)
      cout << (foo|=bar) << endl;       // 0011 (按位或后赋值给foo)
      cout << (foo<<=2) << endl;        // 1100 (左移２位，低位补０，有自身赋值)
      cout << (foo>>=1) << endl;        // 0110 (右移１位，高位补０，有自身赋值)
      cout << (~bar) << endl;           // 1100 (按位取反) 
      cout << (bar>>1) << endl;         // 0001 (右移，不赋值)
      cout << (foo==bar) << endl;       // （0）false (0110==0011为false)
      cout << (foo!=bar) << endl;       // （1）true  (0110!=0011为true)
      cout << (foo&bar) << endl;        // 0010 (按位与，不赋值)
      cout << (foo|bar) << endl;        // 0111 (按位或，不赋值)
      cout << (foo^bar) << endl;		  // 0101 (按位异或，不赋值)
    - 单一元素访问和修改
      bitset<4>a1(string("1011"));
      cout<< a1[0] << endl; //1, **对应的是低地址,下标是反的**
      a1[0] = 0;
    - 各种函数
      cout<<foo.count()<<endl;//5　count函数用来求bitset中1的位数
      cout<<foo.size()<<endl;//8　size函数用来求bitset的大小
      cout<<foo.test(0)<< endl;//true　　（test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回true
      cout<<foo.test(2)<<endl;//false　　同理，foo[2]为０，返回false
      cout<<foo.any()<<endl;//true　　any函数检查bitset中是否有１
      cout<<foo.none()<<endl;//false　　none函数检查bitset中是否没有１
      cout<<foo.all()<<endl;//false　　all函数检查bitset中是全部为１
17. array
    - 简介
          #include <array>
          array是C++11新增的容器，效率与普通数据相差无几，比vector效率要高，自身添加了一些成员函数。
          和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，**只允许访问或者替换存储的元素**。
          array的使用要在std命名空间里
    - 声明
          array<int, 100> a;元素的值不确定
          array<int, 100> a{};元素的值为0
          **array<int, 100> a{1, 2, 3};**
          array<int, 100> a({1, 2, 3});
          array<int, 100> a = {1, 2, 3};
          array<int, 100> a = {1, 2, 3};
    - 访问
      - 下标访问
      - 智能指针访问
      - 迭代器访问
      - at()成员函数访问
          array<int, 4> a = {1, 2, 3, 4};
          int res = a.at(1) + a.at(2);下标为1+下标为2
    - 方法
          begin()	返回容器中第一个元素的访问迭代器（地址）
          end()	返回容器最后一个元素之后一个位置的访问迭代器（地址）
          rbegin()	返回最后一个元素的访问迭代器（地址）
          rend()	返回第一个元素之前一个位置的访问迭代器（地址）
          size()	返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数N
          empty()	判断容器是否为空
          at(n)	返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常
          front()	返回容器中第一个元素的直接引用，函数不适用于空的 array 容器。引用可以作为左值
          back()	返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。
          data()	返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能
          fill(x)	将 x 这个值赋值给容器中的每个元素,相当于初始化。
          fill(a.begin(), a.end(), x)
          array1.swap(array2)	交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型
    - 排序
          sort(a.begin(), a.end());   
18. tuple
    - 简介
          #include <tuple>
          tuple模板是pair的泛化，可以封装不同类型任意数量的对象。
          可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。
          tuple可以等价为结构体使用
    - 声明
          tuple<int, int, string> t1;
          tuple<int, int, int> t1(1, 2, 3, 4);
    - 获取值
          cout << get<0>(t1) << endl;
          int a, b, c, d;
          tie(a, b, c, d) = t1;
          cout << a << b << c << d;
19. **STL函数**
    beg为序列的初始地址，end为序列的尾地址
    - accumulate(beg,end,init)
        #include <numeric>
        O(n)
        对一个序列的元素求和, 求和不包括end,init为对序列元素求和的初始值
    - fill(beg,end,num)  
        std内
        O(n)
        对一个序列进行初始化赋值
    - is_sorted(beg,end)
        #include <algorithm>  
        O(n)
        判断序列是否有序，返回bool值   
    - lower_bound() upper_bound()
        #include <algorithm>  
        O(logN) 二分查找，注意必须是有序数组或者容器     
          lower_bound(a,a+n,x);//在a数组中查找第一个大于等于x的元素，返回该元素的地址
          c = lower_bound(a.begin(), a.end(), 3) - a.begin();//返回值为3的元素的下标
          upper_bound(a,a+n,x);//在a数组中查找第一个大于x的元素，返回该元素的地址
          //如果未找到，返回尾地址的下一个位置的地址
    - max_element() min_element()
          #include <algorithm>
          O(N), 找序列内的最大最小值
          int mx = *max_element(a,a+n);//函数都是返回地址，需要加\*取值
          int mn = *min_element(a,a+n);
    - max() min()
          O(1)， 找多个元素的最大值和最小值
          mx = max(a,b);//找a，b的最大值和最小值
          mn = min(a,b);
          **mx = max({a,b,c,d});//找到a,b,c,d的最大值和最小值**
          mn = min({a,b,c,d});
    - reverse(beg,end)
          #include <algorithm>
          O(N) 对序列进行翻转
    - sort(beg, end) stable_sort()
          #include <algorithm>
          O(NlogN) 对一个序列进行排序
          stable_sort()功能和sort()基本一样区别在于stable_sort()能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置 
    - to_string()
          #include <string>
          **将数字转化为字符串,支持小数（double）**
    - unique(beg,end)
          #include <algorithm>          
          **要求有序序列**
          **消除重复元素，但不实际删除元素。返回消除完重复元素的部分的末尾的下一位的地址**
          vector<int> a = {1, 2, 3, 3, 4, 4, 5, 6, 7, 7, 9};
          **auto it = unique(a.begin(), a.end());it指向9后面的一位而不是9**
          **a.erase(it, a.end());删除重复元素**

