### C++面经总结
### 1. C++基础
#### 1.1 综合问题
1. C++和Python的区别
   - Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。
   - Python使用缩进来区分不同的代码块，C++使用花括号来区分
   - C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等
   - Python的库函数比C++的多，调用起来很方便。比如在数据处理中。
2. C++和C语言的区别
   - C++是面向对象的，而C是面向过程的。c++支持面向对象程序设计、泛型程序设计等多种程序设计风格，而C没有类似的概念
   - C++中取代很多C中原有的功能
        C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。
        标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。
        C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。
        C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。
   - C++允许重载，而C不允许
   - C++增加了引用，而C没有
   - C++中存在命名空间的概念用于区分不同作用域的同名变量，而C没有命名空间的概念
3. 在main执行之前和之后执行的代码可能是什么？
   - main函数执行之前，主要就是初始化系统相关资源
     - 初始化静态static变量和global全局变量，即.data段的内容
     - 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
     - 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容
     - 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
     - __attribute__((constructor))   
   - main函数执行之后，主要是释放一些系统资源
     - 全局对象的析构函数会在main函数之后执行；
     - 可以用 atexit 注册一个函数，它会在main 之后执行;
     - __attribute__((destructor)) 
4. C++从代码到可执行程序经历了什么？（GCC工作流程）
    四步：预编译，编译，汇编，链接
   - 预编译（预处理代码.i）
    主要处理源代码文件中的以“#”开头的预编译指令
        1.删除所有的#define，展开所有的宏定义。
        2.处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。
        3.处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。
        4.删除所有的注释，“//”和“/**/”。
        5.保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。
   - 编译（汇编代码.s）
       把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件(其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义)
   - 汇编（二进制机器码.o）
        将汇编代码转变成机器可以执行的指令(机器码文件)xxx.o(Linux 下)、xxx.obj(Window下)
   - 链接
        将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接
5. 将字符串“hello world”从开始到打印到屏幕上的全过程?
   - 用户通过键盘输入告诉操作系统执行HelloWorld程序
   - 操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。
   - 创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。
   - 为helloworld程序设置cpu上下文环境，并跳到程序开始处。
   - 执行helloworld程序的第一条指令，发生缺页异常
   - 分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序
   - helloword程序执行系统调用，在显示器上写一字符串
6. 静态链接与动态链接（静态库与动态库）
   - 静态链接
      - 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
      - 缺点
            浪费空间：多个程序用会重复加载静态库至内存浪费空间
            更新困难：改变库代码后就需要重新编译与链接
            运行速度快：库代码已经打包到可执行文件中
   - 动态链接
      - 程序启动之后，动态库会被动态加载到内存中，再链接成一个完整的程序
      - 特点
            共享库节约空间
            更新方便不需要重新编译
            有性能损失，链接推迟到了程序运行时
   - 注意
     - 库非常小使用静态库，库比较大时使用动态库
     - 链接时加载的是动态库的一些信息如名称而不是动态库本身
     - 动态库运行时加载所以在内存中位置不确定，编译汇编时要加-fpic
     - 通过ldd命令检查动态库依赖关系
     - 如何定位库文件：通过设置环境变量LD_LIBRARY_PATH
     - 静态库：libxxx.a libxxx.lib, 动态库：libxxx.so,libxxx.dll
7. C++函数调用的压栈过程
    顺序:main(),mian()中调用func(), func()中调用f()
    - 操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈
    - main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；
    - 当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈
    - 函数调用的过程
        从栈空间分配存储空间
        从实参的存储空间复制值到形参栈空间
        进行运算
    - 注意
        形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。
        数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。
        当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递
8. main函数的返回值有什么值得考究之处吗？
    程序运行过程入口点main函数，main（）函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。
9.  程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？
    参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在字符串数组argv[]内，所有的参数在指针char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称
10. C++中struct和class的区别
    - 相同点
        两者都拥有成员函数、公有和私有部分
        任何可以使用class完成的工作，同样可以使用struct完成
    - 不同点
        两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
        class默认是private继承， 而struct默认是public继承  
11. C++和C的struct区别
     - C：struct是用户自定义数据类型（UDT）；C++：struct是抽象数据类型（ADT），也可以用于自定义结构体类型。
     - C：struct没有权限，C++：有权限，支持继承，多态，以及成员函数的定义
     - C：typedef struct A{}; C++： struct A{}；  
12. 结构体内存对齐问题
   - 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
   - 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐使**总大小**为8的倍数，其余如char则是占用4个字节）
   - #pragma pack(n)
        n=1,2,4,8...偏移量要是n和当前变量大小中较小值的整数倍。整体大小要是n和最大变量大小中较小值的整数倍
   - 对齐的目的是
     - 硬件原因
        不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
     - 性能原因
        为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需一次访问
   - c++11以后引入两个关键字 alignas (opens new window)与 alignof (opens new window)。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式
12. 结构体大小比较
   - 重载了 “==” 操作符
   - 元素的话，一个个比；
   - 指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；
13. 如何获得结构成员相对于结构开头的字节偏移量
    使用<stddef.h>头文件中的，offsetof宏。
    struct  S
    {
        int x;
        char y;
        int z;
        double a;
    };
    cout << offsetof(S, x) << endl;
#### 1.2 指针与引用
1. 指针和引用的区别
   - 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
   - 指针可以为空，引用不能为NULL且在定义时必须初始化
   - 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
   - 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
   - sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
2. 什么时候该使用指针，什么时候该使用引用呢？
   - 一般原则
        如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；
        如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；
        如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率
        如果数据对象是类对象，则使用const引用
   - 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。
3. 使用引用的好处与限制
   - 好处
     - 在函数内部可以对此参数进行修改
     - 提高效率
       - 传值需要给形参分配存储单元，形参变量是实参变量的副本。同时如果传递的是对象，还将调用拷贝构造函数。开销较大。
       - 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元。此外阅读性较差。
   - 限制
     - 不能返回局部变量的引用
     - 不能返回函数内部new分配的内存的引用
     - 可以返回类成员的引用，但是最好是const
4. C++中的值传递指针参数传递和引用参数传递有什么区别？底层原理你知道吗？
    - 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）    
    - 指针参数传递和引用参数传递都可以改变原值。区别在于指针参数传递是值传递，改变形参指针不会影响实参指针。而引用参数传递中形参存放的是实参变量的地址，对形参的任何操作都被处理成间接寻址。
    - 原理是：
        程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成之后就不会再改，因此指针可以改变其指向的对象即指针变量中的值可以改，而引用对象则不能修改。
5. 区别以下指针类型？
    int *p[10]:指针数组，数组内每个元素都是指向int类型的指针变量
    int (*p)[10]:数组指针，指针类型，指向的是一个int类型，大小是10的数组
    int *p(int)：函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
    int (*p)(int)：函数指针，指向的函数具有int类型参数，并且返回值是int类型的
    const int *p1 = &a;或者 int const *p1 = &a指针常量（指向常量的指针），指针常量不可修改其指向地址的值
    int *const p2 = &a;常量指针，指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化
6. 一个指针占多少字节？
    在64位的编译环境下的，指针的占用大小为8字节；而在32位环境下，指针占用大小为4字节。一个指针占内存的大小跟编译环境有关，而与机器的位数无关。
7. int a[10] 中a和&a有什么区别？
   - 假设数组int a[10]; int (*p)[10] = &a;其中：
     a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
     &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
     若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。
8. 数组名和指针（这里为指向数组首元素的指针）区别？
    - 数组名是常量指针，不能自增自减，但指向数组首元素的指针是变量指针
    - 数组名取地址得到的是数组名所指元素的地址。 对指针取地址得到的是指针变量自身的地址。
    - 当对数组名使用sizeof时，得到的是数组元素的个数乘元素类型的字节数，对指针sizeof得到的是指针类型的字节数    
9. 继承机制中对象之间如何转换？指针和引用之间如何转换？
    - 向上类型转换
        将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。
    - 向下类型转换
        将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。用dynamic_cast进行向下类型转换
10. 函数指针
    - 函数指针指向一个函数，而函数由其返回的数据类型和其参数列表共同决定，其返回的数据类型和其参数列表共同决定
    - int (*pf)(const int&, const int&);
    - 作用：
      - 将函数作为参数传递给函数
      - 嵌入式中引用不在代码段中的函数，有些函数固化在ROM中，不能直接使用函数名调用
11. 野指针和悬空指针
    - 野指针，指的是没有被初始化过的指针，为了防止出错，对于指针初始化时都是赋值为 nullptr
    - 悬空指针，指针最初指向的内存已经被释放了的一种指针
12. 指针加减计算要注意什么？
    需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，不能越位
#### 1.3 宏定义与内联函数
1. define宏定义和函数或者说inline函数有何区别？
    - #define PI 3.1415926,  #define A(x) x
    - 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
    - 宏定义没有返回值；函数调用具有返回值。
    - 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
2. define宏定义和typedef区别？
    - 作用
        宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名
    - 编译阶段
        宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分
    - 安全性
        宏不检查类型；typedef会检查数据类型
    - 在有指针的场景不一样
        typedef char *pStr1;
        #define pStr2 char *;
        pStr1 s1, s2;
        pStr2 s3, s4;
        s1、s2、s3都被定义为char *，而s4则定义成了char
3. define宏定义和const的区别
    - 编译阶段
        define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用
    - 安全性
        define只做替换，不做类型检查和计算
        const常量有数据类型，编译器可以对其进行类型安全检查
    - 内存占用
        define只是将宏名称进行替换，在内存中会产生多份相同的备份。const在程序运行中只有一份备份但要分配内存空间
4. 为什么不能把所有的函数写成内联函数?
    - 内联函数的目的
        调用函数时需要保存现场和执行的地址，调用完成后要恢复现场并按照原地址继续执行。存在空间和时间上的开销。对于代码量不大，但被频繁调用的函数来说，效率不高
    - 什么情况下不可以使用内联
      - 函数体内有循环，函数执行时间远大于函数调用的时间开销
      - 内联函数调用需要复制代码，如果函数体内的代码比较长，将导致内存消耗代价 
5. 构造函数、析构函数可否声明为内联函数
   - 可以声明为内联函数，语法上没有错误，但编译器并不一定真正的内联
   - 其次，class中的函数默认是inline型的，编译器也只是有选择性的inline
   - 构造函数和析构函数声明为内联函数是没有意义的，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。
6. 虚函数可否声明为内联函数
    看情况。如果虚函数在编译时就能够决定将要调用哪个函数时，就能够内联。但是如果指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。因为前者虚函数具有多态性，后者没有。
#### 1.4 关键字      
1. C++中static的作用
   - 不考虑类的情况
     - 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用.通过include使用。
     - 保持变量内容的持久。c语言中其在代码执行之前初始化，属于编译期初始化。静态变量在函数内定义，作用范围与局部变量相同，函数退出后仍然存在，但不能被别的函数使用。共有两种变量存储在全局初始化区：全局变量和static变量。
     - 默认初始化为0。包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
   - 考虑类的情况
     - static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
     - static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问
     - static成员函数不能被virtual修饰，static成员不属于任何对象或实例
2. static成员与普通成员的区别是什么
   - 生命周期
        静态成员变量从类被加载开始到类被卸载，一直存在；
        普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；
    - 共享方式
        静态成员变量是全类共享；普通成员变量是每个对象单独享用的；
    - 定义位置
        普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；
    - 初始化位置
        普通成员变量在类中初始化；静态成员变量在类外初始化；
    - 默认实参
        可以使用静态成员变量作为默认实参
3. static函数和普通函数的区别
    - 作用域不同
        用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。
    - 内存占用不同
        static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
    - 好处
        - 他文件中可以定义相同名字的函数，不会发生冲突
        - 静态函数不能被其他文件所用
4. C++中const的作用
    - 不考虑类的情况
        - const常量在定义时必须初始化，之后无法更改
        - const形参可以接收const和非const类型的实参，和引用结合时可以防止修改被引用的对象
    - 考虑类的情况
        - const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；类的不同对象对其const数据成员的值可以不同，所以不能在类中声明时初始化
        - const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值
    - 补充：
        - const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以声明使用。 因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。
        - const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；
5. C++的顶层const和底层const
    - 顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边
    - 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边
    - 顶层：const int a;int const a;int *const a;
    - 底层：const int *a;
6. final和override关键字
    - override：指定子类的虚函数必须是重写的父类的，如果父类没有对应的虚函数，编译器会报错
    - final：当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错
        void foo() override; class B final : A{};
7. volatile关键字的用法
    volatile定义变量的值是易变的，表明编译器不去优化该变量，每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。这样在多线程中使用被几个任务共享的变量就不会造成冲突。
    const char* cpch;volatile char* vpch;
    char* const pchc;char* volatile pchv;
8. mutable关键字的用法
    volatile定义变量的值是可变的，为了突破const的限制而设置的。可以在类中使用常量函数来修改被mutable修饰的变量。
    mutable int m_B;
9.  explicit关键字的用法
    - explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换
    - 关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。
10. extern"C"的用法
    正确的在C++代码中调用C语言的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；
    extern "C" {

    }

#### 1.5 一些函数
1. 你知道printf函数的实现原理是什么吗？
    C++通过压入堆栈的方式给函数传参，参数从右往左依次压入栈中，这样最后参数就在栈底，第一个参数在栈顶。而栈是由高地址向低地址增长，所以结构上第一个参数就在低地址处，堆栈指针的上方，可以直接获取到。而printf的第一个参数就是字符指针，再通过字符串里控制参数的个数来判断参数个数及数据类型就可以计算出堆栈指针需要移动的偏移量了。
2. cout和printf有什么区别？
    cout是ostream对象而printf是一个函数
    cout<<可以自己重载来扩展，同时有类型检查更安全
3. 你知道strcpy，memcpy， sprintf的区别是什么吗？
    - void * memcpy (void * dest, const void * src, size_t n);
    - char * strcpy(char * dest,char * src);
    - int sprintf( char *buffer, const char *format [, argument,...] );
    - 实现功能不同
        strcpy主要实现字符串变量间的拷贝
        sprintf主要实现其他数据类型格式到字符串的转化   
        memcpy主要是内存块间的拷贝。
    - 操作对象不同
      strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串
    - 安全性不同
        strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
    - 执行效率不同
        memcpy最高，strcpy次之，sprintf的效率最低。
4. strcpy函数和strncpy函数的区别？哪个函数更安全？
    char* strcpy(char* strDest, const char* strSrc)
    char *strncpy(char *dest, const char *src, size_t n)
    - strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况
    - strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符
5. strlen和sizeof区别？
    - sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
    - sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
    - 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小
6. 你知道回调函数吗？它的作用？
    - 回调函数就是一个通过函数指针调用的函数。把函数的指针（地址）作为参数传递给另一个函数。在这个函数内通过函数指针调用
    - 作用：相当于一个中断处理函数，由系统在符合你设定的条件时自动调用 
#### 1.6 全局与局部，静态与动态，临时变量
1. 静态类型和动态类型，静态绑定和动态绑定的介绍
    - 概念
    静态类型：对象在声明时采用的类型，在编译期既已确定；
    动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；A* pa = pc;  
    静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
    动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；    
    - 注意
      - 要想实现多态，必须使用动态绑定；在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；
      - 绝对不要重新定义继承而来的非虚(non-virtual)函数，因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；
      - 在动态绑定也即在virtual函数中，要注意默认参数的使用。当缺省参数和virtual函数一起使用的时候一定要谨慎 
2. 引用是否能实现动态绑定，为什么可以实现？
    引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。父类引用绑定子类对象，只能调用虚函数。
3. 全局变量和局部变量有什么区别？
    - 生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
    - 使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。
    - 存储位置不同：全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面   
4. 全局变量和static变量的区别
    - 作用域不同
        全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件，知识需要extern声明。静态局部变量具有局部作用域，只对定义自己的函数体可见。静态全局变量有文件作用域，只对当前定义该变量的源文件有效。两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
5. C++中将临时变量作为返回值时的处理过程
    - 临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量.
    - 函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系

#### 1.7 声明，定义，初始化
1. 声明和定义区别？
    - 对于变量：声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。相同变量可以在多处声明（外部变量extern），但只能在一处定义。
    - 对于函数：声明一般在头文件中，实现一般在源文件中
2. 初始化和赋值的区别
    - 对于简单类型来说，初始化和赋值没什么区别
    - 对于类和复杂数据类型来说，这两者的区别就大了
       A a1 = a; 
       A b;  b = a;
       创建对象时初始化，分为直接初始化和拷贝初始化，使用"="的为拷贝初始化。分分布会调用构造函数和拷贝构造函数。而对于赋值，是在对象创建以后，在通过赋值擦除原值。如果重载了operator=，则会调用该重载
3. C++初始化时机
    - 静态初始化
        是指用常量对变量进行初始化。其中未赋初值及初值为0的放在bss段，其他放在data段。静态初始化在程序加载时完成。
    - 动态初始化
        是指需要经过函数调用才能完成的初始化。 对于全局或者类的静态成员变量，是在main()函数执行前由运行时调用相应的代码进行初始化的。而对于局部静态变量，是在函数执行至此初始化语句时才开始执行的初始化。
    - 如果是静态初始化，是在main()函数之前，程序加载时初始化；如果是动态初始化，则要区分是局部静态变量还是全局变量或者全局静态变量，局部静态变量则在函数第一次执行到时初始化，否则在main()函数之前，运行时初始化。
4. 类成员初始化方式？为什么用成员初始化列表会快一些？
    - 赋值初始化，通过在函数体内进行赋值初始化
    - 列表初始化，在冒号后使用初始化列表进行初始化
    - 列表初始化是给数据成员分配内存空间时就进行初始化,此时函数体还未执行。而赋值初始化会产生临时对象的。而赋值初始化会产生临时对象，额外调用构造函数。
5. 有哪些情况必须用到成员列表初始化？作用是什么？
    - 四种情况
      - 当初始化一个引用成员时；
      - 当初始化一个常量成员时；
      - 当调用一个基类的构造函数，而它拥有一组参数时；
      - 当调用一个成员类的构造函数，而它拥有一组参数时；
    - 成员初始化列表做了什么
      - 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；
      - list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；

#### 1.8 显式转换，隐式转换
1. 隐式转换，如何消除隐式转换？
    - 隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为,比如基本数据类型的转换，父类对象与子类对象的转换
    - 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换
    - 也可以通过重载转换函数如operator int()的方式来完成类向基本类型的转换
    - 举例：
        Person p1 = 100; //隐式转换
        Person p2 = Person(100.00);//显式调用
2. C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast
    - reinterpret_cast
        - reinterpret_cast<type-id> (expression)
        - type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。
    - const_cast
        - const_cast<type_id> (expression)
        - 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：
            常量指针被转化成非常量的指针，并且仍然指向原来的对象
            常量引用被转换成非常量的引用，并且仍然指向原来的对象
            const_cast一般用于修改底层指针。如const char *p形式
    - static_cast
       - static_cast < type-id > (expression)
       - 该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：
          - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换
          - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
          - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于**没有动态类型检查**，所以是不安全的
          - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
          - 把空指针转换成目标类型的空指针
          - 把任何类型的表达式转换成void类型
          - 注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。
    - dynamic_cast
        dynamic_cast <type-id> (expression)
          - 有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全
          - 该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用
          - dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）
          - dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换
                在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的
                在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全
3. static_cast比C语言中的转换强在哪里？
    - 更加安全,C++风格在编译阶段就会针对错误的转换报错，而C风格不会
    - 更直接明显可读性更好，可清楚地辨别代码中每个显式的强制转
#### 1.9 其他
1. 说一说一致性哈希
    - 普通hash算法具有缺陷
        比如在服务器缓存的场景中，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，造成了缓存的雪崩，服务器压力过大而崩溃
    - 一致性哈希
      - 一致性哈希算法是对 2^32 取模。一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个哈希环，将各个服务器与数据使用相同的Hash算法映射到哈希环上，对于每个数据，从其位置沿环顺时针查找，遇到的第一台服务器就是其应该定位到的服务器
      - 避免雪崩
        一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性  
      - 环的倾斜与虚拟节点
        当服务器节点分布不均即大多数缓存集中于服务器上时，也容易导致缓存雪崩。就需要采用对每一个服务节点计算多个哈希，一个物理节点对应多个虚拟节点，这样缓存就可以尽量均匀分布。具体做法可以在服务器ip或主机名的后面增加编号来实现。
2. C和C++的类型安全
    - 类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。类型安全的编程语言与类型安全的程序之间，没有必然联系。
    - C是类型不安全的，比如malloc函数的返回值是空类型指针，如果我们使用显式的类型转换会产生问题，但是C并不会报错char* pStr=(char*)malloc(100*sizeof(char))
    - C++相对于C提供了一些新的机制保障类型安全
      - 操作符new返回的指针类型严格与对象匹配，而不是void*
      - C++模板函数支持类型检查
      - C++提供了dynamic_cast关键字，使得转换过程更加安全
3. 浅拷贝和深拷贝的区别
    - 浅拷贝
        浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。
    - 深拷贝
        深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的
        ```
        	Student(const Student &s){//拷贝构造函数
                //浅拷贝，当对象的name和传入对象的name指向相同的地址
                name = s.name;
                //深拷贝
                //name = new char(20);
                //memcpy(name, s.name, strlen(s.name));
                cout << "copy Student" << endl;
            };
        ```
4. 如何用代码判断大小端存储？
    0X12345678
    - 高低字节位：左边为高字节，右边为低字节
    - 大端存储：字数据的高字节存储在低地址中（符合人的阅读习惯）
    - 小端存储：字数据的低字节存储在低地址中（符合计算机处理）
    - 鉴别方式：使用强制类型转换
        ```
        #include <iostream>
        using namespace std;
        int main()
        {
            int a = 0x1234;
            //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
            char c = (char)(a);
            if (c == 0x12)
                cout << "big endian" << endl;
            else if(c == 0x34)
                cout << "little endian" << endl;
        }
        ```
5. C++的异常处理的方法
    - 对于语法错误（编译错误），如变量未定义、括号不匹配、关键字拼写错误编译器可以发现。
    - 对于运行时错误，如数组下标越界、系统内存不足可以通过编译但运行时会报错。C++通过try(检查)、throw(抛出)、catch(捕获)异常处理机制来处理。执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。
    - 常见异常
        数组下标越界
        除法计算时除数为0
        动态分配空间时空间不足
    - try、throw和catch关键字
        try {
             throw -1；   
        }catch (int a) {

        }catch (...) {

        } 
    - 函数的异常声明列表
        int fun() throw(int,double,A,B,C){...};
    - C++标准异常类 exception
        #include <typeinfo>
        bad_typeid:指针为空抛出异常
        ```
        	try {
                cout << typeid(*a).name() << endl; // Error condition
            }
            catch (bad_typeid){
                cout << "Object is NULL" << endl;
            }
        ```
        bad_cast：bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常
        bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常
        out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常
6. 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？
        coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。
        g++ coredumpTest.cpp -g -o coredumpTest
        ./coredumpTest
        gdb [可执行文件名] [core文件名]
7. 形参与实参的区别？
    - 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
    - 实参在函数调用的时候必须要有确定的值
    - 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
8. 零拷贝的了解
    零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。
    在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。
9.  怎样判断两个浮点数是否相等？
    对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。
10. 说一下你理解的 ifdef endif代表着什么？
    - 条件编译，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句
    - 多个文件同时包含一个头文件，防止重定义
11. 如何在不使用额外空间的情况下，交换两个数？
    - 算数法:浮点型会有精度损失
        x = x + y;
        y = x - y;
        x = x - y;
    - 异或法:无法交换浮点型
    　a ^= b; // a=a^b
    　b ^= a; // b=b^(a^b)=b^a^b=b^b^a=0^a=a
    　a ^= b; // a=(a^b)^a=a^b^a=a^a^b=0^b=b
    - 相除法:浮点型会有精度损失，且b != 0
        a = a * b;
        b = a / b;
        a = a / b;
12. 你知道Debug和Release的区别是什么吗？
    - 调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。
    - 发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。
    - 本质上没有区别，只是一组编译选项的集合



### 2. C++面向对象
1. 介绍面向对象的三大特性，并且举例说明
    三大特性：继承、封装和多态
    - 继承
      -  让某种类型对象获得另一个类型对象的属性和方法。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
      - 常见的继承有三种方式：
        实现继承：指使用基类的属性和方法而无需额外编码的能力
        接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
        可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）
        例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法
    - 封装
        封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。
    - 多态
      - 同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。
      - 实现多态有二种方式：覆盖（override），重载（overload),重载实现编译时多态，虚函数实现运行时多态
        覆盖：是指子类重新定义父类的虚函数的做法。
        重载：是指允许存在多个同名函数，而这些函数的参数表不同
        抽象类通过纯虚函数也实现多态
        例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。 
2. 多态性底层的原理是什么？
   - 虚表
        虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表
   - 虚指针
        在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针
   - 实现多态的过程
     - 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址
     - 每个对象中保存一个虚表指针vptr，指向对象所属类的虚表。构造对象的时候，基类先于派生类构造，基类构造函数初始化对象虚指针后，也会先将虚指针指向基类虚表，再在派生类构造中用派生类虚表地址覆写对象虚指针
     - 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面
3. 抽象基类为什么不能创建对象？
   - 定义
        - 称带有纯虚函数的类为抽象类，方便实现多态特性
        - 有时有的类不能生成对象，如动物本身不可以生产对象，而老虎可以
   - 作用
        作为公共基类定义接口函数
   - 原因
        存在纯虚函数，其实现由派生类给出
4. 多继承的优缺点
   - 优点：多继承的优缺点，作为一个开发者怎么看待多继承
   - 缺点：派生类所继承的多个基类有相同的基类会产生二义性，需要通过显示指定pa.Author::eat()或者采用虚拟继承        
5. 什么是虚拟继承
   - 虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承导致的二义性问题而出现的。在访问公共基类的对象时，会导致二义性，需要显示指定，如DerivedA::value或 者DerivedB::value。而在虚拟继承中，虚基类只用同一个（共享）对象表示。
   - 如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。
   - 虚拟继承增加了一个虚基类指针vptr，指向虚基类表，其中记录虚基类于与奔类的偏移地址，通过偏移地址就可以找到虚基类成员
    普通继承直接访问基类成员，虚拟继承访问基类成员通过
6. 为什么析构函数一般写成虚函数？
    - 由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。
    - 如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。
    - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数
        `virtual  类型  函数名(参数列表）= 0`
    - （但存在一种特例，在CRTP模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应 该声明为虚函数，因为这种继承方式，不需要虚函数表）
7. 哪些函数不能是虚函数？把你知道的都说一说
   - 构造函数
   - 内敛函数看情况
   - 静态函数
   - 友元函数
   - 普通函数
8. 构造函数能否声明为虚函数或者纯虚函数?
    虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。
9.  基类的虚函数表和虚函数存放在内存的什么区
   - 虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
   - 虚函数表存储虚函数的地址,类中虚函数的个数在编译时期可以确定，即虚函数表的大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中
   - 虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，所以虚函数表位于C++内存模型中的常量区；而虚函数则位于代码区
11. 虚函数能定义为静态函数吗？
    不能。
   - static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的
   - 静态函数没有this指针，无法通过this指针调用隐藏的成员虚指针vptr，也就无法调用虚函数了
12. 虚表指针vptr的初始化时间
    在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面
13. 什么情况下 调用虚函数不会有多态性
    - 在构造函数或者析构函数里面调用虚函数，不会有多态性。所以一般不要在构造函数或者析构函数里面调用虚函数。
        构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；
        因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；
        析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义
    - 还有基类的默认实参和子类的默认实参，也不会有多态性。
    - 通过对象调用不会有多态性。
        ```
        Base *p=new Derived();
        p->fun();//假定fun是虚函数，会调用子类的fun函数实现
        Derived d;
        Base b=d;
        b.fun();//会调用基类的fun函数。
        ```
14. 虚函数的代价是什么？
    - 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类
    - 带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；
    - 虚函数大多数情况下无法内联
15. 纯虚函数和虚函数区别
    - 作用不同
    - 在虚表中内容不同
        纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址
16. 构造函数析构函数可否抛出异常（**会造成内存泄露**）
    - C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏
    - 如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情，也可能造成内存泄露
    - 使用智能指针取代指针类成员，除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源
17. 类什么时候会析构？
   - 对象生命周期结束，被销毁时；
   - delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；
   - 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。
12. 构造函数的几种关键字
    - default
       显式要求编译器生成合成构造函数 
    - delete
      delete关键字可以删除构造函数、赋值运算符函数
    - 0
      将虚函数定义为纯虚函数  
13. 模板会写吗？写一个比较大小的模板函数
    ```
    #include<iostream> 
    using namespace std; 
    template<typename type1,typename type2>//函数模板 
    type1 Max(type1 a,type2 b) 
    { 
    return a > b ? a : b; 
    } 

    void main() 
    { 
    cout<<"Max = "<<Max(5.5,'a')<<endl; 
    } 
    ```
    BUG:a、b只有在能进行转型的时候才能进行比较，否则 a > b 这一步是会报错的。这个时候往往需要对于 > 号进行重载
14. C++模板是什么，你知道底层怎么实现的？
   - 模板是c++的一种特性，允许函数或者类（对象）通过泛型（generic types）的形式表现或者运行模板可以使得函数或类在对应不同的类型（types）的时候正常工作，而无需为每一种类型分别写一份代码。
   - 二次编译。因为函数模板要被实例化后才能成为真正的函数，编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。
15. 模板类和模板函数的区别是什么？
    - 函数模板允许隐式调用和显式调用而类模板只能显示调用
    - 在使用时类模板必须加<T>，而函数模板不必
16. 模板函数和模板类的特例化
   - 引入原因
    编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化
   - 定义
     对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值
   - 模板函数特例化
        ```
        template<typename T> //模板函数
        int compare(const T &v1,const T &v2)
        {
            if(v1 > v2) return -1;
            if(v2 > v1) return 1;
            return 0;
        }
        //模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
        template<> 
        int compare(const char* const &v1,const char* const &v2)
        {
            return strcmp(p1,p2);
        }
        ```
   - 类模板特例化
        我们可以对模板进行特例化，也可以对类进行部分特例化
        不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参
        ```
         //general template
        template<class T1, class T2> 
        class Pair { ... }; 

        //specialization with T2 set to int
        template<class T1>
        class Pair<T1, int>  { ... }; 
        ```
        也可以特例化类中的部分成员
        ```
        template<typename T>
        class Foo
        {
            void Bar();
            void Barst(T a)();
        };

        template<>
        void Foo<int>::Bar()
        {
            //进行int类型的特例化处理
            cout << "我是int型特例化" << endl;
        }

        Foo<string> fs;
        Foo<int> fi;//使用特例化
        fs.Bar();//使用的是普通模板，即Foo<string>::Bar()
        fi.Bar();//特例化版本，执行Foo<int>::Bar()
        //Foo<string>::Bar()和Foo<int>::Bar()功能不同
        ```
   - 本质
       - 特例化的本质是实例化一个模板，而非重载它。
       - 特例化不影响参数匹配。参数匹配都以最佳匹配为原则。
       - 注意二者函数体的语句不一样了，实现不同功能
       - 模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本
17. 模板和实现可不可以不写在一个文件里面？为什么？
    一般不可以。因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。
18. 如果有一个空类，它会默认添加哪些函数？
    1)  Empty(); // 缺省构造函数//
    2)  Empty( const Empty& ); // 拷贝构造函数//
    3)  ~Empty(); // 析构函数//
    4)  Empty& operator=( const Empty& ); // 赋值运算符// 
19. 构造函数的执行顺序 ？
    - 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。
    - 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。
    - 类类型的成员对象的构造函数（按照初始化顺序）
    - 派生类自己的构造函数。
20. C++有哪几种的构造函数
        默认构造函数
        初始化构造函数：有参数和参数列表
        拷贝构造函数（编译器也会生成）
        移动构造函数
            对于深拷贝情形，如果指针所指向非常大的内存数据的化，那么拷贝函数就要分配一个很大的内存，非常影响性能。
            移动构造函数,采用浅拷贝加移动语义，即是在用原对象指针对新对象指针进行赋值后,将原对象成员指针置为空指针,使得其无法指向内存数据,从而保证在析构的时候不会产生内存泄漏。这样既不用分配新内存,也不会产生内存泄漏,从而很好地解决了上述问题
            HasPtrMem(HasPtrMem& h) : m_data(new int(*h.m_data)){} //拷贝构造函数,从堆中分配内存，用h.m_data初始化
            A(A&& a):m_i(a.m_i){a.m_ptr = nullptr;}
        委托构造函数
            委托构造函数是为了构造函数减少代码的重复,允许在同一个类中一个构造函数可以调用另外一个构造函数
            ClassA(int max, int min):ClassA(max) {}
        转换构造函数
            用于将其他类型的变量，隐式转换为本类对象。形参是其他类型变量，且只有一个形参
            ClassA(int i) {}   
20. 构造函数的执行顺序是什么？
    - 在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；
    - 对象的vptr被初始化；
    - 如果有成员初始化列表，将在构造函数体内扩展开来，这**必须在vptr被设定之后才做**，为了防止在初始化列表出现调用虚函数的情况，没有vptr的话就会访问基类的虚函数；
    - 执行程序员所提供的代码
21. 什么情况会自动生成默认构造函数？
    - 在没有显示定义构造函数的时候，编辑器不一定会自动生成默认的构造函数
    - 含有类对象数据成员，该类对象类型有默认构造函数，因为需要在构造函数的初始化列表内初始化对象成员
    - 派生类的基类带有默认构造函数，因为需要初始化基类
    - 基类带有默认构造函数的，因为需要初始化虚指针
    - 虚拟继承下，因为需要初始化虚表指针
22. 那什么时候需要自动生成拷贝构造函数呢？
    和默认构造函数的生成场景一样
    如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；
    如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；
    如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；
    如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数
23. 什么情况下会调用拷贝构造函数？
    - 拷贝初始化时，比如X xx = x;
    - 当对象被当做参数交给某个函数时；
    - 当函数传回一个类对象时；
24. 为什么拷贝构造函数必须传引用不能传值？
    因为如果拷贝构造函数中的参数不是一个引用，当于采用了传值的方式，传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。
    **不是因为会产生临时对象！**
25. 类与类之间的关系
    - 继承，is-a
        子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法
    - 依赖（dependence）既“use-a” 关系。
        类B作为参数被类A在某个method方法中使用
    - 聚合（aggergation） 即"has-a"关系。
        类B包含类A，整体与部分的关系，但是可以具有各自的生命周期。即成员对象不由整体对象初始化
    - 组合（composition） 
        类B包含类A，但整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。
26. 组合相比继承有什么优缺点？ 
    - 继承
        优点：
            子类可以重写父类的方法来方便地实现对父类的扩展。
        缺点：
            父类的内部细节对子类是可见的
            高度耦合。父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。
    - 组合
        优点：
            对象成员细节不可见
            低耦合
        缺点：
            容易产生过多的对象
            使用对象要仔细定义接口 
27. public，protected和private访问和继承的区别
    - 访问
        public的变量和函数在类的内部外部都可以访问。
        protected的变量和函数只能在类的内部和其派生类以及友元函数中访问。
        private修饰的元素只能在类内以及友元函数中访问 
    - 继承
       公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员
       保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
       私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。
    - 注意：派生类对基类成员的访问权限取决于两点：一、继承方式；二、基类成员在基类中的访问权限。基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
    - 派生类继承了所有的基类方法，除了
        基类的构造函数、析构函数和拷贝构造函数。
        基类的重载运算符。
        基类的友元函数
    - 恢复继承的成员在基类中的访问权限
        使用using 语句，这是C++标准建议使用的方式 
28. 拷贝初始化和直接初始化
    直接初始化直接调用与实参匹配的构造函数
    拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象
        string str1("I am a string");//语句1 直接初始化
        string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化
        string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
        string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
29. 什么情况下会调用拷贝构造函数
    - 拷贝初始化的时候，=
    - 非引用传递，函数的参数是类的对象时
    - 函数返回类的对象时
        产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象， 依然会调用拷贝构造函数
30. 拷贝构造函数和赋值运算符重载的区别？
    - 拷贝构造函数是函数，赋值运算符是运算符重载
    - 拷贝构造函数会生成新的类对象，赋值运算符是对已存在的对象进行赋值
    - 并不是所有出现"="的地方都是使用赋值运算符
    - 类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。
31. C++中的重载、重写（覆盖）和重定义（隐藏）的区别
    - 重载（overload）
        重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关
    - 重写（覆盖）（override）
        重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数且：与基类的虚函数有相同的参数个数、参数类型、返回值类型
    - 重定义（隐藏）（hide）
        隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数
        - 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。
        - 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中
    - 重载与重写的区别：
        重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系
        重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
        重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体
32. 类如何实现只能静态分配和只能动态分配
    前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建。
33. 如何设计一个计算仅单个子类的对象个数
    - 为类设计一个static静态变量count作为计数器；
    - 类定义结束后初始化count;
    - 在构造函数中对count进行+1;
    - 在析构函数中对count进行-1；
34. 如何阻止一个类被实例化
    - 将类定义为抽象基类
    - 将构造函数声明为private；
35. 如何禁止程序自动生成拷贝构造函数？
    定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函
    数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作.
36. 友元函数和友元类的基本情况
    - 作用
        友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。
    - 缺点
        友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。
    - 友元函数
        定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。需要在类的定义中声明所有可以访问它的友元函数。
    - 友元类
        友元类的所有成员函数都是另一个类的友元函数，另一个类里面也要相应的进行声明
    - 注意
        友元关系不能被继承，不能被传递，单向
37. 如果想将某个类用作基类，为什么该类必须定义而非声明？
    派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么           
38. 为什么模板类一般都是放在一个h文件中？
    因为在分离式编译中，不同的cpp文件都不指定彼此内部有什么。调用文件会寻找模板中的函数，但由于模板没有实例化，所以找不到对应的函数地址，就会报错  
39. 你知道重载运算符吗？
    - 我们只能重载已有的运算符，而无权发明新的运算符
    - 两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数
        成员运算符比如+，-
        非成员运算符如<<,使用友元函数实现
40. 当程序中有函数重载时，函数的匹配原则和顺序是什么？
    名字查找
    确定候选函数
    寻找最佳匹配        
41. 对象复用的了解
    对象复用其本质是一种设计模式：Flyweight享元模式。通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。  
42. 成员函数里memset(this,0,sizeof(*this))会发生什么
    - 有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0 
    - 以下情况不能使用
      - 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；
      - 类中含有C++类型的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存      




### 3. C++内存管理
1. 类的对象存储空间？
   - 非静态成员的数据类型大小之和。
   - 编译器加入的额外成员变量（如指向虚函数表的指针）。
   - 内存对齐额外需要的空间。
   - 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展
2. 空类的大小是多少吗？
   - C++空类的大小不为0，不同编译器设置不一样，vs设置为1；原因是C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配**一个字节大小**来区分不同的实例。
   - 对于空白类作为基类时，该类的大小为0
   - 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；
3. 简要说明C++的内存分区
    由低地址到高地址分别为代码区，常量区，全局（静态）数据区，堆区，未使用内存，栈区
   - 注意
     - C++存储不区分全局变量和静态变量，C会分别存储
     - 自由存储区与堆并不等价，通过new来申请的内存区域可称为自由存储区，自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
4. 什么是内存池，如何实现
    - 内存池（Memory Pool） 是一种内存分配方式。直接使用new、malloc 等申请内存的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。
    - 内存池实现机制
        allocate 包装 malloc，deallocate包装free。通过哈希桶加自由链表实现的内存池来分配内存
        - 维护16条链表，8~128字节，以8字节递增。传入所需要的内存大小，映射到对应链表。如果对应自由链表不为空，则从中取出内存块。
        - 链表为空则查看内存池是否为空，如果内存池不为空，查看剩余空间是否够20个节点大小，如果足够则将1个分配给用户，其余挂到相应的自由链表下。
        - 如果不够20个大小，查看是否至少有1个，将其分配给用户，其余挂到相应的自由链表下。
        - 如果一个都没有，则二级空间配置器会使用malloc()从heap上申请内存，申请40块，一半拿来用，一半放内存池中。
        - 如果malloc()失败则从其他内存块较大的链表上拔除一个来使用。
        - 如果这都没有，就调用一级适配器
5. C++中类的数据成员和成员函数内存分布情况
   - 一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。
   - 静态成员函数与一般成员函数的唯一区别就是没有this指针，因此不能访问非静态数据成员。**所有函数都存放在代码区，静态函数也不例外**。所以有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。
6. 关于this指针你知道什么？全说出来
   - 概念
     当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。
   - 特点
     - this指针是类的指针，指向对象的首地址。
     - this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
     - this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的
   - 用处
      - 访问类对象成员 
      - 返回对象本身return *this;
      - 区分相同变量名，如this->n = n
7. this指针是什么时候创建的？
    this在成员函数的开始执行前构造，在成员的执行结束后清除。在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。
8. this指针存放在何处？堆、栈、全局变量，还是其他？
    this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。
9.  this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？
    this是通过函数参数的首参来传递的。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。
10. 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？
    **this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。
11. 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？
    普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。
12. 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？
    在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。
13. 为什么是不可预期的问题？
    delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限错误。可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的。
14. 如果在类的析构函数中调用delete this，会发生什么？
    会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃
15. this指针调用成员变量时，堆栈会发生什么变化？
    当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。
16. 堆和栈的区别
   - 申请方式不同
        堆是自己申请和释放的，栈由系统自动分配
   - 空间大小不同
        堆是不连续的内存区域，受限于计算机系统中有效的虚拟内存（32位 4G）
        栈是一块连续的内存区域，大小固定，过ulimit -a查看，由ulimit -s修改
   - 管理机制不同
        堆由链表管理，当在堆中申请空间时，操作系统首先从空闲链表中找到第一个空间大于“申请空间”的节点，将其分配。多余的部分，系统自动放回空闲链表。在这块内存空间首地址处记录分配的大小，如此，之后的delete()才能正确释放内存空间。
        只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出
   - 碎片问题
        对于堆，频繁的new/delete会造成大量碎片，使程序效率降低
        对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。
   - 生长方向不同
        堆向上，向高地址方向增长。	栈向下，向低地址方向增长。
        (堆从低向高扩展，方便内存管理。栈从高向低是为了最大程度利用地址空间，否则必须指定栈堆的分界线，会导致分配不均。同时高向低也确定了栈空间的起始位置，避免了动态扩展栈空间时需要移动整个栈的数据
   - 分配效率不同
        堆由C/C++函数库提供在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。
        而计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。
        所以堆的效率比栈低很多
17. 什么是内存泄露，如何检测与避免
    - 内存泄漏是指堆内存的泄漏，使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了
    - 后果
        漏大量内存的程序性能下降到内存逐渐用完，导致另一个程序失败；
    - 避免内存泄露的几种方式
        - 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露
        - 一定要将基类的析构函数声明为虚函数
        - 智能指针
        - 对象数组的释放一定要用delete []
        - 有new就有delete，有malloc就有free，保证它们一定成对出现
        - 利用检测工具：Linux下可以使用Valgrind工具
18. malloc、realloc、calloc、allocator的区别
    - malloc就是一般的分配内存方式，需要传入申请的空间的大小
        int *p = malloc(20*sizeof(int));
    - calloc，省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；
        int *p = calloc(20, sizeof(int));
    - reallo：给动态分配的空间分配额外的空间，用于扩充容量
        void realloc(void *p, size_t new_size);
    - new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。
19. C++中有几种类型的new
    - plain new
        普通的new，就是我们常用的new
        int *p = new int(5);
        int *p = new int[5];
    - nothrow new
        char *p = new(nothrow) char[10];
        nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL
    - placement new
        - 主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组.placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。
        - placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。
            ADT *q = new(p) ADT; 
            q->ADT::~ADT();//显示调用析构函数,不能delete q;
	        delete[] p;
20. new / delete 与 malloc / free的异同
   - 相同点
        都可用于内存的动态申请和释放
   - 不同点
     - 前者是C++运算符，后者是C/C++语言标准库函数
     - new自动计算要分配的空间大小，malloc需要显式指定
     - new是类型安全的，malloc不是。因为malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。例如：
        int *p = new float[2]; //编译错误
        int *p = (int*)malloc(2 * sizeof(double));//编译无错误
     - new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL
     - new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者不具有调用构造函数和析构函数功能。
     - new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象
21. delete和delete[]区别？
    delete只会调用一次析构函数。
    delete[]会调用数组中每个元素的析构函数  
22. new和delete是如何实现的？
   - new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针
   - delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存
23. malloc与free的实现原理？
    - 操作系统将可用的内存块连接为空闲链表，调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二。接下来，将分配给用户的那块内存传给用户，并将剩下的那块返回到连接表上。如果空闲链上没有足够大的内存块，则将相邻的小空闲块合并成较大的内存块再使用。
    - 调用free函数时，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。它将用户释放的内存块连接到空闲链上。
    - 底层是使用了brk、mmap、，munmap这些系统调用来分配虚拟内存，之后在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；
24. 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？
    动态创建对象时，malloc/free可以申请内存和回收内存，但无法执行构造函数和析构函数。会导致内存泄露。
25. 被free回收的内存是立即返还给操作系统吗？
    不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片


### 4. C++11新特性
1. C++ 11有哪些新特性？
    - nullptr替代 NULL
    - 引入了 auto 和 decltype 这两个关键字实现了类型推导
    - 基于范围的 for 循环for(auto& i : res){}
    - 类和结构体的中初始化列表
    - Lambda 表达式（匿名函数）
    - std::forward_list（单向链表）
    - 右值引用和move语义
    - ...
2. auto、decltype
   - auto
     - auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。
     - 例
        const auto l = i; 顶层
        auto& p1 = y; //p1是int&型
        auto p2 = &x; //p2是指针类型int*
   - decltype 
      - 选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。
      - 例 
        decltype(c) d = c;//不论是顶层const还是底层const, decltype都会保留
3. C++中NULL和nullptr区别
   - C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0
   - 在C++中指针必须有明确的类型定义，NULL定义为0无法与整数0区分，而C++中允许有函数重载，如果对于重载的函数传入NULL，会造成调用了参数为int的函数而不是参数为指针的函数。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型。
4. 智能指针
   - 原理
        智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏，当类对象声明周期结束时，自动调用析构函数释放资源。
   - 源代码（见cpp文件）
   - auto_ptr
     - 利用RALL思想实现资源管理
     - 特点
       - 有拷贝和赋值语义，拷贝或赋值后源对象无效
       - 不能共享所有权，会传递所有权
       - 不能用在STL标准容器中，TL容器中的元素经常要支持拷贝、赋值操作
   - shared_ptr
       - 允许共享所有权，使用引用计数的方式实现多个shared_ptr对象之间共享资源
       - 特点
         - 对象被销毁也就是调用析构函数时，计数减1，如果计数为0，说明自己是最后一个使用该资源的对象，必须释放该资源
         - 存在循环引用的问题：比如动态分配（new）的对象A内如果存在指向对象B的指针智能，而B内也存在指向A的智能指针，会导致哪怕程序结束后，A,B的引用计数都为1，不会调用A和B的析构函数，造成了内存泄露
         - **存在多线程安全问题**，智能指针中引用计数++、–需要加锁，也就是说引用计数的操作需要是线程安全的
   - weak_ptr
       - 弱引用，为了解决shared_ptr中的循环引用的问题。
       - 特点
         - 只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。
         - 所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针
   - unique_ptr
       - 独享所有权，一个非空的unique_ptr总是拥有它所指向的资源
       - 特点
         - 禁止拷贝和赋值
         - 不能用在STL标准容器中
   - 注意
     - 不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的
     - 初始化：
        auto_ptr<int> a1(new int(1));
        auto_ptr<int> a2(a1);
5. 说说你了解的auto_ptr
   - auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏
   - auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；
   - 由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针
   - Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组
   - 可以通过*和->运算符对auto_ptr所有用的指针进行提领操作；
   - T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。
6. 手写实现智能指针类需要实现哪些函数？
    构造函数、拷贝构造函数、重载赋值运算符、析构函数、移动函数
7. 使用智能指针管理内存资源，RAII是怎么回事？
    RAII全称是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。
    而智能指针即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。
8. lambda函数（匿名函数）
   - 利用lambda表达式可以编写内嵌的匿名函数，用来替换独立函数
   - lambda函数是通过仿函数对象实现的。每当你定义一个lambda表达式后，编译器会自动生成一个匿名类即闭包类型（closure type）。运行时返回闭包实例，而lambda函数捕捉列表，其实就是仿函数中带参数的构造函数，通过构造函数来初始化成员变量。
   - 注意
     - lambda是const的，需要通过mutable指定修改
     - 常用于内嵌，对变量进行状态监控，使得代码可读性更好
   - [capture] （parameters） mutable ->return-type {statement};
        ```
        int a = 1;
        int b = 2;
        auto func1 = [&](int c) {b = a + c;};
        auto func2 = [a, b](int c) mutable->int {return b += a + c;};
        ```
9. 说一下C++左值引用和右值引用
   - 左值与右值
        左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值
        右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。
   - 左值引用与右值引用
        左值引用：传统的C++中引用被称为左值引用
        右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置
   - 右值引用特点
     - 生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去
     - 右值引用类型的变量可能是左值也可能是右值
        int&& var1 = 1; var1是具名变量，是左值
     - T&& t在发生自动类型推断（模板类型自动推导，auto*类型推断大致就是左值右值const引用等等，太繁琐就没仔细看*）的时候，它是未定的引用类型。用左值初始化就是左值，用右值初始化就是右值
   - 右值引用的作用
     - 移动语义
       - 带有指向堆内存的指针的类的拷贝构造函数必须是深拷贝类型的，这会导致在拷贝的过程中，产生临时的类对象，这样就有额外的构造函数和析构函数的开销。
       - 右值引用就可以避免临时对象导致的额外的性能损失，即通过移动构造函数避免临时对象的构造
            ```
            A(const A& a):m_ptr(new int(*a.m_ptr)){} //深拷贝避免指针悬挂
            A(A&& a):m_i(a.m_i){a.m_ptr = nullptr;} //移动构造函数
            int main(){
                A a = Get(false); 函数返回值为右值，匹配到移动构造函数
            }
        - 普通的左值也能借助移动语义来优化，调用std::move
            std::list< std::string> t = std::move(tokens);  //这里没有拷
     - 完美转发
        函数模板可以将自己的参数“完美”地转发给内部调用的其它函数，保证被转发参数的左、右值属性不变
   - 举例
        int&& j = getInt();右值
        int& b = a;  //b是左值引用
        int& c = 10;  //错误，c是左值不能使用右值初始化
        int&& d = 10;  //正确，右值引用用右值初始化


### 5. C++STL标准模板库
#### 5.1 综合问题
0. 注意考虑不同的容器区别时，应针对
   - 逻辑结构（功能）
   - 底层存储结构
   - 查询和删除效率
   - 迭代器区别与失效情况
1. C++中标准库是什么？
    - 标准函数库
        这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。
        输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数
    - 面向对象类库
        这个库是类及其相关函数的集合。
        标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库
2. 什么是STL标准模板库？
   - C++ STL从广义来讲包括了三类：算法，容器和迭代器。
   - 算法包括排序，复制等常用算法，以及不同容器特定的算法。
   - 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。
   - 迭代器就是在不暴露容器内部结构的情况下对容器的遍历
3. 解释一下什么是trivial destructor
    - “trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数如果申请了新的空间一定要显式的释放，否则会造成内存泄露
4. STL迭代器如何实现
   - 迭代器的作用就是提供一个解容器内部原理的情况下遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与->运算符，以及++、--等可能需要重载的运算符重载
   - 最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly
5. 迭代器：++it、it++哪个好，为什么
   - 前置返回一个引用，后置返回一个对象
        // ++i实现代码为：
        int& operator++()
        {

            *this += 1;
            return *this;

        } 
   - 前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低
        //i++实现代码为：                 
        int operator++(int)                 
        {
        int temp = *this;                   

        ++*this;                       

        return temp;                  
        } 
6. 简单说一下traits技法
    traits即特性萃取技术，提取“被传进的对象”对应的返回类型，让同一个接口实现对应的功能。因为STL的算法和容器是分离的，两者通过迭代器链接。算法的实现并不知道自己被传进来什么。萃取器相当于在接口和实现之间加一层封装，来隐藏一些细节并协助调用合适的方法
7. STL的两级空间配置器
   - 原因
        频繁的在堆开辟释放内存，则就会在堆上造成很多外部碎片。内存分配器在找不到合适内存情况下需要合并空闲块，降低效率
   - 方式
        当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。大于128字节则调用一级空间配置器
   - 一级配置器
     - 实际以malloc()，free()，realloc()等C函数执行实际的内存配置。
     - 流程：直接allocate分配内存，其实就是malloc来分配内存，成功直接返回，失败产生异常。用户有自定义异常处理的化就调用处理函数
   - 二级配置器
        allocate 包装 malloc，deallocate包装free。通过哈希桶加自由链表实现的内存池来分配内存
        - 维护16条链表，8~128字节，以8字节递增。传入所需要的内存大小，映射到对应链表。如果对应自由链表不为空，则从中取出内存块。
        - 链表为空则查看内存池是否为空，如果内存池不为空，查看剩余空间是否够20个节点大小，如果足够则将1个分配给用户，其余挂到相应的自由链表下。
        - 如果不够20个大小，查看是否至少有1个，将其分配给用户，其余挂到相应的自由链表下。
        - 如果一个都没有，则二级空间配置器会使用malloc()从heap上申请内存，申请40块，一半拿来用，一半放内存池中。
        - 如果malloc()失败则从其他内存块较大的链表上拔除一个来使用。
        - 如果这都没有，就调用一级适配器
   - 缺点：
        - 内部碎片：因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节
        - 占用内存空间：内存池申请的所有内存只有在进程结束才会释放内存，还给操作系统。导致其他进程无法使用内存
8.  STL中的allocator、deallocator
    - 主要用在二级配置器上，大于128bytes调用一级配置器，否则调用二级配置器，具体过程见上
    - 空间配置函数allocate()
    - 空间释放函数deallocate()
9.  如何在共享内存上使用STL标准库？
9. STL中的allocator、deallocator
    - 主要用在二级配置器上，大于128bytes调用一级配置器，否则调用二级配置器，具体过程见上
    - 空间配置函数allocate()
    - 空间释放函数deallocate()
10. 如何在共享内存上使用STL标准库？
    使用map映射的方式。进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址
11. 容器内部删除一个元素
   - 顺序容器（序列式容器，比如vector、deque）
        erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；
        It = c.erase(it);
   - 关联容器(关联式容器，比如map、set、multimap、multiset等)
        erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；
        c.erase(it++)
12. 常见容器性质总结？
    - vector 底层数据结构为数组 ，支持快速随机访问
    - list 底层数据结构为双向链表，支持快速增删
    - deque是一个双端队列(double-ended queue)，支持首尾（中间不能）快速增删，也支持随机访问.**在堆中保存内容的**.它的保存形式如下:[堆1] --> [堆2] -->[堆3] --> ...每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.
    - stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
    - queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
    - priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
    - set 底层数据结构为红黑树，有序，不重复
    - multiset 底层数据结构为红黑树，有序，可重复
    - map 底层数据结构为红黑树，有序，不重复
    - multimap 底层数据结构为红黑树，有序，可重复
    - unordered_set 底层数据结构为hash表，无序，不重复
    - unordered_multiset 底层数据结构为hash表，无序，可重复
    - unordered_map 底层数据结构为hash表，无序，不重复
    - unordered_multimap 底层数据结构为hash表，无序，可重复
13. 说一下STL每种容器对应的迭代器
    - vector、deque	随机访问迭代器（在常量时间内访问容器任意位置，比双向迭代器更强大，可<，>）
    - stack、queue、priority_queue	无
    - list、(multi)set/map	双向迭代器（从两个方向读写容器，可--，++）
    - unordered_(multi)set/map、forward_list	前向迭代器（只会以一个方向遍历序列）
14. STL中迭代器失效的情况有哪些？
    - vector（原因是vector是顺序存储结构而list是链式存储结构）
      - 尾后插入：size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。
      - 中间插入：中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。
      - 尾后删除：只有尾迭代失效。
      - 中间删除：删除位置之后所有迭代失效。
    - deque 
      - 和 vector 的情况类似
    - list
      - 双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器
    - map/set等
        关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);
    - unordered_(hash) 
        迭代器意义不大, rehash之后, 迭代器应该也是全部失效
15. vector的实现（和array的区别）
    - 对于空间运用的灵活性不同
    - array占用的是静态空间，不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放
    - vector则使用灵活的动态空间配置，维护一块连续的线性空间，在空间不足时，可以自动扩展空间容纳新元素，需要经历重新配置空间，移动数据，释放原空间等操作。动态扩容的规则：以原大小的两倍配置另外一块较大的空间（
    - 频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响 
17. STL中的deque的实现
    - deque则是一种双向开口的连续线性空间，由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性。deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes
    - deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque 
18. STL中slist（forward_list）的实现 
    slist为单向链表和list双向链表区别在于前者的迭代器是单向的前向迭代器，只支持在头部插入数据push_front()。元素插入到slist后，存储的次序和输入的次序是相反的。1<-2<-3<-4<-5
19. STL中list的实现
    list是链式存储结构，插入或删除都只作用于一个元素空间，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器。此外list也是一个环形链表，因此只要一个指针便能完整表现整个链表。
20. STL中stack的实现
    - stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，不提供迭代器。
    - stack这种单向开口的数据结构很容易由双向开口的deque和list形成，只需要根据stack的性质对应移除某些接口即可实现
        stack<int, deque<int>>
        stack<int, list<int>>
    - 不被归为容器，而是一种容器配接器(container adapter)
21. STL中queue的实现
    - queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素,不提供迭代器。
    - queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现
    - 不被归为容器，而是一种容器配接器
22. STL中的priority_queue的实现
    - priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面
    - priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。
    - priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器
23. STL中set的实现
    - STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。所有元素都会根据元素的值自动被排序（默认升序）,不允许有两个相同的键值,不允许迭代器修改元素的值，其迭代器是一种constance iterators
    - 底层采用红黑树实现
24. STL中map的实现
    - map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key。一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的valu
    - 标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map
25. STL中string的实现
    - string是C++风格的字符串，而string本质上是一个类，类内部封装了char*，管理这个字符串，是一个char型的容器。
    - 存储结构为顺序表，可以动态扩展
    
#### 5.2 vector，list，queue
1. vector与list的区别？
   - 内存分配方式不同
        vector内存空间是连续的，list内存空间是不连续的。vector一次性分配好内存，不够时才进行2倍扩容；listlist内存空间是不连续的。
   - 随机访问效率不同
        vector:O(1), list:O(n)
   - 插入和删除效率不同
        vector：O(n), list:O(1)
   - 迭代器失效场景不一样
        vector在插入和删除时可能会导致迭代器失效；list在删除的时候会导致当前迭代器指向的结点失效
2. vector与deque的区别
   - 内存分配方式不同
        vector内存空间是连续的，而deque是动态地以分段连续空间组合而成，段与段之间不一定连续
   - 插入和删除效率不同 
        deque对于头端元素的插入和删除效率是O(1)，而vector是O(n)
3. list与deque的区别
   - 内存分配方式不同
   - 随机访问效率不同
   - 插入和删除效率不同
   - 迭代器失效场景不一样
4. vector如何扩容？为什么是1.5或者是2倍？
   - 新增元素
     vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；
   - 原因
      采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。
5. vector如何删除？
   - pop_back()删除最后一个元素.
   - 成员函数erase()可以删除由一个iterator指出的元素，也可以删除一个指定范围的元素。
   - 通用算法remove()来删除vector容器中的元素
   - 不同之处
        remove不会改变容器的大小，将待删除元素之后的元素移动到vector的前端而不是真的删除，返回未被删除的元素的下一位的迭代器。而pop_back()与erase()等成员函数会改变容器的大小。
        一般组合使用，如vec.erase(remove(vec.begin(), vec.end(), 10), vec.end());
6. Vector如何释放空间?
    - vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。
    - 如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。
        vector(Vec).swap(Vec); //将Vec的内存清除；  
        vector().swap(Vec); //清空Vec的内存；
7.  vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？
    - 通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。
    - map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某人值插入这个map。
    - erase()函数，只能删除内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器

#### 5.2 set，map
1.  STL中hashtable的实现？(STL中hash table扩容发生什么？)
    STL中的hashtable使用的是开链法解决hash冲突问题。hash table表内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器是具有动态扩容能力的vector容器。而每一个节点都对应一个自由链表。如果插入hashtable的元素个数超过了桶的容量，就要进行重建table操作，即找出下一个质数，创建新的vector，重新计算元素在新hashtable的位置。
2. hashtable中解决冲突有哪些方法？
   - 线性探测
     - 使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位
     - 优点：节省空间
     - 缺点：需要处理溢出，容易产生堆聚现象（存入哈希表的记录在表中连成一片），会更容易导致冲突
   - 开链
     - 每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中
     - 优点：处理冲突简单，无堆聚，即非同义词决不会发生冲突；各链表上的 结点空间是动态申请的 ，故它更适合于造表前无法确定表长的情况；
     - 缺点：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间
   - 再散列
        发生冲突时使用另一种hash函数再计算一个地址，直到不冲突
3.  map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？
    
#### 5.2 set，map
1.  STL中hashtable的实现？(STL中hash table扩容发生什么？)
    STL中的hashtable使用的是开链法解决hash冲突问题。hash table表内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器是具有动态扩容能力的vector容器。而每一个节点都对应一个自由链表。如果插入hashtable的元素个数超过了桶的容量，就要进行重建table操作，即找出下一个质数，创建新的vector，重新计算元素在新hashtable的位置。
2.  map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？
    - 在这里我们定义了一个模版参数，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value
    - 因为map和set要求是自动排序的，红黑树能够实现这一功能，而且插入删除等操作都在O(logn时间内完成，因此可以完成高效的插入删除
4. set和map的区别
    - Map是键值对，Set是值得集合，当然键和值可以是任何的值；
    - Map可以通过get⽅法获取值，⽽set不能因为它只有值；
    - 都能通过迭代器进⾏for...of遍历；
    - Set的值是唯⼀的可以做数组去重，Map由于没有格式限制，可以做数据存储
5. map/multimap,set/multiset的区别
    multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样
6. STL中unordered_map和map的区别和应用场景
   - 功能不同，底层机制不同，查询和维护时间不同，空间占用不同
   - map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为$O(logn)$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息
   - unordered_map底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大
   - 从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景
7. map插入方式有哪几种？
    - 用insert函数插入pair数据，
        mapStudent.insert(pair<int, string>(1, "student_one")); 
    - 用insert函数插入value_type数据
        mapStudent.insert(map<int, string>::value_type (1, "student_one"));
    - 在insert函数中使用make_pair()函数
        mapStudent.insert(make_pair(1, "student_one")); 
    - 用数组方式插入数据
        mapStudent[1] = "student_one";
8. map中[]与find的区别？
   - map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。
   - map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器

9.  STL中unordered_map(hash_map)和map的区别
    - 性质不同
        unordered_map不会根据key的大小进行排序
    - 底层结构不同
        unordered_map的底层实现是hash_table;map底层结构是红黑树
    - 需要重载的运算符不同
        map的key需要定义operator<。而unordered_map需要定义hash_value函数并且重载operator==。

10. hash_map如何解决冲突以及扩容
    - hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。
    - 扩容(resize)就是重新计算容量，当HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素
#### 5.3 string
1. C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？
    - string继承自basic_string,其实是对char*进行了封装，封装的string包含了char\*数组，容量，长度等等属性。
    - string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。
2.  你知道const char* 与string之间的关系是什么吗？
    string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化
    const char* c_s = s.c_str();
    string s(c_s);