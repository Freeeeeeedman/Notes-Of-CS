#### C++面经总结
#### 1. C++基础
1. 在main执行之前和之后执行的代码可能是什么？
   - main函数执行之前，主要就是初始化系统相关资源
     - 初始化静态static变量和global全局变量，即.data段的内容
     - 全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
     - 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容
     - 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
     - __attribute__((constructor))   
   - main函数执行之后，主要是释放一些系统资源
     - 全局对象的析构函数会在main函数之后执行；
     - 可以用 atexit 注册一个函数，它会在main 之后执行;
     - __attribute__((destructor))  
2. 结构体内存对齐问题
   - 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
   - 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）
   - 对齐的目的是
     - 硬件原因
        不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
     - 性能原因
        为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需一次访问
   - c++11以后引入两个关键字 alignas (opens new window)与 alignof (opens new window)。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式
3. 指针和引用的区别
   - 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
   - 指针可以为空，引用不能为NULL且在定义时必须初始化
   - 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
   - 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
   - sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
4. 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？
   - 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。
   - 类对象作为参数传递的时候使用引用，对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
5. 堆和栈的区别
   - 申请方式不同
        堆是自己申请和释放的，栈由系统自动分配
   - 空间大小不同
        堆是不连续的内存区域，受限于计算机系统中有效的虚拟内存（32位 4G）
        栈是一块连续的内存区域，大小固定，过ulimit -a查看，由ulimit -s修改
   - 管理机制不同
        堆由链表管理，当在堆中申请空间时，操作系统首先从空闲链表中找到第一个空间大于“申请空间”的节点，将其分配。多余的部分，系统自动放回空闲链表。在这块内存空间首地址处记录分配的大小，如此，之后的delete()才能正确释放内存空间。
        只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出
   - 碎片问题
        对于堆，频繁的new/delete会造成大量碎片，使程序效率降低
        对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。
   - 生长方向不同
        堆向上，向高地址方向增长。	栈向下，向低地址方向增长。
        (堆从低向高扩展，方便内存管理。栈从高向低是为了最大程度利用地址空间，否则必须指定栈堆的分界线，会导致分配不均。同时高向低也确定了栈空间的起始位置，避免了动态扩展栈空间时需要移动整个栈的数据
   - 分配效率不同
        堆由C/C++函数库提供在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。
        而计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。
        所以堆的效率比栈低很多
6. 区别以下指针类型？
    int *p[10]:指针数组，数组内每个元素都是指向int类型的指针变量
    int (*p)[10]:数组指针，指针类型，指向的是一个int类型，大小是10的数组
    int *p(int)：函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
    int (*p)(int)：函数指针，指向的函数具有int类型参数，并且返回值是int类型的
    const int *p1 = &a;或者 int const *p1 = &a指针常量（指向常量的指针），指针常量不可修改其指向地址的值
    int *const p2 = &a;常量指针，指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化
7. new / delete 与 malloc / free的异同
   - 相同点
        都可用于内存的动态申请和释放
   - 不同点
     - 前者是C++运算符，后者是C/C++语言标准库函数
     - new自动计算要分配的空间大小，malloc需要手工计算
     - new是类型安全的，malloc不是。因为malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。例如：
        int *p = new float[2]; //编译错误
        int *p = (int*)malloc(2 * sizeof(double));//编译无错误
     - new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者不具有调用构造函数和析构函数功能
     - new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象
8. new和delete是如何实现的？
   - new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针
   - delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存
9. 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？
    动态创建对象时，malloc/free可以申请内存和回收内存，但无法指向构造函数和析构函数。会导致内存泄露。
10. 被free回收的内存是立即返还给操作系统吗？
    不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片
11. 宏定义和函数有何区别？
    - #define PI 3.1415926,  #define A(x) x
    - 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
    - 宏定义没有返回值；函数调用具有返回值。
    - 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
    - 宏定义不要在最后加分号
12. define宏定义和typedef区别？
    - 作用
        宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名
    - 编译阶段
        宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分
    - 安全性
        宏不检查类型；typedef会检查数据类型
    - 在有指针的场景不一样
        typedef char *pStr1;
        #define pStr2 char *;
        pStr1 s1, s2;
        pStr2 s3, s4;
        s1、s2、s3都被定义为char *，而s4则定义成了char
13. define宏定义和const的区别
    - 编译阶段
        define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用
    - 安全性
        define只做替换，不做类型检查和计算
        const常量有数据类型，编译器可以对其进行类型安全检查
    - 内存占用
        define只是将宏名称进行替换，在内存中会产生多份相同的备份。const在程序运行中只有一份备份但要分配内存空间
14. 变量声明和定义区别？
    - 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
    - 相同变量可以在多处声明（外部变量extern），但只能在一处定义。
15. strlen和sizeof区别？
    - sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
    - sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。
    - 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。
16. 一个指针占多少字节？
    在64位的编译环境下的，指针的占用大小为8字节；而在32位环境下，指针占用大小为4字节。一个指针占内存的大小跟编译环境有关，而与机器的位数无关。
17. int a[10] 中a和&a有什么区别？
    - 假设数组int a[10]; int (*p)[10] = &a;其中：
        a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。
        &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
        若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。
18. 数组名和指针（这里为指向数组首元素的指针）区别？
    - 数组名是常量指针，不能自增自建，但指向数组首元素的指针是变量指针
    - 数组名取地址得到的是数组名所指元素的地址。 对指针取地址得到的是指针变量自身的地址。
    - 当对数组名使用sizeof时，得到的是数组元素的个数乘元素类型的字节数，对指针sizeof得到的是指针类型的字节数
19. C++和Python的区别
    - Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。
    - Python使用缩进来区分不同的代码块，C++使用花括号来区分
    - C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等
    - Python的库函数比C++的多，调用起来很方便。比如在数据处理中。
20. C++和C语言的区别
    - C++是面向对象的，而C是面向过程的。c++支持面向对象程序设计、泛型程序设计等多种程序设计风格，而C没有类似的概念
    - C++中取代很多C中原有的功能
        C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。
        标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。
        C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。
        C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。
    - C++允许重载，而C不允许
    - C++增加了引用，而C没有
    - C++中存在命名空间的概念用于区分不同作用域的同名变量，而C没有命名空间的概念
21. C++中struct和class的区别
    - 相同点
        两者都拥有成员函数、公有和私有部分
        任何可以使用class完成的工作，同样可以使用struct完成
    - 不同点
        两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
        class默认是private继承， 而struct默认是public继承  
22. C++和C的struct区别
     - C：struct是用户自定义数据类型（UDT）；C++：struct是抽象数据类型（ADT），也可以用于自定义结构体类型。
     - C：struct没有权限，C++：有权限，支持继承，多态，以及成员函数的定义
     - C：typedef struct A{}; C++： struct A{}；
23. C++中static的作用
    - static
      - 不考虑类的情况
        - 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
        - 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
        - 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能被别的函数使用
      - 考虑类的情况
        - static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
        - static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问
24. C++中const的作用
    - 不考虑类的情况
        - const常量在定义时必须初始化，之后无法更改
        - const形参可以接收const和非const类型的实参，和引用结合时可以防止修改被引用的对象
    - 考虑类的情况
        - const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；类的不同对象对其const数据成员的值可以不同，所以不能在类中声明时初始化
        - const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值
    - 补充一点const相关：const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。 因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。
25. C++的顶层const和底层const
    - 顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边
    - 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边
    - 顶层：const int a;int const a;int *const a;
    - 底层：const int *a;
26. final和override关键字
    - override：指定子类的虚函数必须是重写的父类的，如果父类没有对应的虚函数，编译器会报错
    - final：当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错
        void foo() override; class B final : A{};
27. 拷贝初始化和直接初始化
    直接初始化直接调用与实参匹配的构造函数
    拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象
        string str1("I am a string");//语句1 直接初始化
        string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化
        string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
        string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
28. 初始化和赋值的区别
    - 对于简单类型来说，初始化和赋值没什么区别
    - 对于类和复杂数据类型来说，这两者的区别就大了
       A a1 = a; 
       A b;  b = a;
       创建对象时初始化，分为直接初始化和拷贝初始化，使用"="的为拷贝初始化。分分布会调用构造函数和拷贝构造函数。而对于赋值，是在对象创建以后，在通过赋值擦除原值。如果重载了operator=，则会调用该重载
29. extern"C"的用法
    正确的在C++代码中调用C语言的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；
    extern "C" {

    }
30. 野指针和悬空指针
    - 野指针，指的是没有被初始化过的指针，为了防止出错，对于指针初始化时都是赋值为 nullptr
    - 悬空指针，指针最初指向的内存已经被释放了的一种指针
31. C和C++的类型安全
    - 类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。类型安全的编程语言与类型安全的程序之间，没有必然联系。
    - C是类型不安全的，比如malloc函数的返回值是空类型指针，如果我们使用显式的类型转换会产生问题，但是C并不会报错char* pStr=(char*)malloc(100*sizeof(char))
    - C++相对于C提供了一些新的机制保障类型安全
      - 操作符new返回的指针类型严格与对象匹配，而不是void*
      - C++模板函数支持类型检查
      - C++提供了dynamic_cast关键字，使得转换过程更加安全
32. 
#### 3. C++新特性

#### 4. C++泛型编程