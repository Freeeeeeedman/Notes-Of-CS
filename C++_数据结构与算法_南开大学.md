[toc]
#数据结构与算法_南开大学
####模块化
1. 编译预处理
   - 定义
      编译程序前的处理，以#开头，末尾无分号
   - 包括
     - 文件包含
       - 系统头文件`#include <iostream>`
       - 自定义头文件`#include "test.h"`
     - 宏定义
       - 将程序中出现的宏名替换为它所对应的**字符串**
       - 无参宏定义"#define PI 3.1415926"
       - 有参宏定义"#define 宏名(形参表) 字符串"，使用：宏名(实参表)
         - 用实参替换宏定义的字符串中相应的形参
         - 再将替换后的字符串替换程序中的"宏名(实参表)"
         - 类似函数
     - 条件编译
       - 对某段代码有条件地参与编译或者不参与编译
        ```
        #ifdef 标识符
                程序段1
        [#else
                程序段2]
        #endif
       
        #ifndef 标识符
                程序段1
        [#else
                程序段2]
        #endif
        
        #if 表达式
                程序段1
        [#else
                程序段2]
        #endif
        ```
       - **利用无参宏编译和条件编译对象调试信息的显示控制** 
2. 多文件结构
   - 定义
    将同一类功能的函数，变量定义放在同一文件中，不同类功能放在多个文件中
   - 优点
     - 结构清晰，管理查找方便
     - 没有访问冲突
   - 头文件
     - 数据类型的定义：结构体，枚举等
     - 自定义函数的函数声明
     - 符号常量定义或宏定义`const int N=100;`
     - 全局变量的外部声明：`extern int g_num[N];`
     - **内联函数的定义**
       - 内联成员函数包括构造是对于当前文本可见
     - 其他头文件
     - 不含有函数定义
   - 源文件
     - 函数定义
     - 全局变量定义`int g_num[N];`
   - 防止重复定义
     - 方位式声明















####面向对象概念
1. 定义
   - 面向对象方法是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构造系统的软件开发方法
2. 对象
   - 静态特征
   - 动态特征
3. 类
   - 属性
   - 方法
4. 实例
5. 消息
   - 对象之间进行通信的机制，就是向对象发出的操作请求
6. 封装
   - 将对象的属性和方法结合构成一个独立实体并对外屏蔽内部细节
   - 有清晰的边界
   - 有确定的接口
   - 受保护的内部实现
7. 继承
   - 单继承
   - 多继承
   - 多重继承：传递性
8. 多态性
   - 在具有继承关系的类层次结构中可以定义同门的属性或方法，但不同层次的类的确可以按照各自的需求实现这个不一定相同的行为
9. 聚合
   - 一个对象由多个对象聚集而成，整体与部分的关系
   - 可分离，有各自的生命周期
10. 组合
    - 同样是整体与部分的关系
    - 不可分，同样的生命周期


####类
1. 定义
   - 类目，属性，方法
   - 数据成员(成员数据)
   - 成员函数(函数成员)
2. 语法格式
```
class<..>{
public:
private:
protect:
};//不要忘记类定义最后的分号；
```
3. 构造函数
   - 自动调用初始化对象
   - 可以被重载
   - 特点
     - 函数名必须与类目相同
     - 无返回类型，void也不行
     - 自动调用
     - 没有写时系统自动创造无参构造函数
4. 对象的定义
   - 类是用户自定义的数据类型，对象是定义类的变量
   - 定义对象的过程叫做类的实例化
   - 有初始值`Circle circleA;`
   - 无初始值`Circle circleB(2,2,12.5);`
5. 对象的访问
   - 对象名+“.”成员名(实参)
   - 对象指针+“—>”成员名(实参)
   - 消息机制即调用成员函数
   - 直接访问(破坏封装性)
   - 通过向对象发出消息访问
6. 类成员的访问控制
   - 类成员的访问控制实现了类的封装性
   - 公有成员public
     - 在程序的任何地方都可以被访问
     - 一般是接口函数
   - 私有成员private
     - 只能被该类的成员函数或该类的友元函数访问
     - 一般是数据成员
     - 实现封装
   - 保护成员protect
     - 只能在该类的内部或其派生类中使用
     - 可以被继承
   - 分别可以出现多个，没有顺序限制，默认为private成员
7. 析构函数
   - 函数名:~<classname>
   - 无返回类型
   - 无参数，所以不能被重载
   - 类声明时没有给出时，系统自动创造~<classname>(){}
   - 对象生命周期结束或者delete时系统自动调用
   - 释放空间或者实现最后一次使用对象后的任何操作
8. 拷贝构造函数
   - <cn>(<cn>&on)
   - 使用以及存在的对象来初始化新对象
   - 新参只有一个为对象的引用，无法重载
   - 无返回类型
   - 没有定义时系统默认给出，对位拷贝，浅拷贝
     - 有指针时，对位拷贝指向同一空间会出现内存泄漏
   - 何时自动调用
     - Circle circle1(circle2);Circle circle1=circle2;
     - 实参形参结合时
     - 函数返回值为类的对象时
9. 类声明与类实现的分离
   - 类声明描述类的结构".h"
   - 类实现定义成员函数的具体功能".cpp"
     - <函数类型><类名>::<函数名>(<形参数表>){函数体}
     - ::作用域运算符
   - 显得明晰
10. 类的静态成员
   - 静态数据成员属于类而非对象，所有对象共享
   - 数据成员
     - static
     - 类内声明，但需要在类外定义静态数据成员，且只能出现一次，不需要再加static
     - 最好放在类实现文件中
   - 静态成员函数
     - 访问私有静态数据成员的接口
     - 不能访问非静态成员函数
       - 为什么？:静态成员函数没有this指针
     - 通过构造和析构函数维护静态数据成员
     - 公有访问形式
       - <类名>::<静态成员函数名>([实参])
       - <对象名>.<静态成员函数名>([实参])
       - <对象指针>—><静态成员函数名>([实参])
11. 类的常量成员
    - 常量数据成员
      - 声明时不能被赋值，只有再定义对象时才能通过构造函数初始化，且之后不允许再被修改
    - 常量成员函数
      - 只有权读取对象的数据成员
      - <><>(<>)const
      - 类外定义时不可省略const
12. this指针
    - this指针是隐含于非静态成员函数中的特殊指针
    - 当一个对象调用非静态成员函数时，this就指向这个对象
    - 显式使用
        - 函数形参名与对象数据成员名相同时，this->a
        - 返回对象或对象地址
13. 类的友元
    - 定义
        - 友元提高了一般函数与类成员，不同类成员之间进行数据共享的机制
        - 提高程序运行效率
    - 类型
        - 友元函数：friend<type><funcname><paras>
        - 友元成员：friend<type><friendclassname>::<funcname>(paras)
        - 友类: friend<fcn>,friend class<fcn>
    - 类声明:使用其他类时先声明，记得传递引用
14. 类的对象成员
    - 聚合，组合，属于：数据成员味另一个类的对象
    - 对象成员的初始化
        - 是那个构造函数特有的初始化方法
    - 对对象成员的私有成员不可以直接调用
15. 自定义类的运算符重载
    - 关键字opeartor以及运算符+
    - 五种不能重载的运算符
        - 类属关系运算符 .
        - 成员指针运算符 .* ->* (指向一个类中某个成员的指针)
        - 作用域运算符 ::
        - sizeof运算符
        - 三目运算符 ？:
    - 特点
        - 不能创建新的运算符
        - 实质为函数重载
        - 不能改变优先级和结合性
        - 大部分运算符可以定义为类的成员函数或者友元函数
    - 成员函数运算符
        - <对象名><运算符><参数>
        - 实质<对象名>operator<运算符>(<参数>)，没有少参数，两个操作数
         `complex& operator += (const complex&);`
    - 友元函数运算符
        - 没有this指针，实质是opeartor<运算符>(<参数1>，<参数2>);
        - `friend complex& operator+ (complex &, const complex&);`
    - ？选择标准
        - 单目成员函数，双目友元函数
        - 以下双目只能重载为成员函数：=,(),[],->
        - 需要修改对象成员函数
        - 操作数有隐式类型转换友元函数
        - 最左边的操作数必须是类的对象或者该类对象的引用运算符时，成员函数
        - 最左边的操作数必须是不同类的对象或者内部类型的对象，友元函数(无this指针)
        - 具有可交换性，友元函数形式
16. 继承
    - 定义
        - 基类(父类)，派生类(子类)
        - 继承基类所有属性和方法并定义派生类特有属性和方法
    - 语法
         class 派生类名:继承方式 基类名
         {
            派生类成员声明
         };
    - 访问控制
        - 取决于 
          - 该成员在基类中的访问控制方式
          - 定义派生类所采用的继承方式

         |左继承上原成员|public|private|protect|
         |:-:|:-:|:-:|:-:|
         | public|public |不可直接访问|protected|
         | private|private |不可直接访问|private|
         | protected|protected |不可直接访问|protected|
    - 函数重定义
    - 派生类的构造函数与析构函数
        - 初始化/清除派生类中新添加的数据成员
        - 构造函数:先基后派
            派生类名(形参):基类名(实参)     后面不写等价于调用无参的构造函数
            {
               派生类中数据成员初始化
            }
            同时初始化基类：可以将派生类构造函数的形参，以及常量，全局变量等作为实参传递给基类构造函数l
        - 析构函数:先派后基
            ~派生类名()
    - 多继承
        - 语法
            class 派生类名:继承方式 基类名1，继承方式 基类名2
            {
               派生类成员声明
            };
        - 调用构造函数的顺序和继承顺序一致，析构函数相反
        - 二义性问题(菱形继承，即次级基类有共同基类)
          - 例：B,C类继承A类，D继承B,C类，那么D中会有两份A类的成员，调用时会报错
          - 虚拟继承和虚基类
               class 派生类名:virtual 继承方式 虚基类名{...}
              - 虚基类中的成员在类的继承关系中只会被继承一次，D只会继承一份A
              - 必须显式写出A类的初始化
               ```
               class B: virtual public A{...};
               class C: virtual public A{...};
               class D: public B,public C
               {
                  public:
                     D(...,int x,int y):B(...),C(...),A(x,y){}
                  ...
               }
          - 如果不是菱形继承，只是多个基类有同名成员，那么这个时候需要在成员名字前面加上类名和域解析符::，以显式地指明到底使用哪个类的成员，消除二义性。
17. 多态
    - 类型兼容
        - 指在基类对象可以出现的任何地方都可以用公有派生类的对象来替代
        - 可以用派生类对象为基类对象赋值
        - 可以用派生类对象初始化基类引用
        - 可以用派生类对象地址为基类指针赋值
        - 用派生类对象替代基类对象进行赋值操作后，通过基类对象，基类引用和基类指针**只能**访问派生类从基类继承的成员
    - 多态性
        - 定义：能够根据**指针**或**引用**所表示的对象的实际类型来调用该对象所属的类的函数，而不是每次都调用基类的函数的特性为多态性
        - 操作中使用相同函数进行统一处理
        - 绑定:建立函数调用和函数本体的关联
        - 先期绑定(静态绑定):绑定发生在程序运行前
        - 后期绑定(动态绑定):绑定发生在程序运行中
    - 虚函数
        - 实现动态绑定，基类函数加上virtual关键字
        - 具有继承性，基类函数为虚函数，派生类无论加不加virtual都是虚函数
        - 只有使用基类的指针或引用调用虚函数才能实现多态性，如果使用对象调用虚函数，则会调用基类的函数
18. 抽象类
    - 具体类
      - 实例化为对象
    - 抽象类
      - 仅仅表现概念，不可以实例化为对象(编译器会报错)
      - 用途：定义子类所共有的属性和方法，并作为子类的基类  
    - 纯虚函数
      - 如果一个类是抽象类，则至少有一个成员函数为纯虚函数
      - `virtual <类型>纯虚函数名(<参数表>)=0;`


####模板
1. 模板
   - 定义:模板是参数化的函数或类，将数据类型作为参数
   - 算法，通用
   - 分为函数模板和类模板
2. 泛化编程
     - 对抽象的算法的编程
     - 泛化指可以广泛适用于不同的数据类型
3. 函数模板
   - 定义
    用来描述一个与数据类型无关的函数(算法)，避免重载函数时函数体的重复设计
   - 语法
    template<<模板形参表>><函数类型><函数名>(<函数形参表>){函数体}
    `template <typename T> T Max(T a,T b)`
   - 模板函数
     - 实例化的函数模板
     - 调用时由编译器自动生成模板函数，根据传入的数据类型指定类型
     - 一般放在头文件，方便编译器寻找并调用
   - 与重载函数的区别
     - 重载函数各函数体内可以执行不同的代码
     - 函数模板执行相同代码，仅仅是数据类型相同
   - 函数模板与一般函数同名时
     - 首先寻找参数完全匹配的一般函数，找到就调用
     - 再寻找函数模板，使其实例化，生成一个匹配的模板函数，再调用该模板函数
4. 类模板
   - 定义
     - 用来描述一组与数据类型无关的类
     - 数据成员，函数成员的参数和返回值可以被模板化
     - 是一组类的统一描述
   - 语法
      template<<模板形参表>>
      class<类模板名>{类体};
      ```
      template<typename T,int length>
      class Array{...};

   - 类模板的成员函数在类模板外定义
      template<<模板形参表>>
      函数类型<类模板名><类型形参名表>::<成员函数名>(函数形参表){...};
      ```
      template<typename T,int length>
      void Array<T,length>::SetElement(T,x){...}
      ```
   - 在函数体内
      `Array<T>& Insert(...);`
   - 模板类
      类模板的实例化必须由程序员在程序中显式指定，其中类型实参表必须与模板中模板形参表数目，顺序，类型相同
      <类模板名><<模板形参表>><对象名表>
      `Array<int,10> a;`
   - 注意
     - 类模板成员函数也是模板但只有在它被调用时才实例化，类模板被实例化时它并不自动实例化
     - 类模板的声明和类模板成员函数的定义应放在同一头文件中


####数据结构与算法
1. 数据结构基本概念
   - 数据结构
     - 数据结构是一门研究计算机的操作对象(数据元素)以及它们之间的关系和运算的学科
     - 数据结构是以数据为成员的结构，是带结构的数据元素的集合
   - 算法
     - 算法则是对计算机上执行的计算过程的具体描述
     - 设计取决于逻辑结构，实现依赖于存储结构
   - 联系
      算法依赖于具体的数据结构，数据结构也直接关系到算法的选择和效率
   - 数据
      所有能输入到计算机中并被计算机识别吗，储存和加工处理的符号
   - 数据元素
      数据的基本单位，简称元素
   - 数据项
      数据的不可分割的最小单位，又称数据域，数据元素是数据项的集合
   - 数据对象
      数据对象是指具体相同性质的数据元素的集合
   - 节点
      数据结构中的数据元素
   - 数据处理
      指对数据元素进行处理的方式，如增删改查排序等
   - **数据结构研究的问题**
     - 数据的逻辑结构:在数据集合中，各种元素之间固有的逻辑关系 
     - 数据的存储结构(物理结构):在计算机中，各数据元素的存储关系
     - 数据结构的操作:基于存储方式，如何实现各种数据结构要进行的操作
   - 数据的逻辑结构
     - 数据元素本身的信息
     - 各数据元素之间的关系
       - 前驱和后继
       - 二元关系表示:X=(D,R),D={a,b,c,d,...},R={<a,b>,<b,c>,<c,d>,...}
     - 线性结构
       - 数据元素之间存在一对一的线性关系
       - 特征
           1. 有且仅有一个没有前驱的结点，即根结点
           2. 只有根结点没有前驱和最后一个结点没有后继，其他都有且只有一个前驱和后继
           3. 插入或删除任何一个结点后还是线性结构
     - 非线性结构
       - 一个结点可能有多个前驱和后继
       - 树状结构
         只有树根结点没有前驱结点，叶子结点没有后继结点
       - 网状结构
         任一个结点都可以有一个或多个的前驱及后继结点
       - 集合结构
         只同属一个集合，结点之间不存在前驱和后继的关系
   - 存储结构(物理结构)
     - 逻辑结构的存储表示，依赖于具体的计算机程序
     - 同一种逻辑结构往往可以采用不同的存储方式，所以存储结构不仅要存放数据元素的数据信息也要存放关系信息
     - 顺序存储结构
        - 逻辑上相邻的数据元素，存储在物理位置也相邻的存储单元
        - 紧凑存储结构:不需要存储结点之间的关系信息，物理位置已经体系
     - 链式存储结构
        - 存储位置随意
        - 指针域:来体现结点间的逻辑关系
        - 适合于因经常进行插入，删除等操作而发生动态变化的数据结构
     - 索引存储结构
        - 大小不等的数据结点的顺序存储
        - 索引项:(关键字，地址)
     - 散列存储结构
        - 根据结点的关键字通过散列函数计算出该结点的存储地址
        - 散列函数:数据元素均匀分布在存储区内,散列函数指示存储位置
   - 数据的操作
     - 定义在逻辑结构上，具体实现在存储结构上
     - 基本操作
       1. 创建
       2. 清除
       3. 插入
       4. 删除
       5. 访问
       6. 更新
       7. 查找
       8. 排序
2. 抽象数据类型(Abstract Data Type,ADT)
   - 定义
     - 一个数学模型以及定义在此数学模型上的一组操作
     - 与具体的物理存储无关
     - 描述的是逻辑结构
   - 三元组表示(D,R,P)
      ADT<抽象数据类型名>
         {
            数据对象D:<数据对象的定义>
            数据关系R:<数据关系的定义>
            基本操作P:<基本操作的定义>
         }ADT<抽象数据类型名>
   - 描述
     - D,R用伪码描述
     - P定义格式
         基本操作名(参数表)
         初始条件:<初始条件描述>
         操作结果:<操作结果描述>
   - 意义
     - 对问题进行抽象和分解的思维工具
     - 将实习的外部特征和内部实现细节分离，对外部用户隐藏其内部实现的细节
3. 线性表(LinearList)
   - 数据元素可以有一个或多个数据项
   - 抽象数据类型
      ADT List
         {
            D=...
            R=..
            P:
               Create():
               Destroy():
               List& Insert(int k,const T& X):
               bool IsEmpy() const:
               int GetLength() const:
               bool GetData(int k,T& x):
               bool ModifyData(int k,T& x):
               int Find(T& x):
               List& DeleteByIndex(int k):
               List& DeleteByKey(T& x):
               void OutPut()const:
         }ADT List
   - 抽象数据类型可以直接通过**类**类型来实现(物理实现)
4. 顺序表(LinearList)
   - 定义
      采用顺序存储结构的线性表
   - 特点
      数组中每个元素的位置可以用公式计算出
   - 类模板
   - 操作
     - 插入删除等等：位置是否可行，表是否已满，再移动元素，在改变length
     - 删除by key可以通过结合Find()和删除by index()
   - 提示
     - C++的一个顺序表就是一个对象
     - 模板类的声明和实现应放在一个头文件中
   - 应用
     - 简单数据元素
     - 复杂数据元素
        - 将数据元素抽象为一个节点类Node
           - 单独头文件储存
        - 定义取数据GetNode()函数
        - 定义输出数据函数OutPutNode(ostream& out)
        - 需要重载插入运算符<<
        - 顺序表<<调用Node头文件重载<<的函数，再调用OutPutNode函数
   - 特点
     - 优点:简单，存储密度大，空间利用率高，存储效率高
     - 缺点:插入和删除时，需要移动大量数据元素，时间效率低
            实际应用中顺序表长度无法估计，需要分配足够大的内存空间造成浪费
     - 对于元素变动频繁，长度变化大的线性表，不宜采用顺序存储结构而应采用链式存储结构
5. 链表(LinkList)
   - 线性链表定义
      采用链式存储结构的线性表
   - 链式存储结构
      通过结点的指针域将n个结点按其逻辑结构连接在一起的数据储存结构
   - 存储结点
      - 数据域
      - 指针域
   - 头结点
   - 结点类LinkNode
   - 单向链表LinkList
     - 操作
       - 插入:插入位置不正确;空表k=1;非空表k=1;1<k<=n;
       - 删除:删除位置不正确;k=1;1<k<n;k=n;删除by key可以通过结合Find()和删除by index
       - 清空:使用求长度及删除操作
       - 按位置修改:逻辑与按位置取得一样
     - 复杂数据元素
        - LinkNode和Node不同，Node是其中的数据部分
        - Node中重载了<<
        - 虽然采取了不同的储存结构，但是只要在类中声明一样的接口，具体实现应用的代码也几乎一样，运行结果也完全相同。唯一不同是声明顺序表或单项链表对象的第一条语句
   - 单向循环链表
     - 最后一个结点的指针域指向头结点，空表则头结点指向自己
     - 头结点使得空表和非空表运算统一
     - 区别
       - 构造函数赋初值:head->next=head;
       - int GetLength()const:判断条件while(p!=head)
       - bool IsEmpty()const:return head->next=head;
   - 双向链表
     - 经常需要访问一个结点的前驱结点情况
     - 两个指针域prev,next
   - 双向循环链表
     - 头节点prev指向尾结点
     - 尾结点next指向头结点
6. 栈(Stack)
   - 栈和队列
     - 线性数据结构
     - 插入和删除操作受限的线性表
   - 定义
     - 插入和删除操作都只能在表的同一端进行的线性表
     - 栈顶(Top),又称为表尾
     - 栈底(Bottom),又称为表头
     - 进栈(push),入栈
     - 退栈(pop)，出栈
     - 先进后出(FILO),后进先出(LIFO)
   - 例：函数的调用和返回；子弹匣
   - 抽象数据类型
      ADT Stack{
         数据对象D
         数据关系R
         基本操作P:
            Create();
            Destory();
            bool IsEmpty();
            bool IsFull();
            bool Push(const T& x);
            bool Top(T& x);
            bool Pop(T& x);
            void OutPut();
      }ADT Stack
7. 顺序栈(LinearStack)  
   - 定义
      顺序存储结构的栈
   - 一位动态数组表示，栈底可以是在数组两端
   - 上溢(Overflow)
   - 下溢(Underflow)
   - 注意top=-1表示空栈
8. 链接栈(LinkStack)
   - 不需要表头结点，栈顶指针就是链接栈的头指针
   - 不需要最大元素个数的限制Isfull()，只要内存足够大即可
   - 注意声明友类模板类时不需要<T>,和普通声明模板类一样
   - Push()进栈时注意要先判断内存是否有空间，即新结点是否能new成功
   - 链接栈先输出栈顶，顺序栈先输出栈底
9. 队列
   - 定义
     - 只允许在表的一端插入，另一端删除的线性表
     - 入队，出队
     - 队尾(rear)，队头(front)
     - 先进先出(FIFO),后进后出(LILO)
   - 抽象数据类型
      ADR Queue{
         D
         R
         P:
            Create();
            Destory();
            bool IsEmpty();
            bool IsFull();
            bool Insert(const T& x);
            bool GetElement(T& x);
            bool Delete(T& x);
            void OutPut();

      }ADT Queue

10. 顺序循环队列(LinearQueue)
   - 需要头指针front,尾指针rear，两个整型变量
   - 约定：front指向队头元素，rear指向队尾元素的下一位置，初始化队列front=0，rear=0
   - 上溢，下溢
   - 循环队列
      - 假上溢
         front=(front+1)%(MaxSize)
         rear=(rear+1)%(MaxSize)
      - 无法仅根据rear=front来判断队列是空还是满
        - 少用一个元素空间。如队前若rear=(rear+1)%(MaxSize)则判断队列已满
        - 使用size记录实际长度。则size=0时则队列是空队列

11. 链接队列(LinkQueue)
    - 仅在表头删除结点，在表位插入结点的单链表
    - 对于链接队列,rear直接指向队尾

12. 树
    - 定义
      - 非线性数据结构
      - 多层次模型:文件夹目录等
      - 根结点，递归定义:子树
    - 度和数的度
      - 一个结点的后继的数目称为该结点的度
      - 树中各结点度的最大值称为树的度
    - 结点的层和树的深度
      - 根结点为第一层
      - 树的深度为层的最大值
    - 分支，路径，路径长度，树的路径长度
      - 分支为结点之间的连线
      - 路径为A,B结点之间所经历的所有分支数目
      - 路径长度为一条路径上的分支数目
      - 树的路径长度为根结点到各结点的路径长度之和
    - 叶子结点，分支结点和内部结点
      - 叶子结点:度为0
      - 分支结点:度不为0
      - 内部结点:除根结点以外的分支结点
    - 结点之间的关系
      - 孩子
      - 双亲
      - 兄弟
      - 堂兄弟:在同一层的不同双亲的孩子
      - 祖先
      - 子孙
    - 有序树和无序树
      - 有序树:交换子树位置会改变树所表示的内容
      - 无序树:或者说各子树的相对次序不被用来表示数据之间的关系
    - 森林
      - 互不相交的树的集合

13. 二叉树(BinTree)
    - 定义
      - 每个结点的度小于等于2的有序树
      - 左子树，右子数 
      - 根节点，其余结点可以分为**两个**互不相交的子集,其中每个子集又是一个二叉树
      - 例:哈夫曼树,数据库
    - 顺序编号法
      自上向下，从左向右
    - 满二叉树
    - 完全二叉树
         结点与相同深度的满二叉树中的结点完全编号一致的二叉树
    - 性质
      - 二叉树第i层至多有$2^{i-1}$    
      - 深度为k的二叉树至多有$2^k-1$个结点
      - 二叉树中度为0的结点数为$n_0$,度为2的结点数为$n_2$,则$n_0$=$n_2+1$
      - 具有n个结点的完全二叉树深度为$[log2_n]+1$,$[log2_n]$指不大于$[log2_n]$的最大整数
      - 若完全二叉树采用顺序编号
        - 若一个结点分支编号为i，则其左子树的根结点编号为$2*i$，右子树的根结点编号为$2*i+1$
        - 若一个非根结点的编号为i，则其双亲结点的编号为$[i/2]$,其中$[i/2]$表示不大于$i/2$的最大整数
    - 抽象数据类型
         ADT BinTree
         {
            D&R
            P:
               BinTree();
               ~BinTree();
               PreOrderTraverse();
               InOrderTraverse();
               PostOrderTraverse();
               LevelOrderTraverse();
               IsEmpty();
               CreateRoot();
               Clear();
               InsertLeftChild();
               InsertRightChild();
               DeleteSubTree();
               SearchByKey();
               ModifyNodeValue();
               GetParent();
         }ADT BinTree
    - 二叉树的顺序表示
       - 按照顺序编号法，定义一个一维数组来表述二叉树的顺序存储空间，下标为0的空间不用或用作其他用途
       - 操作方便但是容易造成存储空间的浪费，例:只有右子树的二叉树
       - 顺序表示适合完全二叉树，不适合非完全二叉树
       - 空间利用率低，在实际应用中不多
    - 二叉树的链式表示
      - 有更高的空间利用率，实际使用中一般采用链式表示
      - 二叉链表表示
         设置两个结点分别指向左孩子和右孩子
      - 三叉链表表示
         设置三个结点分别指向双亲，左孩子和右孩子。对于根结点parent指针为NULL
14. 二叉链表(LinkedBinTree)
    - 更高的空间利用率
         实际应用中，一个结点数据域所占据的空间一般远大于指针域所占用的空间