#### 算法刷题总结
1. 按模块总结要点，不记录具体实现
2. 计划：首先刷完牛客100题的题目，同时复习代码随想录中相应单元并总结。剩下时间学习 快排归并，并查集，图论的DFS,BFS（岛屿问题，棋盘问题，一些经典问题），再留有的时间刷CodeTOP100
3. 及时复习ACM格式，与树的写法
4. 复习中要分析复杂度
#### 1. 复杂度分析
1. 对于不同数据规模，时间复杂度会有区别。数据用例的不一样，时间复杂度也是不同的。
2. 一般时间复杂度是忽略常数项，是因为一般默认数据规模足够大
3. 算法不是时间复杂度越低的越好，当数据规模很小时且有常数项的情况下$O(n^2)$的算法比$O(n)$的更合适
4. $O(1)$常数阶 < $O(\log n)$对数阶（忽略底数） < $O(n)$线性阶 < $O(n^2)$平方阶 < $O(n^3)$立方阶 < $O(2^n)$指数阶
5. 二分法递归实现，时间复杂度是$O(\log n)$，空间复杂度为 $1 * logn = O(logn)$。但如果传递函数是拷贝整个数组而非拷贝地址时，空间复杂度为$O(n\log n)$

#### 2. 二分法
1. 做题要点
   - 题目满足
     - 有序数组
     - 数组内无重复元素，因为有重复时下标不唯一
   - 循环不变量原则
     - [left,right]
     - [left,right)
   - 复杂度
    二分空间复杂度O(1),时间复杂度O(logn)
2. 题目
   - BM17二分查找-I
        最简单的二分
   - BM18 二维数组中的查找
        写一个函数来二分一行，循环调用二分整个数组
   - BM19 寻找峰值
        假设右边有峰值，因为nums[-1] = nums[n] = −∞，所以如果nums[mid] < nums[mid + 1]则右边必有峰值。注意right = mid，left = mid + 1，因为在nums[mid] < nums[mid + 1]的情况下，mid不可能是峰值
   - 

