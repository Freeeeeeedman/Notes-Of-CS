
[toc]

### 1. Linux系统编程入门






#### 1.1 Linux开发环境搭建
1. 免登录VSCode
    本地端: ssh-keygen
    服务器端:ssh-keygen -t rsa 
    复制本地端公钥.pub至.ssh/authoirzed_keys

#### 1.2 GCC
1. gcc与g++
- gcc 和 g++都是GNU(编译器套件)的一个编译器
- 使用原则：gcc编译c文件,g++编译c++文件
- 注意
  - 后缀为 .c 的， gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序
  - 后缀为 .cpp 的，两者都会认为是 C++ 程序
  - 编译可以用gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++
  - gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。但在编译阶段，g++ 会自动调用 gcc，二者等价
  - ldd命令查看所链接的库
1. GCC工作流程
   - 源代码(.h .c .cpp)经预处理器后为预处理后源代码(.i)
   - 再经编译器为汇编代码(.s)
   - 再经汇编器为目标代码(.o)
   - 再与启动代码，库代码，其他目标代码经链接器为可执行程序(.exe .out)
2. 静态库制作
   - 命名规则:libxxx.a libxxx.lib
   - 流程
     - 编译，汇编：gcc -c add.c sub.c mult.c div.c -I ../include/
     - 生成静态库： ar rcs libcalcu.a add.o div.o mult.o sub.o
     - 链接：gcc main.c -o app -I ./include/ -l calcu -L ./lib/
3. 动态库制作
   - 命名规则:libxxx.so libxxx.dll
   - 流程
     - 编译，汇编，得到和位置无关的代码:gcc -c -fpic *.c
     - 生成动态库：gcc -shared *.o -o libcalc.so
     - 链接：gcc main.c -o main -I./include/ -L lib/ -l calc   
     - 配置环境变量:
       - 临时：export LD_LIBRARY_PATH=$LD_LIBRARY:/home/ubuntu/lessons/lesson01/library/lib
       - 用户：.bashrc
       - 系统:/etc/profile/,./profile或者/etc/ld.so.config,sudo ldconfig
4. 工作原理
   - 静态库： GCC 进行链接时，会把静态库中代码打包到可执行程序中
   - 动态库： GCC 进行链接时，动态库的代码不会被打包到可执行程序中
   - 程序启动之后，动态库会被动态加载到内存中，通过 ldd （list dynamic dependencies）命令检查动态库依赖关系
   - 如何定位共享库文件
    当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 DT_RPATH段 ——> 环境变量LD_LIBRARY_PATH ——> /etc/ld.so.cache文件列表 ——> /lib/， /usr/lib目录找到库文件后将其载入内存
5. 对比
    - 静态链接方式，动态链接方式
    - 库非常小使用静态库，库比较大时使用动态库
    - 库的好处： 1.代码保密 2.方便部署和分发
    - 静态库优缺点
      - 优点
        - 静态库被打包到应用程序中加载速度快
        - 发布程序无需提供静态库，移植方便
      - 缺点
        - 多个程序同一静态库重复加载至内存，消耗系统资源，浪费内存
        - 更新、部署、发布麻烦
    - 动态库优缺点
      - 优点
        - 可以实现进程间资源共享（共享库）
        - 更新、部署、发布简单
        - 可以控制何时加载动态库，使用到时加载，没使用到就不加载
      - 缺点
        - 加载速度比静态库慢
        - 发布程序时需要提供依赖的动态库
      - 注意
        - 链接时加载的是动态库的一些信息如名称而不是动态库本身
        - 动态库运行时加载所以在内存中位置不确定，编译汇编时要加-fpic

#### 1.3 Makefile
1. 作用
    自动化编译，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译。像一个 Shell 脚本一样，也可以执行操作系统的命令
2. 文件命名
    makefile 或者 Makefile
3. Makefile 规则
    一个 Makefile 文件中可以有一个或者多个规则
    目标 ...: 依赖 ...
        命令（Shell 命令）...      
   - 目标：最终要生成的文件（伪目标除外）
   - 依赖：生成目标所需要的文件或是目标
   - 命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进
4. 执行规则
   - 先只执行第一条命令，后面的命令如果不生成第一条命令的依赖不执行,需要指定执行
   - 命令在执行之前，需要先检查规则中的依赖是否存在，存在执行，不存在向下查找再执行
   - 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间
   - 各自编译为.o文件再链接比直接编译汇编链接.c文件效率高，因为可以避免重复操作
   - 指定执行目标，make clean
5. 变量规则
   - 自定义变量
      变量名=变量值 var=hello
   - 预定义变量
     - AR : 归档维护程序的名称，默认值为 ar
     - CC : C 编译器的名称，默认值为 cc
     - CXX : C++ 编译器的名称，默认值为 g++
     - $@ : 目标的完整名称
     - $< : 第一个依赖文件的名称
     - $^ : 所有的依赖文件
     - 获取变量的值：$(变量名)
   - 自动变量只能在规则的命令中使用
      ```
      app:main.c a.c b.c
        $(CC) -c $^ -o $@
      ```
   - %.o:%.c
      - %: 通配符，匹配一个字符串
      - 两个%匹配的是同一个字符串
   - 伪目标，防止与文件命名冲突
      ```
      .PHONY:clean
      clean:
        ...
      ```
6. 函数
   - $(wildcard PATTERN...)
     - $(wildcard *.c ./sub/*.c)
   - $(patsubst <pattern>,<replacement>,<text>)
     - $(patsubst %.c, %.o, x.c bar.c)

#### 1.4 GDB调试
1. 简介
    GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境， GDB 是 Linux 和许多类 Unix 系统中的标准开发环境
2. 功能
   1. 启动程序，可以按照自定义的要求随心所欲的运行程序
   2. 可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）
   3. 当程序被停住时，可以检查此时程序中所发生的事
   4. 可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG
3. 准备
    gcc -g -Wall program.c -o program //关闭优化选项-O
    `-g` 选项的作用是在可执行文件中加入源代码的信息,并不是把源代码嵌入其中，所以调试时必须保证 gdb 能找到源文件
4. 命令
   - 基础命令
     - 启动和退出
      gdb 可执行程序
      quit
     - 给程序设置参数/获取设置参数
      set args 10 20
      show args
     - GDB 使用帮助
      help
     - 查看当前文件代码
      list/l （从默认位置显示）
      list/l 行号 （从指定的行显示）
      list/l 函数名（从指定的函数显示）
     - 查看非当前文件代码（不能直接指定文件）
      list/l 文件名:行号
      list/l 文件名:函数名
     - 设置显示的行数
      show list/listsize
      set list/listsize 行数
   - 断点命令
     - 设置断点
      b/break 行号
      b/break 函数名
      b/break 文件名:行号
      b/break 文件名:函数
     - 查看断点
      i/info b/break
     - 删除断点
      d/del/delete 断点编号
     - 设置断点无效
      dis/disable 断点编号
     - 设置断点生效
      ena/enable 断点编号
     - 设置条件断点（一般用在循环的位置）
      b/break 10 if i==5
   - 调试命令
     - 运行GDB程序
      start（程序停在第一行）
      run（遇到断点才停）
     - 继续运行，到下一个断点停
      c/continue
     - 向下执行一行代码（不会进入函数体）
      n/next
     - 变量操作
      p/print 变量名（打印变量值）
      ptype 变量名（打印变量类型）
     - 向下单步调试（遇到函数进入函数体）
      s/step
      finish（跳出函数体）
     - 自动变量操作
      display 变量名（自动打印指定变量的值）
      i/info display
      undisplay 编号
     - 其它操作
      set var 变量名=变量值 （循环中用的较多）
      until （跳出循环）

#### 1.5 文件IO
1. 站在内存角度考虑IO，输入为文件到内存，输出为内存到文件
2. 跨平台
  Java通过虚拟跨平台，实际代码运行都在虚拟机内
  C通过调用不同平台的API跨平台
3. 返回值File *fp
   结构体
   - 文件描述符(整型值)：索引到对应的磁盘文件
   - 文件读写指针位置：读写文件过程中指针的实际位置，用于操作读数据和写数据
   - I/O缓冲区（内存地址）：通过寻址找到对应的内存，数据从内存刷新到磁盘     
4. I/O缓冲区
    C库函数先写入缓冲区，再调用LinuxI/O函数写入磁盘
  - 作用 
    提高效率，降低写磁盘的次数（本质是通过内核）
  - 写入磁盘的时机
    1. 刷新缓冲区： fflush
    2. 缓冲区已满
    3. 正常关闭文件
        a.fclose
        b.return(main函数)
        c.exit(main函数)
4. 标准 C 库 IO 和 Linux 系统 IO 的关系
   - 调用和被调用的关系
      用户程序调用C标准I/O库，C标准I/O库写入缓冲区，缓冲区满时调用linux系统I/O，写入磁盘
   - 标准C库函数为高级语言，linux平台I/O函数更低级
   - 磁盘读写时选用标准C库函数，网络通信提高效率使用LinuxI/O函数

#### 1.6 虚拟地址空间 
1. 程序和进程
    程序：磁盘上的代码
    进程：加载到内存中的运行中的程序
2. 32位：2^32 ~ 4G
   64位: 2^48
3. 内核区1G
   - 内存管理
   - 进程管理
   - 设备驱动管理
   - VFS虚拟文件系统
4. 用户区3G
  - 环境变量
  - 命令行参数
  - 栈空间(小)：由高到低存
  - 共享库
  - 堆空间(大)：由低到高存
  - ELF
    未初始化全局变量
    初始化全局变量
    代码段，二进制机器命令
  - 受保护的地址

#### 1.6 文件描述符
1. 文件描述符在内核区，由PCB进程控制块管理
2. 文件描述符表
   - 使用数组存取，为了一个进程可以同时打开多个文件
   - 默认大小为1024，即最大同时可打开文件数目为1024
   - 默认前三为标准输入0，标准输出1，标准错误2，默认为打开状态，与当前终端/dev/tty设备文件绑定
   - 一个文件可以被打开多次，即多个文件描述符可以指定同一文件
   - 每打开一个文件，则占用一个空闲的最小的文件描述符

#### 1.7 Linux I/O函数
1. man 2 open:linux系统I/O函数
   man 3 fopen:标准C库函数
2. open()
   - int open(const char *pathname, int flags);
     - pathname:要打开的文件路径
     - flags：对文件的操作权限设置还有其他设置，互斥
     - 返回值：返回一个新的文件描述符，如果调用失败，返回-1
     - errno：属于linux系统函数库，是其中的一个全局变量，记录的是最近的错误号
   - void perror(const char *s);作用：打印errno对应的错误描述
      s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)
   - int open(const char *pathname, int flags, mode_t mode);
     - 不是函数重载，C是用可变参数实现
     - flags：注意flag为程序内的权限，而mode为程序外的权限
       - 必选项：O_RDONLY,  O_WRONLY, O_RDWR  这三个之间是互斥的
       - 可选项：O_CREAT 文件不存在，创建新文件
         - 使用按位或设置可选项
         - flags参数是一个int类型的数据，占4个字节，32位
         - flags 32个位，每一位就是一个标志位
       - mode
         - 八进制的数，表示创建出的新的文件的操作权限，比如：0775
         - 最终的权限是：mode & ~umask
         - 按位与：0和任何数都为0,umask的作用就是抹去某些权限
            0777   ->   111111111
        &   0775   ->   111111101

                        111111101
3. read()
   - ssize_t read(int fd, void *buf, size_t count);
     - 参数：
       - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件
       - buf：需要读取数据存放的地方，数组的地址（传出参数）
       - count：指定的数组的大小
     - 返回值：
        - 成功：
           \>0: 返回实际的读取到的字节数
           =0：文件已经读取完了
        - 失败：-1 ，并且设置errno        
4. write()
    - ssize_t write(int fd, const void *buf, size_t count);
       - 参数：
            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件
            - buf：要往磁盘写入的数据，数据
            - count：要写的数据的实际的大小
       - 返回值：
            成功：实际写入的字节数
            失败：返回-1，并设置errno
5. lseek()
   - off_t lseek(int fd, off_t offset, int whence);
      -  参数：
            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件
            - offset：偏移量
            - whence:
                SEEK_SET
                    设置文件指针的偏移量
                SEEK_CUR
                    设置偏移量：当前位置 + 第二个参数offset的值
                SEEK_END
                    设置偏移量：文件大小 + 第二个参数offset的值
      -  返回值：返回文件指针的位置
     -   作用：
        1. 移动文件指针到文件头,避免再次打开文件
        lseek(fd, 0, SEEK_SET);
        2. 获取当前文件指针的位置
        lseek(fd, 0, SEEK_CUR);
        3. 获取文件长度
        lseek(fd, 0, SEEK_END);
        4. 拓展文件的长度，当前文件10b, 110b, 增加了100个字节
        lseek(fd, 100, SEEK_END)
        注意：需要写一次数据， write(fd, " ", 1);
        用途：先占据一部分空间
6. stat()
   - stat test.txt
   - int stat(const char *pathname, struct stat *statbuf);
      - 作用：获取一个文件相关的一些信息
      - 参数:
            - pathname：操作的文件的路径
            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息
      - 返回值：
            成功：返回0
            失败：返回-1 设置errno
   - int lstat(const char *pathname, struct stat *statbuf);
      - 作用：获取软链接而非其指向的文件的信息
   -  ```
      struct stat {
          dev_t st_dev; // 文件的设备编号
          ino_t st_ino; // 节点
          mode_t st_mode; // 文件的类型和存取的权限
          nlink_t st_nlink; // 连到该文件的硬连接数目
          uid_t st_uid; // 用户ID
          gid_t st_gid; // 组ID
          dev_t st_rdev; // 设备文件的设备编号
          off_t st_size; // 文件字节数(文件大小)
          blksize_t st_blksize; // 块大小
          blkcnt_t st_blocks; // 块数
          time_t st_atime; // 最后一次访问时间
          time_t st_mtime; // 最后一次修改时间
          time_t st_ctime; // 最后一次改变时间(指属性)
      };
      ```
   - st_mode变量
     - 4位文件类型+3位特殊权限位+3位User权限位+3位Group权限位+3位Others权限位
     - linux共七种文件
         - S_IFSOCK 0140000 套接字
         - S_IFLNK 0120000 符号链接（软链接）
         - S_IFREG 0100000 普通文件
         - S_IFBLK 0060000 块设备
         - S_IFDIR 0040000 目录
         - S_IFCHR 0020000 字符设备
         - S_IFIFO 0010000 管道
         - S_IFMT 0170000 掩码
     - (st_mode & S_IFMT) == S_IFREG，通过与宏&运算，再与对应文件类型宏进行比较得出其文件类型
     - others文件权限也是通过与宏00007&运算得出，等等

#### 1.8 Linux 文件属性操作函数
1. access()
   - int access(const char *pathname, int mode);
     - 作用：判断某个文件是否有某个权限，或者判断文件是否存在
     - 参数：
         - pathname: 判断的文件路径
         - mode:
                R_OK: 判断是否有读权限
                W_OK: 判断是否有写权限
                X_OK: 判断是否有执行权限
                F_OK: 判断文件是否存在
     - 返回值：成功返回0， 失败返回-1
2. chmod()
   -  int chmod(const char *pathname, mode_t mode);
      - 修改文件的权限
      -  参数：
            - pathname: 需要修改的文件的路径
            - mode:需要修改的权限值，八进制的数
            - r:4,w:2,x:1
      -  返回值：成功返回0，失败返回-1
   - int chown(const char *path, uid_t owner, gid_t group);
     - 修改文件的所有者和所有组
     - uid:etc/passwd
     - gid:etc/group
   - useradd
   - id ubuntu
3. truncate()
   - int truncate(const char *path, off_t length);
     - 作用：缩减或者扩展文件的尺寸至指定的大小
     - 参数：
        - path: 需要修改的文件的路径
        - length: 需要最终文件变成的大小
     - 返回值：
         成功返回0， 失败返回-1

#### 1.9 Linux 目录操作函数
1. mkdir()
   - mkdir命令和mkdir函数不同
   - int mkdir(const char *pathname, mode_t mode);
       - 作用：创建一个目录
       - 参数：
            pathname: 创建的目录的路径
            mode: 权限，八进制的数,会与掩码进行与操作
       - 返回值：
            成功返回0， 失败返回-1
2. int rmdir(const char *path)
   只能删除空目录
3. int rename(const char *oldpath, const char *newpath)
4. chdir()
   - int chdir(const char *path);
       - 作用：修改进程的工作目录
            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder
       - 参数：
            path : 需要修改的工作目录
5. getcwd()
   - char *getcwd(char *buf, size_t size);
       - 作用：获取当前工作目录
       - 参数：
            - buf : 存储的路径，指向的是一个数组（传出参数）
            - size: 数组的大小
       - 返回值：
            返回的指向的一块内存，这个数据就是第一个参数
<<<<<<< HEAD

#### 1.10 Linux目录遍历函数
1. opendir()
   - 流stream
      一切能被读写的都是文件，流是读写文件的抽象
      流就是读一点数据, 处理一点点数据
   - DIR *opendir(const char *name);
      - 参数：
            - name: 需要打开的目录的名称
      - 返回值：
            DIR * 类型，理解为目录流，一开始指向数据最前面
            错误返回NULL
2. readdir()
   - struct dirent *readdir(DIR *dirp);
        - 参数：dirp是opendir返回的结果
        - 返回值：
            struct dirent，代表读取到的文件的信息
            读取到了末尾或者失败了，返回NULL
   - ```
      struct dirent
      {
      // 此目录进入点的inode
      ino_t d_ino;
      // 目录文件开头至此目录进入点的位移
      off_t d_off;
      // d_name 的长度, 不包含NULL字符
      unsigned short int d_reclen;
      // d_name 所指的文件类型
      unsigned char d_type;
      // 文件名
      char d_name[256];
      };
     d_type
      DT_BLK - 块设备
      DT_CHR - 字符设备
      DT_DIR - 目录
      DT_LNK - 软连接
      DT_FIFO - 管道
      DT_REG - 普通文件
      DT_SOCK - 套接字
      DT_UNKNOWN - 未知
     ``` 
3. int closedir(DIR *dirp);

#### 1.11 dup,dup2,fcntl函数
1. dup()
   - int dup(int oldfd);
      - 作用：复制一个新的文件描述符
        fd=3, int fd1 = dup(fd),
        fd指向的是a.txt, fd1也是指向a.txt
        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符
2. dup2()
   - int dup2(int oldfd, int newfd);
      - 作用：重定向文件描述符
        oldfd 指向 a.txt, newfd 指向 b.txt
        调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt
        oldfd 必须是一个有效的文件描述符
        oldfd和newfd值相同，相当于什么都没有做
      - 返回描述符，与被newfd相同
3. fcntl()
   - int fcntl(int fd, int cmd, ...);
   - 作用：
      复制文件描述符
      设置/获取文件的状态标志
   - 参数：
      - fd : 表示需要操作的文件描述符
      - ...:可变参数
      - cmd: 表示对文件描述符进行如何操作
         - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）
             int ret = fcntl(fd, F_DUPFD);
         - F_GETFL : 获取指定的文件描述符文件状态flag
              获取的flag和我们通过open函数传递的flag是一个东西
         - F_SETFL : 设置文件描述符文件状态flag
              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改
              可选性：O_APPEND, O_NONBLOCK
                O_APPEND 表示追加数据,flag也是一系列二进制，所以需要使用flag |= O_APPEND来进行修改,也必须要有写权限
                NONBLOK 设置成非阻塞
      - 阻塞和非阻塞：描述的是函数调用的行为



### 2. Linux 多进程开发
#### 2.1 进程
1. 程序
   程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程
   - 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）
   - 机器语言指令：对程序算法进行编码。
   - 程序入口地址：标识程序开始执行时的起始指令位置。
   - 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。
   - 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。
   - 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。
   - 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。
2. 进程
   - 和程序的区别
      进程占用内存，CPU等资源，而程序只占用磁盘 
   - 进程是正在运行的程序的实例。 进程既是基本的分配单元，也是基本的执行单元。
   - 可以用一个程序来创建多个进程，**进程是内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源**。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息
3. 单道与多道
   - 单道程序，即在计算机内存中只允许一个的程序运行。
   - 多道程序
      多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率
   - 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻， CPU 上运行的程序只有一个
   - 在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级， 1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行
4. 时间片
   - 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－ 800ms），用户不会感觉到。
   - 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。
   - 时间片不能太短，切换的时间开销大；也不能太长，否则宏观上不能同时执行
5. 并行与并发
   - 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。
   - 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行
6. 进程控制块（PCB）
   - 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。
   - 在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可：
     - 进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数
     - 进程的状态：有就绪、运行、挂起、停止等状态
     - 进程切换时需要保存和恢复的一些CPU寄存器
     - 描述虚拟地址空间的信息
     - 描述控制终端的信息
     - 当前工作目录（Current Working Directory）
     - umask 掩码
     - 文件描述符表，包含很多指向 file 结构体的指针
     - 和信号相关的信息
     - 用户 id 和组 id
     - 会话（Session）和进程组
     - 进程可以使用的资源上限（Resource Limit）,ulimit -a 命令查看

#### 2.2 进程状态转换
1. 进程的状态
   - 进程状态反映进程执行过程的变化。这些状态随着**进程的执行和外界条件的变化**而转换。
   - 在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态
   - 运行态：进程占有处理器正在运行
   - 就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列
   - 阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成,如sleep()，等待用户输入等。阻塞态不能直接变为运行态，因为阻塞时已经释放了资源CPU，需要重新进入就绪队列以获取
   - 新建态：进程刚被创建时的状态，尚未进入就绪队列
   - 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。终止态删除用户空间的资源，但还保留内核空间的资源。就绪态和阻塞态也可以直接转为终止态。
2. 进程相关命令
   - 查看进程
      ps aux / ajx
      a：显示终端上的所有进程，包括其他用户的进程
      u：显示进程的详细信息
      x：显示没有控制终端的进程，查看当前终端信息：tty
      j：列出与作业控制相关的信息
   - STAT参数意义：
      D 不可中断 Uninterruptible（usually IO）
      R 正在运行，或在队列中的进程
      S(大写) 处于休眠状态
      T 停止或被追踪
      Z 僵尸进程
      W 进入内存交换（从内核2.6开始无效）
      X 死掉的进程
      < 高优先级
      N 低优先级
      s 包含子进程
      + 位于前台的进程组
3. 实时显示进程动态
    - top
      可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令
      执行后，可以按以下按键对显示的结果进行排序：
      - M 根据内存使用量排序
      - P 根据 CPU 占有率排序
      - T 根据进程运行时间长短排序
      - U 根据用户名来筛选进程
      - K 输入指定的 PID 杀死进程
    - 杀死进程
      kill [-signal] pid
      kill –l 列出所有信号
      kill –SIGKILL 进程ID
      kill -9 进程ID
      killall name 根据进程名杀死进程
4. 进程号与进程组
    - 每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围： 0～ 32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。
    - 任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。
    - 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。
    -  进程号和进程组相关函数：
      pid_t getpid(void);
      pid_t getppid(void);
      pid_t getpgid(pid_t pid);
    - 大部分进程的父进程都是当前终端，如bash

#### 2.3 进程创建
1. fork()
   pid_t fork(void);
   - 函数的作用：用于创建子进程。
   - 返回值：
            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。
            在父进程中返回创建的子进程的ID,
            在子进程中返回0
            如何区分父进程和子进程：通过fork的返回值。
            在父进程中返回-1，表示创建子进程失败，并且设置errno
   - 失败的两个主要原因：
     1. 当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN
     2. 系统内存不足，这时 errno 的值被设置为 ENOMEM 
2. 父子进程虚拟地址空间
   - 内核空间
      子进程内核空间拷贝父进程，但各自的PID不同
   - 用户空间
      子进程用户空间拷贝父进程
      - 代码也是完全相同，但执行不同
      - fork()在父进程中执行，不在子进程中执行，但是返回值PID(和内核PID不一样)作为临时变量分布存储在父子进程的栈空间，父进程存储子进程PID，子进程为0
      - 子父进程同名局部变量互不影响
   - fork的实现:读时共享，写时拷贝 (copy- on-write)
     - 实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。
     - 写时拷贝是一种可以推迟甚至避免拷贝数据的技术,节约内存空间，减少拷贝时的时间消耗
     - 内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。
     - 注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针
3. 父子进程之间的关系：
   - 区别：
      1.fork()函数的返回值不同
                父进程中: >0 返回的子进程的ID
                子进程中: =0
      2.pcb中的一些数据
                当前的进程的id pid
                当前的进程的父进程的id ppid
                信号集
   - 共同点：
      某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作
                用户区的数据
               文件描述符表
        
   -  父子进程对变量是不是共享的？
      刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。所以不能用变量进行通信。
      读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。

#### 2.4 GDB多进程调试
1. 使用 GDB 调试的时候， GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。
2. 设置调试父进程或者子进程： set follow-fork-mode [parent（默认） | child]
3. 设置调试模式： set detach-on-fork [on | off]默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。
4. 查看调试的进程： info inferiors
5. 切换当前调试的进程： inferior id
6. 使进程脱离 GDB 调试： detach inferiors id

#### 2.5 exec函数族
1. 函数族
   C语言中没有函数重载概念，使用函数族，指一系列功能类似的函数
2. exec 函数族
   - exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容（而不是再创建一个进程），换句话说，就是在调用进程内部执行一个可执行文件。一般使用时，先fork()再在子进程中调用，避免替换父进程内容。
   - exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。
   - execve()为linux系统函数，其他函数为在前者上分装后的C标准库函数。
3. execl()
   - int execl(const char *path, const char *arg, ...);
   - 参数：
       - path:需要指定的执行的文件的路径或者名称,也可执行shell命令如ps
                a.out /home/nowcoder/a.out 推荐使用绝对路径
                ./a.out hello world
       - arg:是执行可执行文件所需要的参数列表
                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
                从第二个参数开始往后，就是程序执行所需要的的参数列表。
                参数最后需要以NULL结束（哨兵）
   - 返回值：
            只有当调用失败，才会有返回值，返回-1，并且设置errno
            如果调用成功，没有返回值。因为调用成功后代码区被替换，是不可能收到返回值的。
4. execlp()
   - int execlp(const char *file, const char *arg, ... );
   - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。
   - 参数：
      - file:需要执行的可执行文件的文件名
                a.out
                ps
      - arg:是执行可执行文件所需要的参数列表
                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
                从第二个参数开始往后，就是程序执行所需要的的参数列表。
                参数最后需要以NULL结束（哨兵）
      - 返回值：
            只有当调用失败，才会有返回值，返回-1，并且设置errno
            如果调用成功，没有返回值。
5. 其他函数
- int execle(const char *path, const char *arg, .../*, (char *) NULL, char *
const envp[] */);
- int execv(const char *path, char *const argv[]);
- int execvp(const char *file, char *const argv[]);
- int execvpe(const char *file, char *const argv[], char *const envp[]);
- int execve(const char *filename, char *const argv[], char *const envp[]);
- 说明
   l(list) 参数地址列表，以空指针结尾
   v(vector) 存有各参数地址的指针数组的地址
   p(path) 按 PATH 环境变量指定的目录搜索可执行文件
   e(environment) 存有环境变量字符串地址的指针数组的地址，即自己指定的地址,char* test[]={"","",""};

#### 2.6 进程控制
1. 进程退出
   - C标准库： #include <stdlib.h>
     - void exit(int status);
     - 调用退出处理函数->刷新I/O缓冲并关闭文件描述符->调用_exit()系统调用
     - 如'\n'会刷新缓冲区，但是如果print("world");_exit(0);则不会刷新缓冲区，无输出
   - Linux系统库： #include <unistd.h>
     - void _exit(int status);
     - 调用_exit()系统调用
     - 退出进程，用的多
   - status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。
2. 孤儿进程
   - 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。
   - 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init（pid == 1） ，而 init进程会循环地 wait() 它的已经退出的子进程。最后由init进程回收孤儿进程的资源。
   - 孤儿资源没有危害
   - 例
      终端为a进程的父进程，a进程运行时，终端进程切换到后台，a进程运行结束，终端进程切换到前台。但是如果a进程的子进程还在运行，则仍会输出到屏幕上，因为子进程复制了a进程的文件描述符表
3. 僵尸进程
   - 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放
   - 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程
   - 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免
   - 结束僵尸进程需要结束父进程可以用ctrl+c但不方便，所以一般让父进程调用wait()或waitpid()
4. 