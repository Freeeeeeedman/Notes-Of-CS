
[toc]

### 1. Linux系统编程入门






#### 1.1 Linux开发环境搭建
1. 免登录VSCode
    本地端: ssh-keygen
    服务器端:ssh-keygen -t rsa 
    复制本地端公钥.pub至.ssh/authoirzed_keys

#### 1.2 GCC
1. gcc与g++
- gcc 和 g++都是GNU(编译器套件)的一个编译器
- 使用原则：gcc编译c文件,g++编译c++文件
- 注意
  - 后缀为 .c 的， gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序
  - 后缀为 .cpp 的，两者都会认为是 C++ 程序
  - 编译可以用gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++
  - gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。但在编译阶段，g++ 会自动调用 gcc，二者等价
  - ldd命令查看所链接的库
1. GCC工作流程
   - 源代码(.h .c .cpp)经预处理器后为预处理后源代码(.i)
   - 再经编译器为汇编代码(.s)
   - 再经汇编器为目标代码(.o)
   - 再与启动代码，库代码，其他目标代码经链接器为可执行程序(.exe .out)
2. 静态库制作
   - 命名规则:libxxx.a libxxx.lib
   - 流程
     - 编译，汇编：gcc -c add.c sub.c mult.c div.c -I ../include/
     - 生成静态库： ar rcs libcalcu.a add.o div.o mult.o sub.o
     - 链接：gcc main.c -o app -I ./include/ -l calcu -L ./lib/
3. 动态库制作
   - 命名规则:libxxx.so libxxx.dll
   - 流程
     - 编译，汇编，得到和位置无关的代码:gcc -c -fpic *.c
     - 生成动态库：gcc -shared *.o -o libcalc.so
     - 链接：gcc main.c -o main -I./include/ -L lib/ -l calc   
     - 配置环境变量:
       - 临时：export LD_LIBRARY_PATH=$LD_LIBRARY:/home/ubuntu/lessons/lesson01/library/lib
       - 用户：.bashrc
       - 系统:/etc/profile/,./profile或者/etc/ld.so.config,sudo ldconfig
4. 工作原理
   - 静态库： GCC 进行链接时，会把静态库中代码打包到可执行程序中
   - 动态库： GCC 进行链接时，动态库的代码不会被打包到可执行程序中
   - 程序启动之后，动态库会被动态加载到内存中，通过 ldd （list dynamic dependencies）命令检查动态库依赖关系
   - 如何定位共享库文件
    当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 DT_RPATH段 ——> 环境变量LD_LIBRARY_PATH ——> /etc/ld.so.cache文件列表 ——> /lib/， /usr/lib目录找到库文件后将其载入内存
5. 对比
    - 静态链接方式，动态链接方式
    - 库非常小使用静态库，库比较大时使用动态库
    - 库的好处： 1.代码保密 2.方便部署和分发
    - 静态库优缺点
      - 优点
        - 静态库被打包到应用程序中加载速度快
        - 发布程序无需提供静态库，移植方便
      - 缺点
        - 多个程序同一静态库重复加载至内存，消耗系统资源，浪费内存
        - 更新、部署、发布麻烦
    - 动态库优缺点
      - 优点
        - 可以实现进程间资源共享（共享库）
        - 更新、部署、发布简单
        - 可以控制何时加载动态库，使用到时加载，没使用到就不加载
      - 缺点
        - 加载速度比静态库慢
        - 发布程序时需要提供依赖的动态库
      - 注意
        - 链接时加载的是动态库的一些信息如名称而不是动态库本身
        - 动态库运行时加载所以在内存中位置不确定，编译汇编时要加-fpic

#### 1.3 Makefile
1. 作用
    自动化编译，Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译。像一个 Shell 脚本一样，也可以执行操作系统的命令
2. 文件命名
    makefile 或者 Makefile
3. Makefile 规则
    一个 Makefile 文件中可以有一个或者多个规则
    目标 ...: 依赖 ...
        命令（Shell 命令）...      
   - 目标：最终要生成的文件（伪目标除外）
   - 依赖：生成目标所需要的文件或是目标
   - 命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进
4. 执行规则
   - 先只执行第一条命令，后面的命令如果不生成第一条命令的依赖不执行,需要指定执行
   - 命令在执行之前，需要先检查规则中的依赖是否存在，存在执行，不存在向下查找再执行
   - 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间
   - 各自编译为.o文件再链接比直接编译汇编链接.c文件效率高，因为可以避免重复操作
   - 指定执行目标，make clean
5. 变量规则
   - 自定义变量
      变量名=变量值 var=hello
   - 预定义变量
     - AR : 归档维护程序的名称，默认值为 ar
     - CC : C 编译器的名称，默认值为 cc
     - CXX : C++ 编译器的名称，默认值为 g++
     - $@ : 目标的完整名称
     - $< : 第一个依赖文件的名称
     - $^ : 所有的依赖文件
     - 获取变量的值：$(变量名)
   - 自动变量只能在规则的命令中使用
      ```
      app:main.c a.c b.c
        $(CC) -c $^ -o $@
      ```
   - %.o:%.c
      - %: 通配符，匹配一个字符串
      - 两个%匹配的是同一个字符串
   - 伪目标，防止与文件命名冲突
      ```
      .PHONY:clean
      clean:
        ...
      ```
6. 函数
   - $(wildcard PATTERN...)
     - $(wildcard *.c ./sub/*.c)
   - $(patsubst <pattern>,<replacement>,<text>)
     - $(patsubst %.c, %.o, x.c bar.c)

#### 1.4 GDB调试
1. 简介
    GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境， GDB 是 Linux 和许多类 Unix 系统中的标准开发环境
2. 功能
   1. 启动程序，可以按照自定义的要求随心所欲的运行程序
   2. 可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）
   3. 当程序被停住时，可以检查此时程序中所发生的事
   4. 可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG
3. 准备
    gcc -g -Wall program.c -o program //关闭优化选项-O
    `-g` 选项的作用是在可执行文件中加入源代码的信息,并不是把源代码嵌入其中，所以调试时必须保证 gdb 能找到源文件
4. 命令
   - 基础命令
     - 启动和退出
      gdb 可执行程序
      quit
     - 给程序设置参数/获取设置参数
      set args 10 20
      show args
     - GDB 使用帮助
      help
     - 查看当前文件代码
      list/l （从默认位置显示）
      list/l 行号 （从指定的行显示）
      list/l 函数名（从指定的函数显示）
     - 查看非当前文件代码（不能直接指定文件）
      list/l 文件名:行号
      list/l 文件名:函数名
     - 设置显示的行数
      show list/listsize
      set list/listsize 行数
   - 断点命令
     - 设置断点
      b/break 行号
      b/break 函数名
      b/break 文件名:行号
      b/break 文件名:函数
     - 查看断点
      i/info b/break
     - 删除断点
      d/del/delete 断点编号
     - 设置断点无效
      dis/disable 断点编号
     - 设置断点生效
      ena/enable 断点编号
     - 设置条件断点（一般用在循环的位置）
      b/break 10 if i==5
   - 调试命令
     - 运行GDB程序
      start（程序停在第一行）
      run（遇到断点才停）
     - 继续运行，到下一个断点停
      c/continue
     - 向下执行一行代码（不会进入函数体）
      n/next
     - 变量操作
      p/print 变量名（打印变量值）
      ptype 变量名（打印变量类型）
     - 向下单步调试（遇到函数进入函数体）
      s/step
      finish（跳出函数体）
     - 自动变量操作
      display 变量名（自动打印指定变量的值）
      i/info display
      undisplay 编号
     - 其它操作
      set var 变量名=变量值 （循环中用的较多）
      until （跳出循环）

#### 1.5 文件IO
1. 站在内存角度考虑IO，输入为文件到内存，输出为内存到文件
2. 跨平台
  Java通过虚拟跨平台，实际代码运行都在虚拟机内
  C通过调用不同平台的API跨平台
3. 返回值File *fp
   结构体
   - 文件描述符(整型值)：索引到对应的磁盘文件
   - 文件读写指针位置：读写文件过程中指针的实际位置，用于操作读数据和写数据
   - I/O缓冲区（内存地址）：通过寻址找到对应的内存，数据从内存刷新到磁盘     
4. I/O缓冲区
    C库函数先写入缓冲区，再调用LinuxI/O函数写入磁盘
  - 作用 
    提高效率，降低写磁盘的次数（本质是通过内核）
  - 写入磁盘的时机
    1. 刷新缓冲区： fflush
    2. 缓冲区已满
    3. 正常关闭文件
        a.fclose
        b.return(main函数)
        c.exit(main函数)
4. 标准 C 库 IO 和 Linux 系统 IO 的关系
   - 调用和被调用的关系
      用户程序调用C标准I/O库，C标准I/O库写入缓冲区，缓冲区满时调用linux系统I/O，写入磁盘
   - 标准C库函数为高级语言，linux平台I/O函数更低级
   - 磁盘读写时选用标准C库函数，网络通信提高效率使用LinuxI/O函数

#### 1.6 虚拟地址空间 
1. 程序和进程
    程序：磁盘上的代码
    进程：加载到内存中的运行中的程序
2. 32位：2^32 ~ 4G
   64位: 2^48
3. 内核区1G
   - 内存管理
   - 进程管理
   - 设备驱动管理
   - VFS虚拟文件系统
4. 用户区3G
  - 环境变量
  - 命令行参数
  - 栈空间(小)：由高到低存
  - 共享库
  - 堆空间(大)：由低到高存
  - ELF
    未初始化全局变量
    初始化全局变量
    代码段，二进制机器命令
  - 受保护的地址

#### 1.6 文件描述符
1. 文件描述符在内核区，由PCB进程控制块管理
2. 文件描述符表
   - 使用数组存取，为了一个进程可以同时打开多个文件
   - 默认大小为1024，即最大同时可打开文件数目为1024
   - 默认前三为标准输入0，标准输出1，标准错误2，默认为打开状态，与当前终端/dev/tty设备文件绑定
   - 一个文件可以被打开多次，即多个文件描述符可以指定同一文件
   - 每打开一个文件，则占用一个空闲的最小的文件描述符

#### 1.7 Linux I/O函数
1. man 2 open:linux系统I/O函数
   man 3 fopen:标准C库函数
2. open()
   - int open(const char *pathname, int flags);
     - pathname:要打开的文件路径
     - flags：对文件的操作权限设置还有其他设置，互斥
     - 返回值：返回一个新的文件描述符，如果调用失败，返回-1
     - errno：属于linux系统函数库，是其中的一个全局变量，记录的是最近的错误号
   - void perror(const char *s);作用：打印errno对应的错误描述
      s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)
   - int open(const char *pathname, int flags, mode_t mode);
     - 不是函数重载，C是用可变参数实现
     - flags：注意flag为程序内的权限，而mode为程序外的权限
       - 必选项：O_RDONLY,  O_WRONLY, O_RDWR  这三个之间是互斥的
       - 可选项：O_CREAT 文件不存在，创建新文件
         - 使用按位或设置可选项
         - flags参数是一个int类型的数据，占4个字节，32位
         - flags 32个位，每一位就是一个标志位
       - mode
         - 八进制的数，表示创建出的新的文件的操作权限，比如：0775
         - 最终的权限是：mode & ~umask
         - 按位与：0和任何数都为0,umask的作用就是抹去某些权限
            0777   ->   111111111
        &   0775   ->   111111101

                        111111101
3. read()
   - ssize_t read(int fd, void *buf, size_t count);
     - 参数：
       - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件
       - buf：需要读取数据存放的地方，数组的地址（传出参数）
       - count：指定的数组的大小,**一般用sizeof，但对于char\* str = "abc";这种要用strlen()**
     - 返回值：
        - 成功：
           \>0: 返回实际的读取到的字节数
           =0：文件已经读取完了
        - 失败：-1 ，并且设置errno        
4. write()
    - ssize_t write(int fd, const void *buf, size_t count);
       - 参数：
            - fd：文件描述符，open得到的，通过这个文件描述符操作某个文件
            - buf：要往磁盘写入的数据，数据
            - count：要写的数据的实际的大小
       - 返回值：
            成功：实际写入的字节数
            失败：返回-1，并设置errno
5. lseek()
   - off_t lseek(int fd, off_t offset, int whence);
      -  参数：
            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件
            - offset：偏移量
            - whence:
                SEEK_SET
                    设置文件指针的偏移量
                SEEK_CUR
                    设置偏移量：当前位置 + 第二个参数offset的值
                SEEK_END
                    设置偏移量：文件大小 + 第二个参数offset的值
      -  返回值：返回文件指针的位置
     -   作用：
        - 移动文件指针到文件头,避免再次打开文件
        lseek(fd, 0, SEEK_SET);
        - 获取当前文件指针的位置
        lseek(fd, 0, SEEK_CUR);
        - 获取文件长度
        lseek(fd, 0, SEEK_END);
        - 拓展文件的长度，当前文件10b, 110b, 增加了100个字节
        lseek(fd, 100, SEEK_END)
        注意：需要写一次数据， write(fd, " ", 1);
        用途：lseek只是移动指针，还需要写入扩展文件
6. stat()
   - stat test.txt
   - int stat(const char *pathname, struct stat *statbuf);
      - 作用：获取一个文件相关的一些信息
      - 参数:
            - pathname：操作的文件的路径
            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息
      - 返回值：
            成功：返回0
            失败：返回-1 设置errno
   - int lstat(const char *pathname, struct stat *statbuf);
      - 作用：获取软链接而非其指向的文件的信息
   -  ```
      struct stat {
          dev_t st_dev; // 文件的设备编号
          ino_t st_ino; // 节点
          mode_t st_mode; // 文件的类型和存取的权限
          nlink_t st_nlink; // 连到该文件的硬连接数目
          uid_t st_uid; // 用户ID
          gid_t st_gid; // 组ID
          dev_t st_rdev; // 设备文件的设备编号
          off_t st_size; // 文件字节数(文件大小)
          blksize_t st_blksize; // 块大小
          blkcnt_t st_blocks; // 块数
          time_t st_atime; // 最后一次访问时间
          time_t st_mtime; // 最后一次修改时间
          time_t st_ctime; // 最后一次改变时间(指属性)
      };
      ```
   - st_mode变量
     - 4位文件类型+3位特殊权限位+3位User权限位+3位Group权限位+3位Others权限位
     - linux共七种文件
         - S_IFSOCK 0140000 套接字
         - S_IFLNK 0120000 符号链接（软链接）
         - S_IFREG 0100000 普通文件
         - S_IFBLK 0060000 块设备
         - S_IFDIR 0040000 目录
         - S_IFCHR 0020000 字符设备
         - S_IFIFO 0010000 管道
         - S_IFMT 0170000 掩码
     - (st_mode & S_IFMT) == S_IFREG，通过与宏&运算，再与对应文件类型宏进行比较得出其文件类型
     - others文件权限也是通过与宏00007&运算得出，等等
7. sizeof()和strlen()在write()中的区别
   - write(fd, buf, strlen(buf));向文件中写入内容的是，只会把缓冲区中的有效内容全部拷贝到文件中。
   - write(fd, buf, sizeof(buf));会把缓冲区中的所有数据拷贝到文件中
#### 1.8 Linux 文件属性操作函数
1. access()
   - int access(const char *pathname, int mode);
     - 作用：判断某个文件是否有某个权限，或者判断文件是否存在
     - 参数：
         - pathname: 判断的文件路径
         - mode:
                R_OK: 判断是否有读权限
                W_OK: 判断是否有写权限
                X_OK: 判断是否有执行权限
                F_OK: 判断文件是否存在
     - 返回值：成功返回0， 失败返回-1
2. chmod()
   -  int chmod(const char *pathname, mode_t mode);
      - 修改文件的权限
      -  参数：
            - pathname: 需要修改的文件的路径
            - mode:需要修改的权限值，八进制的数
            - r:4,w:2,x:1
      -  返回值：成功返回0，失败返回-1
   - int chown(const char *path, uid_t owner, gid_t group);
     - 修改文件的所有者和所有组
     - uid:etc/passwd
     - gid:etc/group
   - useradd
   - id ubuntu
3. truncate()
   - int truncate(const char *path, off_t length);
     - 作用：缩减或者扩展文件的尺寸至指定的大小
     - 参数：
        - path: 需要修改的文件的路径
        - length: 需要最终文件变成的大小
     - 返回值：
         成功返回0， 失败返回-1

#### 1.9 Linux 目录操作函数
1. mkdir()
   - mkdir命令和mkdir函数不同
   - int mkdir(const char *pathname, mode_t mode);
       - 作用：创建一个目录
       - 参数：
            pathname: 创建的目录的路径
            mode: 权限，八进制的数,会与掩码进行与操作
       - 返回值：
            成功返回0， 失败返回-1
2. int rmdir(const char *path)
   只能删除空目录
3. int rename(const char *oldpath, const char *newpath)
4. chdir()
   - int chdir(const char *path);
       - 作用：修改进程的工作目录
            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder
       - 参数：
            path : 需要修改的工作目录
5. getcwd()
   - char *getcwd(char *buf, size_t size);
       - 作用：获取当前工作目录
       - 参数：
            - buf : 存储的路径，指向的是一个数组（传出参数）
            - size: 数组的大小
       - 返回值：
            返回的指向的一块内存，这个数据就是第一个参数
<<<<<<< HEAD

#### 1.10 Linux目录遍历函数
1. opendir()
   - 流stream
      一切能被读写的都是文件，流是读写文件的抽象
      流就是读一点数据, 处理一点点数据
   - DIR *opendir(const char *name);
      - 参数：
            - name: 需要打开的目录的名称
      - 返回值：
            DIR * 类型，理解为目录流，一开始指向数据最前面
            错误返回NULL
2. readdir()
   - struct dirent *readdir(DIR *dirp);
        - 参数：dirp是opendir返回的结果
        - 返回值：
            struct dirent，代表读取到的文件的信息
            读取到了末尾或者失败了，返回NULL
   - ```
      struct dirent
      {
      // 此目录进入点的inode
      ino_t d_ino;
      // 目录文件开头至此目录进入点的位移
      off_t d_off;
      // d_name 的长度, 不包含NULL字符
      unsigned short int d_reclen;
      // d_name 所指的文件类型
      unsigned char d_type;
      // 文件名
      char d_name[256];
      };
     d_type
      DT_BLK - 块设备
      DT_CHR - 字符设备
      DT_DIR - 目录
      DT_LNK - 软连接
      DT_FIFO - 管道
      DT_REG - 普通文件
      DT_SOCK - 套接字
      DT_UNKNOWN - 未知
     ``` 
3. int closedir(DIR *dirp);

#### 1.11 dup,dup2,fcntl函数
1. dup()
   - int dup(int oldfd);
      - 作用：复制一个新的文件描述符
        fd=3, int fd1 = dup(fd),
        fd指向的是a.txt, fd1也是指向a.txt
        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符
2. dup2()
   - int dup2(int oldfd, int newfd);
      - 作用：重定向文件描述符
        oldfd 指向 a.txt, newfd 指向 b.txt
        调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt
        oldfd 必须是一个有效的文件描述符
        oldfd和newfd值相同，相当于什么都没有做
      - 返回描述符，与被newfd相同
3. fcntl()
   - int fcntl(int fd, int cmd, ...);
   - 作用：
      复制文件描述符
      设置/获取文件的状态标志
   - 参数：
      - fd : 表示需要操作的文件描述符
      - ...:可变参数
      - cmd: 表示对文件描述符进行如何操作
         - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）
             int ret = fcntl(fd, F_DUPFD);
         - F_GETFL : 获取指定的文件描述符文件状态flag
              获取的flag和我们通过open函数传递的flag是一个东西
         - F_SETFL : 设置文件描述符文件状态flag
              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改
              可选性：O_APPEND, O_NONBLOCK
                O_APPEND 表示追加数据,flag也是一系列二进制，所以需要使用flag |= O_APPEND来进行修改,也必须要有写权限
                如果想去除则 |= ~即可，即先get，再flag |= ~O_APPEND，再set
                NONBLOK 设置成非阻塞
      - 阻塞和非阻塞：描述的是函数调用的行为



### 2. Linux 多进程开发
#### 2.1 进程
1. 程序
   程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程
   - 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）
   - 机器语言指令：对程序算法进行编码。
   - 程序入口地址：标识程序开始执行时的起始指令位置。
   - 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。
   - 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。
   - 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。
   - 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。
2. 进程
   - 和程序的区别
      进程占用内存，CPU等资源，而程序只占用磁盘 
   - 进程是正在运行的程序的实例。 进程既是基本的分配单元，也是基本的执行单元。
   - 可以用一个程序来创建多个进程，**进程是内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源**。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息
3. 单道与多道
   - 单道程序，即在计算机内存中只允许一个的程序运行。
   - 多道程序
      多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率
   - 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻， CPU 上运行的程序只有一个
   - 在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级， 1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行
4. 时间片
   - 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－ 800ms），用户不会感觉到。
   - 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。
   - 时间片不能太短，切换的时间开销大；也不能太长，否则宏观上不能同时执行
5. 并行与并发
   - 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。
   - 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行
6. 进程控制块（PCB）
   - 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。
   - 在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可：
     - 进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数
     - 进程的状态：有就绪、运行、挂起、停止等状态
     - 进程切换时需要保存和恢复的一些CPU寄存器
     - 描述虚拟地址空间的信息
     - 描述控制终端的信息
     - 当前工作目录（Current Working Directory）
     - umask 掩码
     - 文件描述符表，包含很多指向 file 结构体的指针
     - 和信号相关的信息
     - 用户 id 和组 id
     - 会话（Session）和进程组
     - 进程可以使用的资源上限（Resource Limit）,ulimit -a 命令查看

#### 2.2 进程状态转换
1. 进程的状态
   - 进程状态反映进程执行过程的变化。这些状态随着**进程的执行和外界条件的变化**而转换。
   - 在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态
   - 运行态：进程占有处理器正在运行
   - 就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列
   - 阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成,如sleep()，等待用户输入等。阻塞态不能直接变为运行态，因为阻塞时已经释放了资源CPU，需要重新进入就绪队列以获取
   - 新建态：进程刚被创建时的状态，尚未进入就绪队列
   - 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。终止态删除用户空间的资源，但还保留内核空间的资源。就绪态和阻塞态也可以直接转为终止态。
2. 进程相关命令
   - 查看进程
      ps aux / ajx
      a：显示终端上的所有进程，包括其他用户的进程
      u：显示进程的详细信息
      x：显示没有控制终端的进程，查看当前终端信息：tty
      j：列出与作业控制相关的信息
   - STAT参数意义：
      D 不可中断 Uninterruptible（usually IO）
      R 正在运行，或在队列中的进程
      S(大写) 处于休眠状态
      T 停止或被追踪
      Z 僵尸进程
      W 进入内存交换（从内核2.6开始无效）
      X 死掉的进程
      < 高优先级
      N 低优先级
      s 包含子进程
      + 位于前台的进程组
3. 实时显示进程动态
    - top
      可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令
      执行后，可以按以下按键对显示的结果进行排序：
      - M 根据内存使用量排序
      - P 根据 CPU 占有率排序
      - T 根据进程运行时间长短排序
      - U 根据用户名来筛选进程
      - K 输入指定的 PID 杀死进程
    - 杀死进程
      kill [-signal] pid
      kill –l 列出所有信号
      kill –SIGKILL 进程ID
      kill -9 进程ID
      killall name 根据进程名杀死进程
4. 进程号与进程组
    - 每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围： 0～ 32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。
    - 任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。
    - 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。
    -  进程号和进程组相关函数：
      pid_t getpid(void);
      pid_t getppid(void);
      pid_t getpgid(pid_t pid);
    - 大部分进程的父进程都是当前终端，如bash

#### 2.3 进程创建
1. fork()
   pid_t fork(void);
   - 函数的作用：用于创建子进程。
   - 返回值：
            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。
            在父进程中返回创建的子进程的ID,
            在子进程中返回0
            如何区分父进程和子进程：通过fork的返回值。
            在父进程中返回-1，表示创建子进程失败，并且设置errno
   - 失败的两个主要原因：
     1. 当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN
     2. 系统内存不足，这时 errno 的值被设置为 ENOMEM 
2. 父子进程虚拟地址空间
   - 内核空间
      子进程内核空间拷贝父进程，但各自的PID不同
   - 用户空间
      子进程用户空间拷贝父进程
      - 代码也是完全相同，但执行不同
      - fork()在父进程中执行，不在子进程中执行，但是返回值PID(和内核PID不一样)作为临时变量分布存储在父子进程的栈空间，父进程存储子进程PID，子进程为0
      - 子父进程同名局部变量互不影响
   - fork的实现:读时共享，写时拷贝 (copy- on-write)
     - 实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。
     - 写时拷贝是一种可以推迟甚至避免拷贝数据的技术,节约内存空间，减少拷贝时的时间消耗
     - 内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。
     - 注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针
3. 父子进程之间的关系：
   - 区别：
      1.fork()函数的返回值不同
                父进程中: >0 返回的子进程的ID
                子进程中: =0
      2.pcb中的一些数据
                当前的进程的id pid
                当前的进程的父进程的id ppid
                信号集
   - 共同点：
      某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作
                用户区的数据
               文件描述符表
        
   -  父子进程对变量是不是共享的？
      刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。所以不能用变量进行通信。
      读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。

#### 2.4 GDB多进程调试
1. 使用 GDB 调试的时候， GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。
2. 设置调试父进程或者子进程： set follow-fork-mode [parent（默认） | child]
3. 设置调试模式： set detach-on-fork [on | off]默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。
4. 查看调试的进程： info inferiors
5. 切换当前调试的进程： inferior id
6. 使进程脱离 GDB 调试： detach inferiors id

#### 2.5 exec函数族
1. 函数族
   C语言中没有函数重载概念，使用函数族，指一系列功能类似的函数
2. exec 函数族
   - exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容（而不是再创建一个进程），换句话说，就是在调用进程内部执行一个可执行文件。一般使用时，先fork()再在子进程中调用，避免替换父进程内容。
   - exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。
   - execve()为linux系统函数，其他函数为在前者上分装后的C标准库函数。
3. execl()
   - int execl(const char *path, const char *arg, ...);
   - 参数：
       - path:需要指定的执行的文件的路径或者名称,也可执行shell命令如ps
                a.out /home/nowcoder/a.out 推荐使用绝对路径
                ./a.out hello world
       - arg:是执行可执行文件所需要的参数列表
                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
                从第二个参数开始往后，就是程序执行所需要的的参数列表。
                参数最后需要以NULL结束（哨兵）
   - 返回值：
            只有当调用失败，才会有返回值，返回-1，并且设置errno
            如果调用成功，没有返回值。因为调用成功后代码区被替换，是不可能收到返回值的。
4. execlp()
   - int execlp(const char *file, const char *arg, ... );
   - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。
   - 参数：
      - file:需要执行的可执行文件的文件名
                a.out
                ps
      - arg:是执行可执行文件所需要的参数列表
                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
                从第二个参数开始往后，就是程序执行所需要的的参数列表。
                参数最后需要以NULL结束（哨兵）
      - 返回值：
            只有当调用失败，才会有返回值，返回-1，并且设置errno
            如果调用成功，没有返回值。
5. 其他函数
   - int execle(const char *path, const char *arg, .../*, (char *) NULL, char *
   const envp[] */);
   - int execv(const char *path, char *const argv[]);
   - int execvp(const char *file, char *const argv[]);
   - int execvpe(const char *file, char *const argv[], char *const envp[]);
   - int execve(const char *filename, char *const argv[], char *const envp[]);
   - 说明
      l(list) 参数地址列表，以空指针结尾
      v(vector) 存有各参数地址的指针数组的地址
      p(path) 按 PATH 环境变量指定的目录搜索可执行文件
      e(environment) 存有环境变量字符串地址的指针数组的地址，即自己指定的地址,char* test[]={"","",""};

#### 2.6 进程控制
1. 进程退出
   - C标准库： #include <stdlib.h>
     - void exit(int status);
     - 调用退出处理函数->刷新I/O缓冲并关闭文件描述符->调用_exit()系统调用
     - 如'\n'会刷新缓冲区，但是如果print("world");_exit(0);则不会刷新缓冲区，无输出
   - Linux系统库： #include <unistd.h>
     - void _exit(int status);
     - 调用_exit()系统调用
     - 退出进程，用的多
   - status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到。
2. 孤儿进程
   - 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。
   - 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init（pid == 1） ，而 init进程会循环地 wait() 它的已经退出的子进程。最后由init进程回收孤儿进程的资源。
   - 孤儿资源没有危害
   - 例
      终端为a进程的父进程，a进程运行时，终端进程切换到后台，a进程运行结束，终端进程切换到前台（因为是a的父进程，知道a已结束）。但是如果a进程的子进程还在运行，则仍会输出到屏幕上，因为子进程复制了a进程的文件描述符表
3. 僵尸进程
   - 每个进程结束之后, 都会释放自己地址空间中的用户区数据，但内核区的 PCB 没有办法自己释放掉，需要父进程去释放
   - 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程
   - 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait()或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免
   - 结束僵尸进程需要结束父进程让进程为1的进程托管，可以用ctrl+c但不方便，所以一般让父进程调用wait()或waitpid()
4. 进程回收
   - 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。
   - 主动：父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程
   - 被动：结束父进程，子进程成为孤儿进程被1号进程接管
   - wait() 和 waitpid() 函数的功能一样，区别在于， wait() 函数会阻塞，waitpid() 可以设置不阻塞， waitpid() 还可以指定等待哪个子进程结束。
   - 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。
5. wait()
   - pid_t wait(int *wstatus);
      - 功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。
      - 参数：int *wstatus
            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。**注意由于是传出参数，所以实际写程序时，写得是对应的地址**
      - 返回值：
            - 成功：返回被回收的子进程的id
            - 失败：-1 (所有的子进程都结束，调用函数失败)
   - 调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1
   - status
     - WIFEXITED(status) 非0，进程正常退出
     - WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）
     - WIFSIGNALED(status) 非0，进程异常终止
     - WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号
     - WIFSTOPPED(status) 非0，进程处于暂停状态
     - WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号
     - WIFCONTINUED(status) 非0，进程暂停后已经继续运行

6. 通过循环建立多个进程
``` 
    pid_t pid;
    for(int i = 0; i < 5; i++) {
        pid = fork();
        if(pid == 0) {
            break; //否则将嵌套建立一共 5 + 4 + 3 + 2 + 1 个进程
        }
    }
```
7. waitpid()
pid_t waitpid(pid_t pid, int *wstatus, int options);
   - 功能：回收指定进程号的子进程，可以设置是否阻塞。
   - 参数：
      - pid:
                pid > 0 : 某个子进程的pid
                pid = 0 : 回收当前进程组的任意子进程    
                pid = -1 : 回收任意的子进程，相当于 wait()  （最常用）
                pid < -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程
      - options：设置阻塞或者非阻塞
                0 : 阻塞
                WNOHANG : 非阻塞
      - 返回值：
                > 0 : 返回子进程的id
                = 0 : options=WNOHANG, 表示还有子进程活着
                = -1 ：错误，或者没有子进程了
      - 非阻塞好处：父进程不用一直挂起，可以执行waitpid()代码之后的内容，最后再循环回来
   - 进程组
      单个进程默认进程组ID就是其PID，父进程的子进程可以分布在不同的进程组内
8. return 0 相当于exit(0)

#### 2.7 进程间通信(IPC)
1. 进程间通信概念
- 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间
的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。
- 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程
间通信( IPC： Inter Processes Communication )。
- 进程间通信的目的：
  - 数据传输：一个进程需要将它的数据发送给另一个进程。
  - 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种
事件（如进程终止时要通知父进程）。
  - 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同
步机制。
  - 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制
进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

2. 进程间通信方式  **重点**
- 同一主机进程间通信
  - Unix进程间通信方式
    - 匿名管道
    - 有名管道
    - 信号
  - System V进程间通信方式
    - 消息队列
    - 共享内存
    - 内存映射
    - 信号量
- 不同主机(网络)进程间通信
  - socket套接字

#### 2.8 匿名管道(pipe)
1. 简介
    - 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。
    - 统计一个目录中文件的数目命令： ls | wc –l，为了执行该命令， shell 创建了两个进程来分别执行 ls 和 wc。ls： stdout(fd 1)--->管道--->wc：stdin(fd 0)
2. 特点
    - 管道其实是一个在内核内存中维护的缓冲器（其实就是内存中的缓冲区），这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。
    - 管道拥有文件的特质：读操作、写操作（通过两端的文件描述符），匿名管道没有文件实体，有名管道有文件实体，但不存储数据（数据也存储在内存）。可以按照操作文件的方式对管道进行操作。
    - 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。（而消息一次只能读对应个消息）
    - 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。（因为管道的数据结构为环形队列）
    - 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。
    - 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。
    - 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。
    - 管道缓冲区在内核空间的内存中，进程缓存区在用户空间（栈，堆）的内存中。写入读取时系统调用read(),write()
3. 管道进行进程间通信的原理
   fork()后的父子进程共享同一文件描述表，比方说父进程5执行管道写段，6指向管道读段，fork()后子进程也一样，可以进行半双工通信，即同一时刻仅可以父向子或者子向父
4. 管道的数据结构
  循环队列，内存中不一定是环形，通过逻辑手段构造成环形，极大节约了空间。所以数据只能使用一次
5. pipe()
   int pipe(int pipefd[2]);
   - 功能：创建一个匿名管道，用来进程间通信。
   - 参数：int pipefd[2] 这个数组是一个传出参数。**这里传递的是数组的地址**
           pipefd[0] 对应的是管道的读端
           pipefd[1] 对应的是管道的写端
   - 返回值：
            成功 0
            失败 -1
   - 注意：
     - 要实现父子进程通信一定要在创建子进程之前创建管道，否则父子描述符不共享
     - 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞
     - 匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）
     - 管道是半双工的，注意父子进程读写顺序要相反，否则阻塞或者多读少读
     - 不加sleep()容易导致自己读自己，**一般不用管道做双向的数据传递**，一般每个进程只读或者写，关闭其他的端口
   - 关闭读/写端
     close(pipefd[0]);close(pipefd[1]);
   - 清除缓冲区buf
      memset(buf, 0, 1024);读完写完都需要清空
   - 父进程读数据需要留一个位置给结束符
      len = read(fd[0], buf, sizeof(buf) - 1)
   - 查看管道缓冲大小命令
      ulimit -a:8 * 412 = 4096 bit
   - 查看管道缓冲大小函数
      long size = fpathconf(pipefd[0], _PC_PIPE_BUF);
6. 管道的读写特点
- 读管道：
    - 管道中有数据，read返回实际读到的字节数。
    - 管道中无数据：
            写端被全部关闭（通过写段计数器查看），read返回0（相当于读到文件的末尾）
            写端没有完全关闭，read阻塞等待（**可以设置读写非阻塞，即返回-1后继续执行**）
- 写管道：
    - 管道读端全部被关闭（通过读端计数器查看），进程异常终止（进程收到SIGPIPE信号）
    - 管道读端没有全部关闭：
            管道已满，write阻塞
            管道没有满，write将数据写入，并返回实际写入的字节数

7. 设置管道读写非阻塞
   - 注意：这样设置的flag是管道读写端文件描述符的flag，而不是read和write的flag
   ```
   int flags = fcntl(pipefd[0], F_GETFL);
   flags |= O_NONBLOCK;
   fcntl(pipefd[0], F_SETFL, flags);
   ```

#### 2.9 有名管道（FIFO）
1. 匿名管道的缺点
匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、 FIFO文件。
2. 管道文件（FIFO）
有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。
3. 先入先出
一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I/O系统调用了（如read()、 write()和close()）。与管道一样， FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。 FIFO 的名称也由此而来：先入先出。
4. 有名管道（FIFO）和匿名管道（pipe）的区别
    1. FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。
    2. 当使用 FIFO 的进程退出后， FIFO 文件将继续保存在文件系统中以便以后使用。
    3. FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。
5. 创建有名管道
    - 创建有名管道
      mkfifo 名字
    - 通过函数创建有名管道
      int mkfifo(const char *pathname, mode_t mode);
       - 参数：
         - pathname: 管道名称的路径
         - mode: 文件的权限 和 open 的 mode 是一样的是一个八进制的数
       - 返回值：成功返回0，失败返回-1，并设置错误号
    - 一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I/O 函数都可用于 fifo。如： close、 read、 write、 unlink 等。
    - FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek()等文件定位操作。
6. 有名管道的读写特点
   - 一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道
   - 一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道
   - 其他和匿名管道读写特点相同
7. 例：使用有名管道完成聊天的过程
   通过把读写进程分别放在子父进程内，完成聊天的并发，防止阻塞

#### 2.10 内存映射
1. 内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。先映射到虚拟内存的共享库部分。
2. 效率较高，直接对内存的操作 
    - mmap()把硬盘文件映射到内存（内核缓存区），不用拷贝数据，但这里没有减少上下文的切换（因为都在内核态），
    - 注意在网络传输（如socket零拷贝）中，内存映射是映射内核缓存区的数据到进程缓存区，也不用拷贝数据，这次没有减少上下文切换，mmap()也是系统调用
    - 从硬盘中拷贝数据到内核缓冲区不需要系统调用read()，都在内核态，不需要切换上下文
    - 内核缓存区与进程缓存区都在内存中
3. 如何完成进程间通信
   - 将硬盘文件映射到两个进程的虚拟空间中，修改即同步，即完成进程间通信
   - 可实现有关系的进程映射（匿名映射），没关系的进程映射（文件映射）
4. mmap()
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
   - 功能：将一个文件或者设备的数据映射到内存中
   - 参数：
       - void *addr: NULL, 由内核指定
       - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。
                  **获取文件的长度：stat lseek**
                  实际分配的空间是分页的整数倍
       - prot : 对申请的内存映射区的操作权限
                PROT_EXEC ：可执行的权限
                PROT_READ ：读权限
                PROT_WRITE ：写权限
                PROT_NONE ：没有权限
                要操作映射内存，必须要有读的权限： PROT_READ、PROT_READ|PROT_WRITE
       - flags :
          - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项
          - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）
       - fd: 需要映射的那个文件的文件描述符
          - 通过open得到，open的是一个磁盘文件
          - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。
                    prot: PROT_READ                open:只读/读写 
                    prot: PROT_READ | PROT_WRITE   open:读写
       - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移。
    - 返回值：返回创建的内存的首地址
         失败返回MAP_FAILED，(void *) -1
5. munmap()     
int munmap(void *addr, size_t length);
- 功能：释放内存映射
- 参数：
    - addr : 要释放的内存的首地址,(char*)强制转换
    - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。
6. 使用内存映射实现进程间通信：
    1. 有关系的进程（父子进程）
        - 还没有子进程的时候
            - 通过唯一的父进程，先创建内存映射区（这里好像后创建也行）
        - 有了内存映射区以后，创建子进程
        - 父子进程共享创建的内存映射区  
    2. 没有关系的进程间通信
        - 准备一个大小不是0的磁盘文件
        - 进程1 通过磁盘文件创建内存映射区
            - 得到一个操作这块内存的指针
        - 进程2 通过磁盘文件创建内存映射区
            - 得到一个操作这块内存的指针
        - 使用内存映射区通信
7. 使用内存映射实现文件拷贝
   - 两个文件同时映射到内存中，没有产生上下文切换，只是内存内的拷贝，速度非常快
   - memcpy(new, old, size);
   - 后创建的资源先释放，防止有依赖关系
   - 一般不用内存映射做文件拷贝，因为对于大数据拷贝，内存可能容量不够
8. 匿名映射
   - MAP_SHARED | MAP_ANONYMOUS
   - 不需要文件实体进程一个内存映射
   - 只能做父子进程之间的通信，不能做没有关系的进程间的通信
   - 注意内存映射为非阻塞，子进程必须sleep(1)手动等待父进程输入完成
9.  内存映射注意事项
   - 内存映射区通信，是非阻塞的
   - 如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?
   void * ptr = mmap(...);
   ptr++;  可以对其进行++操作
   munmap(ptr, len);   // 错误,要保存地址
   - 如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?
   错误，返回MAP_FAILED
   open()函数中的权限建议和prot参数的权限保持一致。
   - 如果文件偏移量为1000会怎样?
   偏移量必须是4K的整数倍，返回MAP_FAILED
   - mmap什么情况下会调用失败?
       - 第二个参数：length = 0
       - 第三个参数：prot
           - 只指定了写权限
           - prot PROT_READ | PROT_WRITE
             第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY
   - 可以open的时候O_CREAT一个新文件来创建映射区吗?
       - 可以的，但是创建的文件的大小如果为0的话，肯定不行
       - 可以对新的文件进行扩展
           - lseek()
           - truncate()
   - mmap后关闭文件描述符，对mmap映射有没有影响？
       int fd = open("XXX");
       mmap(,,,,fd,0);
       close(fd); 
       映射区还存在，创建映射区的fd被关闭，没有任何影响。
   - 对ptr越界操作会怎样？
   void * ptr = mmap(NULL, 100,,,,,);
   4K
   越界操作操作的是非法的内存 -> 段错误


#### 2.11 信号
1. 信号
信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为**软件中断**，它是在软件层次上对中断机制的一种模拟，是一种**异步通信**的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
2. 内核为进程产生信号的各类事件
    - 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。
    - 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。
    - 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU时间超限，或者该进程的某个子进程退出。
    - 运行 kill 命令或调用 kill 函数。
3. 目的
   - 让进程知道已经发生了一个特定的事情。
   - 强迫进程执行它自己代码中的信号处理程序。
4. 信号的特点：
   - 使用简单
   - 不能携带大量信息
   - 满足某个特定条件才发送
   - 优先级比较高
5. 重要的信号（不同架构信号值不同，X86%ARM）
   - 2：SIGINT
      当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号
      终止进程
   - 3：SIGQUIT
      用户按下<Ctrl+\>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号
      终止进程
   - 9：SIGKILL
      无条件终止正常的进程（僵尸进程不能被该信号终止）。该信号不能被忽略，处理和阻塞
      终止进程，可以杀死任何正常进程
   - 11：SIGSEGV(segmentation violation)
      指示进程进行了无效内存访问(段错误)
      终止进程并产生core文件
   - 13：SIGEPIPE
      open pipe向一个没有读端的管道写数据
      终止进程
   - 17: SIGCHLD
      子进程结束或暂停时，父进程会收到这个信号
      忽略这个信号
   - 18：SIGCONT
      如果进程已停止，则使其继续运行
      继续/忽略
   - 19：SIGSTOP 
      停止进程的执行。信号不能被忽略，处理和阻塞
      终止进程
6. 一些终端命令
   - 查看系统定义的信号列表： kill –l
   - 前 31 个信号为常规信号，其余为实时信号
   - 查看信号的详细信息： man 7 signal
7. 信号的五种默认处理动作
   - Term 终止进程
   - Ign 当前进程忽略掉这个信号
   - Core 终止进程，并生成一个Core文件，异常写入其中
   - Stop 暂停当前进程
   - Cont 继续执行当前被暂停的进程
8. 信号的三种状态：产生、未决、递达
9. SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作

#### 2.12 信号相关函数
1. core文件生成
   - gcc core.c -g
   - ulimit -c 1024
   - ubuntu预装了apport错误收集系统，sudo service apport stop
   - gdb命令：core-file core,调试时查看错误信息
2. kill()
int kill(pid_t pid, int sig);
   - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig
   - 参数：
      - pid ：
                > 0 : 将信号发送给指定的进程
                = 0 : 将信号发送给当前的进程组
                = -1 : 将信号发送给每一个有权限接收这个信号的进程
                < -1 : 这个pid=某个进程组的ID取反 （-12345）
      - sig : 需要发送的信号的编号或者是宏值(建议使用宏值，不同系统一致)，0表示不发送任何信号
        kill(getppid(), 9);
        kill(getpid(), 9);
      - 多进程父子进程谁先谁后不确定，都在抢占CPU资源
3. raise()
int raise(int sig);
   - 功能：给当前进程发送信号
   - 参数：
            - sig : 要发送的信号
   - 返回值：
            - 成功 0
            - 失败 非0
        kill(getpid(), sig);   
3. abort()
void abort(void);
   - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程
        kill(getpid(), SIGABRT);
4. alarm()
   unsigned int alarm(unsigned int seconds);
   - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，
                函数会给当前的进程发送一个信号：SIGALARM
   - 参数：
      seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。
               取消一个定时器，通过alarm(0)。
   - 返回值：
      - 之前没有定时器，返回0
      - 之前有定时器，返回之前的定时器剩余的时间
   - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器,会覆盖之前的定时器
        alarm(10);  -> 返回0
        过了1秒
        alarm(5);   -> 返回9
   - alarm(100) -> 该函数是不阻塞的
   - alarm时间 = 用户时间 + 内核时间 (即在用户态和内核态的时间)
      - 实际的时间 = 内核时间(系统调用时间) + 用户时间(普通代码执行时间) + 消耗的时间(操作IO等消耗的时间)
      - 定时器，与进程的状态无关（自然定时法）。无论进程处于什么状态(如sleep阻塞)，alarm都会计时
      - 例：printf()到终端和直接重定向，输出的数字后者多很多
5. setitimer()
int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);
   - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微秒us，可以实现周期性定时
   - 参数：
      - which : 定时器以什么时间计时
              ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   **常用**
              ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM
              ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF

      - new_value: 设置定时器的属性

                struct itimerval {      // 定时器的结构体
                struct timeval it_interval;  // 每个阶段的时间，间隔时间
                struct timeval it_value;     // 延迟多长时间执行定时器,即第一次发送信号
                };

                struct timeval {        // 时间的结构体
                    time_t      tv_sec;     //  秒数     
                    suseconds_t tv_usec;    //  微秒    
                };
      - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL 
   - 也是非阻塞的
   - 返回值：
            成功 0
            失败 -1 并设置错误号
6. signal()
sighandler_t signal(int signum, sighandler_t handler);
   - 功能：设置某个信号的捕捉行为
   - 参数：
      - signum: 要捕捉的信号
      - handler: 捕捉到信号要如何处理
            - SIG_IGN ： 忽略信号
            - SIG_DFL ： 使用信号默认的行为
            - 回调函数
               - typedef void (*sighandler_t)(int);函数指针, int类型的参数表示捕捉到的信号的值
               - 这个函数是**内核调用**，程序员只负责写，捕捉到信号后如何去处理信号。
               - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义
               - 不是程序员调用，而是当信号产生，由内核调用（执行还是在用户空间执行的）
               - 函数指针是实现回调的手段，函数实现之后，将函数名(即函数的地址)放到函数指针的位置就可以了。
   - 返回值：
      成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL
      失败，返回SIG_ERR，设置错误号
   - 要先注册信号捕捉,再产生信号
   - SIGKILL SIGSTOP不能被捕捉，不能被忽略。例:防止病毒程序

#### 2.13 信号集
1. 简介
   - 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。
   - 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图（0101011...其实就一个64位的长整数）机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。
2. 未决
   信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。
3. 阻塞
   - 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。
   - 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。
4. 阻塞信号集与未决信号集
   - 用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)
   - 信号产生但是没有被处理 （未决）
      - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）
      - SIGINT信号状态被存储在第二个标志位上
        - 这个标志位的值为0， 说明信号不是未决状态
        - 这个标志位的值为1， 说明信号处于未决状态
   - 这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较
      - 阻塞信号集默认不阻塞任何的信号
      - 如果想要阻塞某些信号需要用户调用系统的API
   - 在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了
      - 如果没有阻塞，这个信号就被处理
      - 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理
   - 只能修改阻塞信号集，未决信号集只能被获取
5. 自定义信号集函数
以下信号集相关的函数都是对**自定义的信号集**进行操作。
   - int sigemptyset(sigset_t *set);
      - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0,记得设置信号集之前都要清空，防止栈内的随机数据
      - 参数：set,传出参数，需要操作的信号集
      - 返回值：成功返回0， 失败返回-1
   - int sigfillset(sigset_t *set);
      - 功能：将信号集中的所有的标志位置为1
      - 参数：set,传出参数，需要操作的信号集
      - 返回值：成功返回0， 失败返回-1
   - int sigaddset(sigset_t *set, int signum);
      - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号
      - 参数：
         - set：传出参数，需要操作的信号集
         - signum：需要设置阻塞的那个信号
      - 返回值：成功返回0， 失败返回-1
   - int sigdelset(sigset_t *set, int signum);
      - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号
      - 参数：
         - set：传出参数，需要操作的信号集
         - signum：需要设置不阻塞的那个信号
      - 返回值：成功返回0， 失败返回-1
   - int sigismember(const sigset_t *set, int signum);
      - 功能：判断某个信号是否阻塞
      - 参数：
         - set：需要操作的信号集
         - signum：需要判断的那个信号
      - 返回值：
         1 ： signum被阻塞
         0 ： signum不阻塞
         -1 ： 失败
6. 内核信号集函数(是系统调用函数)
   - int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
     - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）
     - 参数：
        - how : 如何对内核**阻塞信号集**进行处理
              SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变
                 假设内核中默认的阻塞信号集是mask， mask | set
              SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞
                 mask &= ~set，即用户的信号集为1，则解除内核的信号集对应位置的1
              SIG_SETMASK:覆盖内核中原来的值
        - set ：已经初始化好的用户自定义的信号集
        - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL
     - 返回值：
        成功：0
        失败：-1，设置错误号：EFAULT（set，oldset指向错误地址）、EINVAL（how非法）
   - int sigpending(sigset_t *set);
     - 功能：获取内核中的**未决信号集**
     - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。
7. 第二个信号捕捉函数
   - int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
      - 是系统调用函数
      - 功能：检查或者改变信号的处理。信号捕捉
      - 参数：
         - signum : 需要捕捉的信号的编号或者宏值（信号的名称）
         - act ：捕捉到信号之后的处理动作
         - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL
      - 返回值：
         成功 0
         失败 -1
```
struct sigaction {
   // 函数指针，指向的函数就是信号捕捉到之后的处理函数
   void     (*sa_handler)(int);
   // 不常用
   void     (*sa_sigaction)(int, siginfo_t *, void *);
   // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。每次调用sigaction之前记得要清空。阻塞了就相当于忽略该信号
   sigset_t   sa_mask;
   // 使用哪一个信号处理对捕捉到的信号进行处理
   // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction
   int        sa_flags;
   // 被废弃掉了
   void     (*sa_restorer)(void);
};
```
8. 内核实现信号捕捉的过程
   1. 在执行主控制流程的某条指令时因为中断、异常或系统调用进入内核
   2. 内核处理完异常准备回用户模式之前先处理当前进程中可以递送的信号
   3. 如果信号的处理动作为自定义的信号处理函数，则回到用户模式执行信号处理函数（而不是回到主控制流程）
   4. 信号处理函数返回时执行特殊的系统调用sigreturn再次进入内核
   5. 返回用户模式从主控制流程中上次被中断的地方继续向下执行
9. 一些注意事项
   - 尽量避免使用signal（不同的标准可能形式不一样），尽量使用sigaction
   - 如果信号处理函数正在处理第一个SIGALRM信号，然后又来了SIGALRM一个信号，后来的SIGALRM信号会默认被屏蔽，只有等前一个回调函数执行完，才会执行下一个回调函数
   - 执行信号捕捉函数时用的临时信号集，回调完后会切换到内核系统的阻塞信号集。也就说有两种对信号的处理方式，一种是sigprocmask处理的内核的阻塞信号集，还有一种是sigaction的临时信号集的处理。
   - 常规信号不支持排队，未决信号集只能标记一次的状态，即只能记录一个信号是否是未决，当其中某个信号被阻塞时，后面如果又来了相同的信号，它们都会被丢弃（其他序号32后面的支持排队）
10. SIGCHLD信号
    - SIGCHLD信号产生的3个条件：
      1. 子进程结束
      2. 子进程暂停了
      3. 子进程继续运行
    - 以上三种情况内核都会给父进程发送该信号，父进程默认忽略该信号。
    - 作用：使用SIGCHLD信号解决僵尸进程的问题。
      - 之前是用wait()再让父进程循环，但是wait()是阻塞的，父进程也需要执行自己的命令。子进程结束时可以用信号捕捉函数捕捉到SIGCHLD信号来解决僵尸进程。
      - 在回调函数内写wait()回收发送SIGCHLD信号的子进程，但是当回调函数执行中时又来了多个SIGCHLD信号，多余的信号都会被丢弃，会导致有部分子进程未被回收
      - 改进方案是通过非阻塞的waitpid来回收进程，设置循环，循环内调用waitpid()一旦收到SIGCHLD信号，就把所有已经死亡的子进程的资源回收，如果还有未回收的子进程或者所有子进程已死亡，break，通过回调函数回到父进程执行位置（不需要关心有多少个SIGCHID的信号被忽略了，因为收到一个就会回收所有的已死亡的子进程）
      - 要提前在主函数中设置好对应的阻塞信号集，因为有可能子进程很快结束，而父进程还没有注册完信号捕捉。在创建子进程前设置好阻塞信号集，在父进程执行中解除阻塞信号集即可。
      ```
      while(1) {
        int ret = waitpid(-1, NULL, WNOHANG);
        if(ret > 0) {
            printf("child die, pid = %d\n", ret);
        } else if(ret == 0) {
            break;
        } else if(ret == -1) {
            break;
        }
      } 
     ```

#### 2.14 共享内存
1. 共享内存是效率最高的一种进程间通信方式，因为是直接操作内存。内存映射还需要同步文件和内存的数据，所以效率没有共享内存高
2. 简介
   - 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入（相对于其他进程间通信方式用户态和内核态切换的次数少，效率高）。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。
   - 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。
3. 问题
   - 内存同步（本章未讲）
4. 共享内存使用步骤（创建关联读写分离删除）
   - 调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的**共享内存标识符**。
   - 使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分（共享库内）。
   - 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。
   - 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。
   - 调用 shmctl() 来删除共享内存段。只有当当前**所有**附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。
5. 相关函数
   - int shmget(key_t key, size_t size, int shmflg);
      - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。
            新创建的内存段中的数据都会被初始化为0
      - 参数：
        - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。
                一般使用16进制表示，非0值，写10进制也可以，会转换
        - size: 共享内存的大小（创建后实际大小为分页大小整数倍）
        - shmflg: 属性
            - 访问权限
            - 附加属性：创建/判断共享内存是不是存在
                - 创建：IPC_CREAT
                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用
                    IPC_CREAT | IPC_EXCL | 0664
            - 获取时的写法：int shmid = shmget(100, 0, IPC_CREAT);
        - 返回值：
            失败：-1 并设置错误号
            成功：>0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。

   - void *shmat(int shmid, const void *shmaddr, int shmflg);
       - 功能：和当前的进程进行关联
       - 参数：
           - shmid : 共享内存的标识（ID）,由shmget返回值获取
           - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定
           - shmflg : 对共享内存的操作
               - 读 ： SHM_RDONLY, 必须要有读权限
               - 读写： 0
       - 返回值：
           成功：返回共享内存的首（起始）地址。  失败(void *) -1
           读数据，如字符串数据时，转换printf("%s\n", (char\*) ptr);
   - int shmdt(const void *shmaddr);
       - 功能：解除当前进程和共享内存的关联
       - 参数：
           shmaddr：共享内存的首地址
       - 返回值：成功 0， 失败 -1
       
   - int shmctl(int shmid, int cmd, struct shmid_ds *buf);
       - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进程被销毁了对共享内存是没有任何影响。
       - 参数：
           - shmid: 共享内存的ID
           - cmd : 要做的操作
               - IPC_STAT : 获取共享内存的当前的状态
               - IPC_SET : 设置共享内存的状态
               - IPC_RMID: **标记**共享内存被销毁（通过ipcs查看时key为0x00000000）
           - buf：需要设置或者获取的共享内存的属性信息
               - IPC_STAT : buf存储数据
               - IPC_SET : buf中需要初始化数据，设置到内核中
               - IPC_RMID : 没有用，NULL
   - key_t ftok(const char *pathname, int proj_id);
       - 功能：根据指定的路径名，和int值，生成一个共享内存的key
       - 参数：
          - pathname:指定一个**存在的**路径
            /home/nowcoder/Linux/a.txt
            / 
          - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节
                   范围 ： 0-255  一般指定一个字符 'a'
       - 每次传递的值一样那么生成的key也一样
6. 注意
   - 问题1：操作系统如何知道一块共享内存被多少个进程关联？
       - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch
       - shm_nattach 记录了关联的进程个数（可通过ipcs -m  查看）

   - 问题2：可不可以对共享内存进行多次删除 shmctl
       - 可以的
       - 因为shmctl 标记删除共享内存，不是直接删除
       - 什么时候真正删除呢?
           当和共享内存关联的进程数为0的时候，就真正被删除
       - 当共享内存的key为0的时候，表示共享内存被标记删除了
           如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。

7. 共享内存和内存映射的区别
   1. 共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）
   2. 共享内存效率更高（内存映射需要和磁盘进行同步）
   3. 内存
      所有的进程操作的是同一块共享内存。
      内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。
   4. 数据安全
      - 进程突然退出
         共享内存还存在
         内存映射区消失
      - 运行进程的电脑死机，宕机了
         数据存在在共享内存中，没有了
         内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。
   5. 生命周期
      - 内存映射区：进程退出，内存映射区销毁
      - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机。
         如果一个进程退出，会**自动**和共享内存进行取消关联。

8. 终端查看进程间通信信息命令
   - ipcs 用法
     - ipcs -a // 打印当前系统中所有的进程间通信方式的信息
     - ipcs -m // 打印出使用共享内存进行进程间通信的信息
     - ipcs -q // 打印出使用消息队列进行进程间通信的信息
     - ipcs -s // 打印出使用信号进行进程间通信的信息
   - ipcrm 用法
     - ipcrm -M shmkey // 移除用shmkey创建的共享内存段
     - ipcrm -m shmid // 移除用shmid标识的共享内存段
     - ipcrm -Q msgkey // 移除用msqkey创建的消息队列
     - ipcrm -q msqid // 移除用msqid标识的消息队列
     - ipcrm -S semkey // 移除用semkey创建的信号
     - ipcrm -s semid // 移除用semid标识的信号

#### 2.15 守护进程
1. 终端
   - 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端（通过fork或者exec函数族）。
   - 终端就是一个控制进程的设备,远程登录后会得到shell进程，通过shell进程解析命令执行创建子进程
     - 查看当前终端设备：tty
     - 查看当前shell进程PID：echo $$
     - 会话ID：SID
   - 默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。
   - 在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号， Ctrl + \ 会产生 SIGQUIT 信号。
2. 进程组
   - 进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令，方便管理。有时也称进程组为作业。
   - 进程组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。
   - 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。
3. 会话
   - 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。
   - 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。
   - 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。
   - 当控制终端的连接建立起来之后，会话首进程（shell进程）会成为该终端的控制进程。
4. 进程组、会话、控制终端之间的关系
   - find / 2 > /dev/null | wc -l &
      注意这里find，wc进程是兄弟关系，它们共同的父进程都是shell进程（bash）即会话首进程，但是它们组PGID和bash的组PGID不同（？）
   - sort < longlist | uniq -c
5. 进程组、会话操作函数
   - 进程组
     - pid_t getpgrp(void);
     - pid_t getpgid(pid_t pid);
     - int setpgid(pid_t pid, pid_t pgid);
   - 会话
     - pid_t getsid(pid_t pid);
     - pid_t setsid(void);
6. 守护进程
   - 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是Linux 中的**后台服务进程**。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。
   - 守护进程具备下列特征：
     - 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。
     - 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、 SIGQUIT）。
   - Linux 的大多数服务器就是用守护进程实现的。比如，sshd，Internet 服务器 inetd，Web 服务器 httpd 等。
   - 注意，守护进程关闭终端后也不会停止，必须手动kill
7. 守护进程的创建步骤
   - 执行一个 fork()，之后父进程退出，子进程继续执行。
       - 防止父进程结束后显示shell提示符
       - 不能是进程组的首进程创建会话。例如如果父进程PID = PGID = 100，其通过setsid()创建新会话，那么在新会话中也会有同样名称进程组SID = PGID = 100，产生冲突。而通过子进程PID = 101,产生会话SID = PGID = 101则没有冲突
   - 子进程调用 setsid() 开启一个新会话。
       - 创建的新会话没有控制终端，就可以防止键盘产生一些信号杀死这个终端（但是还是能通过kill杀死）
       - 但是还是有终端的，只是这个终端设备没办法通过shell控制进程再控制该进程，但该进程可以通过标准输出向其输出
   - 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。
       - umask(022);
       - 777 - 022 = 755 rwxrw-rw- 
       - 这个新创建的会话创建的文件和目录权限就是rwxrw-rw-
   - 修改进程的当前工作目录，通常会改为根目录（/）。
       - 防止目录在系统运行过程中被卸载
   - 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。
       - 防止其向终端输出
       - 防止卸载某些文件时，这些文件被占用
   - 在关闭了文件描述符0、 1、 2之后，守护进程通常会打开/dev/null 并使用dup2()使所有的描述符指向这个设备。
   - 核心业务逻辑


### 3. Linux多线程开发

#### 3.1 线程
1. 概述
   - 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）
   - 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。
   - 线程是轻量级的进程（LWP： Light Weight Process），在 Linux 环境下线程的本质仍是进程。
   - 查看指定进程的 LWP 号： ps –Lf pid
2. 线程和进程区别（为什么要有线程？）
   - 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。
   - 调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。
   - 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。
   - 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表。
3. 线程和进程虚拟地址空间
   - 共享同一块虚拟地址空间：内核空间，共享库，堆空间，bss段，data段，text段，但是栈空间和text段不共享，分别为各自线程的特有的栈，text段
   - bss段（存放程序中未初始化的全局变量），data段（存放程序中未初始化的全局变量），text段（存放程序执行代码）
4. 线程之间共享和非共享资源
   - 共享资源
      - 进程 ID 和父进程 ID        
      - 进程组 ID 和会话 ID
      - 用户 ID 和 用户组 ID
      - 文件描述符表
      - 信号处置（注册的信号处理）
      - 文件系统的相关信息：文件权限掩码（umask）、当前工作目录
      - 以上都是内核空间的资源，没有复制直接共享
      - 虚拟地址空间（除栈、 .text）
   -  非共享资源
      - 线程 ID
      - 信号掩码（阻塞信号集，每个进程都有自己的阻塞信号集）
      - 线程特有数据
      - error 变量（error号不共享）
      - 实时调度策略和优先级
      - 栈，本地变量和函数的调用链接信息
5. 线程库(NPTL)
   - 查看当前 pthread 库版本： getconf GNU_LIBPTHREAD_VERSION
   - 注意NPTL为第三方库，编译时需要指定路径或者直接加上 -pthread
6. 创建线程
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
void \*(*start_routine) (void *), void *arg);
   - 功能：创建一个子线程
   - 参数：
      - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。
      - attr : 设置线程的属性，一般使用默认值，NULL
      - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码
      - arg : 给第三个参数使用，传参
   - 返回值：
      成功：0
      失败：返回错误号。这个错误号和之前errno不太一样，不能用perror。
      获取错误号的信息：  char * strerror(int errnum);
   - 注意
      - 一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程称之为子线程。
      - 程序中默认只有一个进程，fork()函数调用，2进程
      - 程序中默认只有一个线程，pthread_create()函数调用，2个线程。
      - 子线程只执行传入函数内的代码，不执行主线程执行的代码
      - 子线程未输出结果原因可能是因为主线程先抢占CPU资源，结束时子线程还未创建完毕或者结束时(直接return 0，而不是通过pthread_exit()退出)由于主线程的虚拟地址空间没有了，子线程也立刻终止了
      - 和多进程一样，也是主线程和子线程抢占资源交替执行
7. 终止线程
   - void pthread_exit(void *retval);
      - 功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程
      - 参数：retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。
      - 注意
        - 当主线程通过pthread_exit()正常退出时，不会对其他线程有影响
        - 所以主线退出后的代码都不会被执行，包括main()中的return 0;
        - 在子线程中使用return NULL退出相当于调用了pthread_exit(NULL);
   - pthread_t pthread_self(void);
      - 功能：获取当前的线程的线程ID
   - int pthread_equal(pthread_t t1, pthread_t t2);
      - 功能：比较两个线程ID是否相等
         不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的是使用结构体去实现的。所以不能直接用“==”来判断
8. 连接已终止的线程（手动回收已终止的线程的资源）
int pthread_join(pthread_t thread, void **retval);
   - 功能：和一个已经终止的线程进行连接
            回收子线程的资源，防止产生僵尸线程
            这个函数是**阻塞**函数，调用一次只能回收一个子线程
            一般在主线程中使用
   - 参数：
      - thread：需要回收的子线程的ID
      - retval: 接收子线程退出时的返回值,为二级指针，因为是传出参数，要改变原值必须再取地址。至于为什么子线程返回值为void*因为传递地址效率高，当使用自定义结构的时候尤其如此。
      ```
      int * thread_retval;
      ret = pthread_join(tid, (void **)&thread_retval);
      ```
   - 返回值：
      0 : 成功
      非0 : 失败，返回的错误号
9. 分离线程（自动回收线程资源）
int pthread_detach(pthread_t thread);
   - 功能：分离一个线程。被分离的线程**在终止的时候**，会自动释放资源返回给系统。
      1.不能多次分离，会产生不可预料的行为。
      2.不能去连接一个已经分离的线程，会报错。
   - 参数：需要分离的线程的ID
   - 返回值：
      成功：0
      失败：返回错误号
10. 取消线程（让线程终止）
int pthread_cancel(pthread_t thread);
   - 功能：取消线程（让线程终止）
   - 可以在创建线程的时候设置其属性，设置可以取消还是不能取消
   - 取消某个线程，可以终止某个线程的运行，但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。
   - 取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。
11. 线程属性
    - 注意
      - 通过创建线程时，传入线程的属性来时其结束后自动分离,与join的区别是不需要主线程回收
      - 获得线程属性要在其创建完之后
      - 最后记得要销毁线程属性变量
    - 初始化线程属性变量
    int pthread_attr_init(pthread_attr_t *attr);
    比如说设置栈空间的大小
    - 释放线程属性的资源
    int pthread_attr_destroy(pthread_attr_t *attr);     
    - 获取线程分离的状态属性
    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); 
    - 设置线程分离的状态属性
    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
       
#### 3.2 线程同步
1. 线程同步
   - 多个线程由于先后抢占CPU资源执行，对同一个共享资源会产生线程同步问题
   - 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。
   - 临界区
      是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应中断该片段的执行。
   - 线程同步
      - 即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。
      - 线程同步会降低并发的效率，但这是必须的，因为要保证数据的安全。同时只是对临界区的同步，对整体的效率影响不大。
#### 3.3 互斥量（互斥锁）
1. 互斥量
   - 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。
   - 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。
   - 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议：
     - 针对共享资源锁定互斥量
     - 访问共享资源
     - 对互斥量解锁
   - 互斥量定义在全局中，初始化和销毁在主线程中（前提主线程销毁前通过join阻塞回收子线程资源）
2. 互斥量相关函数
   - 互斥量的类型 pthread_mutex_t
   - int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
      - 初始化互斥量
      - 参数 ：
         - mutex ： 需要初始化的互斥量变量
         - attr ： 互斥量相关的属性，NULL
      - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。
         pthread_mutex_t *restrict mutex = xxx;
         pthread_mutex_t * mutex1 = mutex;
   - int pthread_mutex_destroy(pthread_mutex_t *mutex);
      - 释放互斥量的资源
   - int pthread_mutex_lock(pthread_mutex_t *mutex);
      - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待
   - int pthread_mutex_trylock(pthread_mutex_t *mutex);
      - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。
   - int pthread_mutex_unlock(pthread_mutex_t *mutex);
      - 解锁

#### 3.4 死锁
1. 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。
2. 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。
3. 死锁的几种场景：
   - 忘记释放锁  trylock
   - 重复加锁
   - 多线程多锁，抢占锁资源
      线程A拿锁1，再拿锁2；线程B拿锁2，再拿锁1；由于A拿锁2时，锁2在B手中，B拿锁1时，锁1在A手中，两者都阻塞，形成死锁

#### 3.5 读写锁
1. 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。
2. 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。
3. 读写锁的特点：
   - 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。
   - 如果有其它线程写数据，则其它线程都不允许读、写操作。
   - 写是独占的，写的优先级高。要写的线程先执行。
     - A先在r，B要w，C要r,则先w再r
   - 应用场景：读的操作多于写的操作
4. 读写锁相关操作函数
    读写锁的类型 pthread_rwlock_t
    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
5. 注意使用detach回收子线程资源时，由于其不阻塞，销毁读写锁应放在销毁主线程代码之后

#### 3.6 生产者和消费者模型
1. 生产者和消费者模型中的对象
   - 生产者
   - 消费者
   - 容器
2. 可能遇到的问题
   - 容器满，生产者要通知消费者消费
   - 容器空，消费者要通知生产者生产
   - 多个生产者消费者导致的数据安全问题
3. 如何解决
   - 互斥量
   - 条件变量和信号量