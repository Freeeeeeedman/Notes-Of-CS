#### 操作系统面经总结

#### 1. 硬件结构
1. 外中断和异常（内中断）有什么区别？
   - 外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。
   - 异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等
2. 软中断和硬中断有什么区别？
   - 软件中断是可被调用执行的程序产生的中断。比如外部设备管理中断服务程序（键盘管理中断、显示器管理中断、打印机管理 中断等）
   - 硬件中断是由与系统相连的外设(比如网卡 硬盘 键盘等)自动产生的. 每个设备或设备集都有他自己的IRQ(中断请求)。
#### 2. 进程管理
1. 程序是什么？
    程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程。
    包括：机器语言指令，数据（变量初始值），共享库和动态链接信息等等
2. 进程是什么？
    进程是正在运行的程序的实例，也是系统进行资源分配和调度的基本单位
3. 进程和程序的区别
   - 进程占用内存，CPU等资源，而程序只占用磁盘 
   - 进程是正在运行的程序的实例。 进程既是基本的分配单元，也是基本的执行单元。
   - 可以用一个程序来创建多个进程
4. 说一说进程的状态
   - 三态模型
        运⾏状态（Runing）：该时刻进程占⽤ CPU；
        就绪状态（Ready）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；
        阻塞状态（Blocked）：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏，这时，即使给它CPU控制权，它也⽆法运⾏；
   - 五态模型
        创建状态（new）：进程正在被创建时的状态；
        结束状态（Exit）：进程正在从系统中消失时的状态；
   - 七态模型
        挂起状态：描述进程没有占⽤实际的物理内存空间的情况
        阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；
        就绪挂起状态：进程在外存（硬盘），但只要进⼊内存，即刻⽴刻运⾏；
5. 说一说进程的状态变迁
        进程先是创建状态，然后进入就绪队列即就绪状态，被调用后进入运行状态，如果等待事件则进入阻塞状态。如果结束则进入结束状态。如果时间片用完或者等待的事件完成则进入就绪状态。如果进程运行中被挂起就进入就绪挂起状态，如果在阻塞状态被挂起就进入阻塞挂起状态。被激活后在进入就绪或阻塞状态
6. 为什么要把进程挂起？
    如果有⼤量处于阻塞状态的进程，进程可能会占⽤着物理内存空间，应当把这些进程换出到硬盘
7. 导致进程挂起的原因是什么？
   - 进程所使⽤的内存空间不在物理内存
   - 通过 sleep 让进程间歇性挂起，其⼯作原理是设置⼀个定时器，到期后唤醒进程
   - ⽤户希望挂起⼀个程序的执⾏，⽐如在 Linux 中⽤ Ctrl+Z 挂起进程
8. 操作系统中用什么来描述进程？
    进程控制块（PCB），PCB 是进程存在的唯⼀标识
9.  PCB 具体包含什么信息呢？
   - 进程标识符
   - 进程状态
   - 优先级
   - 有关内存地址空间的信息与CPU 中各个寄存器的值以便进程上下文切换
11. 每个 PCB 是如何组织的呢？
   - 通常是通过链表的⽅式进⾏组织
   - 就绪队列：将所有处于就绪状态的进程链在⼀起
     阻塞队列：把所有因等待某事件⽽处于等待状态的进程链在⼀起
11. 说一说CPU的上下⽂切换
    - CPU上下⽂是CPU 在运⾏任何任务前，所必须依赖的环境，即CPU 寄存器和程序计数器。CPU 上下⽂切换就是先把前⼀个任务的 CPU 上下⽂保存起来，然后加载新任务的上下⽂，最后再跳转到程序计数器所指的新位置，运⾏新任务。
    - CPU 上下⽂切换分成： 进程上下⽂切换、线程上下⽂切换和中断上下⽂切换
12. 说一说进程的上下⽂切换
    - 各个进程之间是共享 CPU ，CPU从⼀个进程切换到另⼀个进程运⾏，称为进程的上下⽂切换
    - 进程的上下⽂切换不仅包含了虚拟地址空间、堆、栈、全局变量等⽤户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。通常，会把交换的信息保存在进程的 PCB，当要运⾏另外⼀个进程的时候，我们需要从这个进程的 PCB取出上下⽂，然后恢复到 CPU 中，这使得这个进程可以继续执⾏
13. 进程间共享什么？
    - 没有亲缘关系的进程
      - CPU
      - 共享内存
    - 父子进程fork()
      - 子进程内核空间拷贝父进程，但各自的PID不同
      - 子进程用户空间拷贝父进程，但读时共享，写时拷贝。需要写入时才复制地址空间，从而使各个进程拥有各自的地址空间
14. 发⽣进程上下⽂切换有哪些场景？
    - 进程的时间片用完
    - 系统资源不足时，进程会被挂起
    - sleep主动挂起
    - 高优先级进程先运行时被挂起
    - 硬件中断时被挂起，CPU来执行内核中的中断服务程序
15. 孤儿进程
        父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。孤儿资源没有危害，因为其资源最后会由init进程来进行回收
16. 僵尸进程
        子进程结束之后, 都会释放自己地址空间中的用户区数据，通过父进程释放掉内核区的 PCB数据。如果进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。会一直占用进程号，导致系统不能产生新的进程。一般通过让父进程调用wait()或waitpid()回收，或者直接结束父进程，让子进程变成孤儿进程。
17. 线程是什么？
    线程是进程当中的⼀条执⾏流程，是CPU执行的最基本单元。线程之间可以共享代码段、数据段等资源，但各自有⼀套独⽴的寄存器和栈
18. 为什么需要线程？
    - 进程间通信开销大
    - 维护进程的系统开销大，比如进程切换时，需要保存进程的上下文
19. 线程的优缺点？
    - 优点
        ⼀个进程中可以同时存在多个线程；
        各个线程之间可以并发执⾏；
        各个线程之间可以共享地址空间和⽂件等资源
    - 缺点
        当进程中的⼀个线程崩溃时，可能会导致其所属进程的所有线程崩溃。比如操作系统检测到异常，会kill掉进程，其他线程就一起被干掉了。
20. 线程相⽐进程能减少开销体现在哪里？
    - 线程的创建时间⽐进程快，因为进程在用fork（）创建的过程中，，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性
    - 线程的终⽌时间⽐进程快，因为线程释放的资源相⽐进程少很多；
    - 同⼀个进程内的线程切换⽐进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同⼀个进程的线程都具有同⼀个⻚表，那么在切换的时候不需要切换⻚表。⽽对于进程之间的切换，切换的时候要把⻚表给切换掉，⽽⻚表的切换过程开销是⽐较⼤的；
    - 由于同⼀进程的各线程间共享内存和⽂件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更⾼了
21. 线程上下⽂切换的是什么？
    - 当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下⽂切换⼀样；
    - 当两个线程是属于同⼀个进程，内核空间，共享库，堆空间，bss段，data段，text段，但是栈空间，寄存器，程序计数器不共享
22. 协程是什么？
    协程是一种用户态的轻量级线程，协程的调度完全由用户控制。
23. 为什么需要协程？
    - 节省CPU，内核级别的线程切换开销大，浪费CPU资源。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，避免了系统级线程上下文切换造成的资源浪费。
    - 节约内存：线程占用内存多，协程占用内存少可以实现高并发
    - 更稳定，一个线程崩溃可能会导致进程中的所有线程都会跟着一起崩溃。
    - 开发效率更高，适用于异步IO
24. 协程上下文切换的是什么？
    寄存器和栈
25. 进程、线程和协程的区别和联系
    - 定义
        进程：资源分配基本单位，线程：程序执行的基本单位，协程用户态的轻量级线程，线程内部调度的基本单位
    - 上下文切换内容不同
        进程：虚拟地址空间、堆、栈、全局变量等⽤户空间的资源，还包括了内核堆 、栈、寄存器等内核空间的资源
        线程：程序计数器，寄存器，线程栈
        协程：寄存器，协程栈
    - 状态转变
        进程、线程：用户态，内核态，用户态
        协程:用户态
    - 并发性
        不同进程之间切换实现并发
        一个进程内部的多个线程并发执行
        同一时间只能执行一个协程，而其他协程处于休眠状态
    - 系统开销不同
        进程：创建销毁切换开销很大，切换时还需要切换页表
        线程：创建销毁需要的资源都很少，切换不需要切换页表，只需要切换线程栈，寄存器与程序计数器
        协程：相较线程只在用户态，没有内核切换的开销
    - 通信方式不同
        进程：进程间通信，比如管道，共享内存，socket
        线程：共享内存，通过全局变量通信
        协程：共享内存
26. 一个进程可以创建多少线程，和什么有关？
    一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定。理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程
27. 进程线程模型你知道多少？
    - 多进程
        - 进程是资源分配的基本单位。通过fork()创建子进程。子进程用户空间拷贝父进程，但读时共享，写时拷贝。需要写入时才复制地址空间，从而使各个进程拥有各自的地址空间。在命令行中执行文件创建的进程都是shell进程的子进程
        - 进程的上下文切换：...
        - 一些接口
            创建进程：pid_t fork(void);
            结束进程：void exit(int status);
    - 多线程
       -  线程是调度的基本单位。对于用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享。
       -  多线程的优点是首先减少了多进程创建销毁以及进程上下文切换的大量开销。并且
        原先顺序执行的程序可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务。
       -  多线程的缺点是会带来多线程共享资源导致的互斥和同步问题，并且当进程中的⼀个线程崩溃时，可能会导致其所属进程的所有线程崩溃。
       -  多线程的接口有：
            创建线程：pthread_create
            终止线程：pthread_exit
            分离线程（自动回收线程资源）：pthread_detach
            连接已终止的线程（手动回收已终止的线程的资源）：int pthread_join

28. 说一说CPU调度的时机
    - 从就绪态 -> 运⾏态：当进程被创建时，会进⼊到就绪队列，操作系统会从就绪队列选择⼀个进程运⾏；
    - 从运⾏态 -> 阻塞态：当进程发⽣ I/O 事件⽽阻塞时，操作系统必须另外⼀个进程运⾏；
    - 从运⾏态 -> 结束态：当进程退出结束后，操作系统得从就绪队列选择另外⼀个进程运⾏
29. 说一说CPU调度算法
    - 先来先服务（First Come First Seved, FCFS）算法
        每次从就绪队列选择最先进⼊队列的进程，然后⼀直运⾏，直到进程退出或被阻塞，才会继续从队列中选择第⼀个进程接着运⾏。
        FCFS 对⻓作业有利，适⽤于 CPU 繁忙型作业的系统，⽽不适⽤于 I/O 繁忙型作业的系统
    - 最短作业优先（Shortest Job First, SJF）调度算法
        优先选择运⾏时间最短的进程来运⾏
        对⻓作业不利
    - ⾼响应⽐优先（Highest Response Ratio Next, HRRN）调度算法
        兼顾短作业和长作业，高响应比优先，响应比 = （等待时间 + 要求服务时间）/要求服务时间
    - 时间⽚轮转（Round Robin, RR）调度算法
        每个进程被分配⼀个时间段，称为时间⽚（Quantum），即允许该进程在该时间段中运⾏。
        如果时间⽚设得太短会导致过多的进程上下⽂切换
        如果设得太⻓⼜可能引起对短作业进程的响应时间变⻓
    - 最⾼优先级（Highest Priority First， HPF）调度算法
        静态优先级
        动态优先级：随着时间的推移增加等待进程的优先级
        ⾮抢占式和抢占式
    - 多级反馈队列（Multilevel Feedback Queue）调度算法
        多级表示有多个队列，每个队列优先级从⾼到低，同时优先级越⾼时间⽚越短。
        反馈表示如果有新的进程加⼊优先级⾼的队列时，⽴刻停⽌当前正在运⾏的进程，转⽽去运⾏优先级⾼的队列；
        这样对于短作业很快就能运行完，对于长作业，如果在第一个队列时间片内没运行完会转入到第二队列的末尾等待运行。兼顾了⻓短作业，同时有较好的响应时间
30. 说一说进程间通信的方式
    - 管道
    - 消息队列
    - 共享内存
    - 信号量
    - 信号
    - socket
31. 说一说线程间通信的方式
    - 共享内存（全局变量）
    - 信号
    - 信号量
    - 锁
    - 条件变量
32. 说一说管道
     int pipe(int pipefd[2]);
     int mkfifo(const char *pathname, mode_t mode);
     管道其实是一个在内核内存中维护的缓冲器。一段输入，一段读取。管道传输的数据是⽆格式的流且⼤⼩受限。匿名管道用于父子进程间通信，有名管道用于没有亲缘关系的进程间的通信。
33. 如何利用管道通信？
    对于匿名管道fork()后的父子进程共享同一文件描述符表，父子进程都拥有了管道的读端和写段。如果需要双向通信，则应该创建两个管道。而命名管道就需要通过管道文件作为媒介通信。
34. shell里管道命令实际是怎么工作的？
    shell ⾥⾯执⾏ A | B 命令的时候， A 进程和 B 进程都是 shell 创建出来的⼦进程， A 和 B 之间不存在⽗⼦关系，它俩的⽗进程都是 shell。在 shell ⾥通过「 | 」匿名管道将多个命令连接在⼀起，实际上也就是创建了多个⼦进程。在我们编写 shell 脚本时，能使⽤⼀个管道搞定的事情，就不要多⽤⼀个管道，这样可以减少创建⼦进程的系统开销。
35. 说一说消息队列
    管道的通信⽅式是效率低的，因此管道不适合进程间频繁地交换数据，消息队列解决了这个问题。消息队列是保存在内核中的消息链表，以消息体的格式发生数据。每个消息体都是固定⼤⼩的存储块，不像管道是⽆格式的字节流数据。
36. 说一说消息队列和管道的区别
    - 传输的格式不同
    - 通信效率不同
    - 生命周期不同，消息队列⽣命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在，⽽匿名管道是随进程的创建⽽建⽴，随进程的结束⽽销毁
37. 说一说消息队列的缺点
    - 消息队列不适合⽐较⼤数据的传输，消息体有长度限制
    - 消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销，因为进程写⼊数据到内核中的消息队列时，会发⽣从⽤户态拷⻉数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发⽣从内核态拷⻉数据到⽤户态的过程。
38. 说一说共享内存
    int shmget(key_t key, size_t size, int shmflg);
    共享内存是效率最高的一种进程间通信方式，共享内存的机制，就是不同的进程拿出⼀块虚拟地址空间来，映射到相同的物理内存中。
39. 共享内存效率高在哪里？
    不需要像管道或者消息队列一样，存在⽤户态与内核态之间的数据拷⻉开销，也不需要频繁切换用户态和内核态
40. 说一说条件变量
    pthread_cond_t，使用通知的方式解锁，与互斥锁配合使用。条件变量不是锁，当满足某个条件时，条件变量可以阻塞线程或者解除阻塞。解决不了线程同步问题。
41. 说一说信号量
    使用共享内存通信会导致多进程竞争共享资源造成数据错乱。信号量其实就是⼀个整型的计数器，就可以实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。通常信号量表示资源的数量，对应的变量是⼀个整型（ sem ）变量。两个原⼦操作的系统调⽤函数来控制信号量的。P操作信号量-1，如果sem<0, 阻塞。V操作信号量+1，如果sem>=0,唤醒。
42. 信号量是如何实现进程/线程间的互斥与同步的？
    进程：共享内存，线程:全局变量
    信号量：sem_t
    互斥：初始化信号量为 1，A进程通过P操作减1，访问到共享内存。B进程经过P操作后发现信号量<0,阻塞。A处理完后V操作，信号量为0，B被唤醒 
    同步：初始化信号量为 0，线程B先通过P操作建1阻塞，此时线程A如果完成动作后执行V操作，则B被唤醒
43. 说一说信号
    raise()
    信号是进程间通信机制中唯⼀的异步通信机制。因为可以在任何时候发送信号给某⼀进程，⼀旦有信号产生，就有3种处理方式
    - 常见信号：SIGKILL, SIGSTOP, SIGALARM
    - 执行默认操作
    - 捕捉信号，执行相应的信号处理函数（signal，sigaction）
    - 忽略信号，但是SIGKILL和SIGSTOP无法忽视或者捕捉
44. 说一说socket
     int socket(int domain, int type, int protocal)
     Socket 通信不仅可以跨⽹络与不同主机的进程间通信，还可以在同主机上进程间通信。还可以指定通信的方式，如TCP,UDP还是本地进程间字节流通信
45. 针对 TCP 协议通信的 socket 编程模型
    服务端和客户端初始化 socket ，得到⽂件描述符；
    服务端调⽤ bind ，将绑定在 IP 地址和端⼝;
    服务端调⽤ listen ，进⾏监听；
    服务端调⽤ accept ，等待客户端连接；
    客户端调⽤ connect ，向服务器端的地址和端⼝发起连接请求；
    服务端 accept 返回⽤于传输的 socket 的⽂件描述符；
    客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据；
    客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完数据后，服务端调⽤ close ，表示连接关闭。
    监听 socket，已完成连接 socket
46. 针对 UDP 协议通信的 socket 编程模型
    UDP 是没有连接的，不需要三次握⼿，只需要IP地址和端口号
    客户端/服务端：socket()初始化，bind()绑定IP和端口，再通过sendto()和recvfrom()传输数据
47. 针对本地进程间通信的 socket 编程模型
    本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端⼝，⽽是绑定⼀个本地⽂件
48. 为什么会发生多进程（线程）竞争共享资源造成数据错乱？
    因为实际进程（线程）运行过程种调度不可控不可知，比如对共享内存中的一个数字进行修改大概分为三个步骤，从内存中取值并放入寄存器，寄存器修改值，值放回内存。可能进程（线程）只执行了1，2步切换到另一个（进程）线程，而这个（进程）线程重复的完整执行了三个步骤，这时候又切换到第一个（进程）线程,则又会执行第三部，相当于第二个（进程）线程未做修改。
49. 说一说互斥
    保证⼀个线程在临界区执⾏时，其他线程应该被阻⽌进⼊临界区。互斥也并不是只针对多线程。在多进程竞争共享资源的时候，也同样是可以使⽤互斥的⽅式来避免资源竞争造成的资源混乱。
50. 说一说同步
    同步，就是并发进程/线程在⼀些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。
52. 一般如何实现多线程的互斥与同步？
    - 锁，使⽤加锁操作和解锁操作可以解决并发线程/进程的互斥问题
        「忙等待锁」，⾃旋锁（spin lock），⼀直while⾃旋，利⽤ CPU 周期，直到锁可⽤
        「⽆等待锁」，就把当前线程放⼊到锁的等待队列，然后执⾏调度程序，把 CPU让给其他线程执⾏。
    - 信号量
       信号量其实就是⼀个整型的计数器，就可以实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。通常信号量表示资源的数量，对应的变量是⼀个整型（ sem ）变量。两个原⼦操作的系统调⽤函数来控制信号量的。P操作信号量-1，如果sem<0, 阻塞。V操作信号量+1，如果sem>=0,唤醒。








#### 3. 内存管理
1. 为什么需要虚拟内存地址？
    因为如果进程使用绝对物理地址，会导致互相会产生冲突。而且进程能够直接访问物理地址是一种不安全的方式。
2. 什么时虚拟内存地址？
    操作系统为每个进程分配独⽴的⼀套「虚拟地址」，将不同进程的虚拟地址和不同内存的物理地址映射起来
3. 操作系统是如何管理虚拟地址与物理地址之间的关系？
   内存分段和内存分⻚
4. 说一说内存分段
   程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。 不同的段是有不同的属性的，所以就⽤分段（Segmentation）的形式把这些段分离出来。
5. 分段机制下，虚拟地址和物理地址是如何映射的？
    分段机制下的虚拟地址由两部分组成， 段选择⼦和段内偏移量。通过段选择子得到段表保存的段基地址，段基地址加上段内偏移量得到物理内存地址
6. 分段机制会导致什么问题？
    - 内存碎⽚
        外部内存碎⽚，也就是产⽣了多个不连续的⼩物理内存，导致新的程序⽆法被装载；
        内部内存碎⽚，程序所有的内存都被装载到了物理内存，部分内存并不常⽤，导致浪费；
    - 内存交换的效率低
        解决外部内存碎片采用内存交换的方式，即把这下不连续的内存碎片先邪道硬盘再读回内存
        多进程的系统来说，⽤分段的⽅式，很容易产⽣内存碎⽚，但硬盘速度很慢，如果内存交换的时候，交换的是⼀个占内存空间很⼤的程序，开销很大
7. 说一说分页机制
    分⻚是把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩称为页，在 Linux 下，每⼀⻚的⼤⼩为 4KB，虚拟地址与物理地址之间通过⻚表来映射.分页可以解决分段的内存碎⽚、内存交换效率低的问题
    ⻚表是存储在内存⾥的， 内存管理单元 （MMU）就做将虚拟内存地址转换成物理地址的⼯作
8. 说一说缺页异常
    当进程访问的虚拟地址在⻚表中查不到时，系统会产⽣⼀个缺⻚异常，进⼊系统内核空间分配物理内存、更新进程⻚表，最后再返回⽤户空间，恢复进程的运⾏。
9. 分⻚是怎么解决分段的内存碎⽚、内存交换效率低的问题？
   - 内存空间都是预先划分好的，也就不会像分段会产⽣间隙⾮常⼩的内存,采⽤了分⻚，那么释放的内存都是以⻚为单位释放的，也就不会产⽣⽆法给进程使⽤的⼩内存
   - 如果内存空间不够，操作系统会把其他正在运⾏的进程中的「最近没被使⽤」的内存⻚⾯给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。⼀旦需要的时候，再加载进来，称为换⼊（Swap In）。所以，⼀次性写⼊磁盘的也只有少数的⼀个⻚或者⼏个⻚，不会花太多时间， 内存交换的效率就相对⽐较⾼。
   - 分⻚的⽅式使得我们在加载程序的时候，不再需要⼀次性都把程序加载到物理内存中。我们完全可以在进⾏虚拟内存和物理内存的⻚之间的映射之后，并不真的把⻚加载到物理内存⾥，⽽是只有在程序运⾏中，需要⽤到对应虚拟内存⻚⾥⾯的指令和数据时，再加载到物理内存⾥⾯去。
10. 分⻚机制下，虚拟地址和物理地址是如何映射的？
    - 简单页表
        对于简单的页表,虚拟地址分为两部分， ⻚号和⻚内偏移.通过页号找到页表中的对应的物理内存的基地址,加上页内偏移就得到了物理内存地址
        但简单页表会有空间上的缺陷.对于32位,虚拟地址4GB,需要100万个页来存储,一个页表项4个字节,那么一个进程就需要4MB的内存来存页表
    - 多级页表
        如果采用二级分页,一级页表内存二级页表,二级页表再存页表项.这样一级⻚表就可以覆盖整个 4GB 虚拟地址空间，但如果某个⼀级⻚表的⻚表项没有被⽤到，也就不需要创建这个⻚表项对应的⼆级⻚表了，即可以在需要时才创建⼆级⻚表。64位系统里是四级页表。但多级页表降低了地址转换的效率
11. 说一说系统如何提高访问页表的效率？
    通过TLB页表缓存，将最常访问的⼏个⻚表项存储到缓存中。这样CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的⻚表。
12. 说一说段页式内存管理（寻址过程）
    内存分段和内存分⻚相组合。先将程序划分为多个段，接着再把每个段划分为多个⻚。虚拟地址分为三部分，段号，段内页号，页内位移。由段号从段表中得到页表起始地址，再从页表中得到物理页号，再加上页内位移得到物理地址。
13. 说一说Linux 采⽤了什么⽅式管理内存
    Linux 内存主要采⽤的是⻚式内存管理，也涉及到段机制。因为Intel的CPU硬件结构决定了只能线进行段式映射，再进行页式映射。Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是⼀样的。
14. 说一说Linux的虚拟地址空间
    - 分为内核空间和用户空间。32位系统内核空间占⽤ 1G ，位于最⾼处，剩下的 3G 是⽤户空间；64 位系统的内核空间和⽤户空间都是 128T ，分别占据整个内存空间的最⾼和最低处，剩下的中间部分是未定义的。
    - 每个进程都各⾃有独⽴的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。
    - ⽤户空间内存，从低到⾼分别是：
        程序文件段，.text
        已初始化数据段，.data, 比如已初始化的全局变量
        未初始化数据段，.bass, 比如未初始化的全局变量
        堆段，动态分配的内存，从低地址向高地址增长(malloc())
        文件映射段，包括动态库，共享内存(mmap()，动态分配)
        栈段，包括局部变量，从高地址向低地址增长

        























15. 内核区1G
   - 内存管理
   - 进程管理
   - 设备驱动管理
   - VFS虚拟文件系统
11. 用户区3G
  - 环境变量
  - 命令行参数
  - 栈空间(小)：由高到低存
  - 共享库
  - 堆空间(大)：由低到高存
  - ELF
    未初始化全局变量
    初始化全局变量
    代码段，二进制机器命令
  - 受保护的地址
#### 4. 磁盘调度

#### 5. 网络系统

#### 6. 设备管理

#### 7. 综合问题
1. 一个程序从开始运行到结束的完整过程，你能说出来多少？
    主要是四个过程：
       - 预编译
        主要处理源代码文件中的以“#”开头的预编译指令，比如将使用的库文件内容替换到文件中，替换所有的宏定义，删除注释等等
       - 编译
        把预编译之后生成的文件，进行一系列词法语法分析及优化后，生成相应的汇编代码文件
       - 汇编
        将汇编代码转变成机器可以执行的指令(机器码文件)。
       - 链接
        将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。包括静态链接和动态链接。
2. 说一说程序的局部性原理
    即在⼀段时间内，整个程序的执⾏仅限于程序中的某⼀部分。相应地，执⾏所访问的存储空间也局限于某个内存区域。