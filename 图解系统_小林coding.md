[toc]

### 1. 硬件结构

#### 1.1 CPU如何执行程序?
1. 计算机基本结构
    中央处理器，内存，输入设备，输出设备，总线
2. 中央处理器
   - 位宽:32位，64位
   - 寄存器
     - 通⽤寄存器，⽤来存放需要进⾏运算的数据
     - 程序计数器，⽤来存储 CPU 要执⾏下⼀条指令「所在的内存地址」
     - 指令寄存器，⽤来存放程序计数器指向的指令
3. 总线
   - 地址总线，⽤于指定 CPU 将要操作的内存地址
   - 数据总线，⽤于读写内存的数据
   - 控制总线，⽤于发送和接收信号，⽐如中断、设备复位等信号
4. 线路位宽与 CPU 位宽
   - 串行，并行
   - 线路位宽，避免低效率的串⾏传输的⽅式，线路的位宽最好⼀次就能访问到所有的内存地址，2^32=4G
   - CPU 的位宽不要⼩于线路位宽,32 位的 CPU 最好和 32 位宽的线路搭配
5. 程序执⾏的基本过程
   - ⼀个程序执⾏的时候， CPU 会根据程序计数器⾥的内存地址，从内存⾥⾯把需要执⾏
的指令读取到指令寄存器⾥⾯执⾏，然后根据指令⻓度⾃增，开始顺序读取下⼀条指令
   - 程序语言->汇编代码->机器码(通过汇编器)
   - 指令
     - 指令的内容是⼀串⼆进制数字的机器码
     - 不同的 CPU 有不同的指令集，也就是对应着不同的汇编语⾔和不同的机器码
     - 类型：数据传输类型，运算类型，跳转类型，信号类型，闲置类型
   - CPU 的指令周期
      Fetch（取得指令）-> Decode（指令译码）->  Execution（执⾏指令）-> Store（数据回写）
   - CPU 的时钟周期
      - 每⼀次脉冲信号⾼低电平的转换就是⼀个周期 
      - 1GHz，时钟频率为1G，时钟周期为1ns
   - CPU 的执行时间
     - CPU 的执行时间=CPU 时钟周期数（CPU Cycles）X 时钟周期时间（Clock Cycle Time）
     - CPU 时钟周期数=指令数 X 每条指令的平均时钟周期数(CPI)
     - 指令数:编译器优化
     - CPI:厂商优化
     - CCT:计算机主频
6. 32位和64位
   - 只有运算⼤数字的时候， 64 位 CPU 的优势才能体现出来，否则和 32 位 CPU 的计算性能相差不⼤
   - 64 位 CPU 可以寻址更⼤的内存空间，32 位的寄存器存不下 64 位的指令
   - 硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是指令的位宽

#### 1.2 存储器金字塔
1. 存储器的层次结构
   - CPU 并不会直接和每⼀种存储器设备直接打交道，⽽是每⼀种存储器设备只和它相邻的存储器设备打交道
   - 目的
    缓存:依次寻找并取数据
   - 寄存器
    0.5CCT
   - CPU高速缓存(CPU Cache)
        SRAM静态随机存储器
        L1(数据缓存，指令缓存):1ns
        L2:4ns
        L3:20~60CCT
   - 内存
        DRAM动态随机存取存储器
        100ns
   - SSD/HDD
        SSD:150μs
        HDD:10ms

#### 1.3 写出让CPU跑得更快的代码
1. 计算密集型程序，写出能够配合 CPU Cache ⼯作机制的代码
2. CPU Cache 的数据结构和读取过程
   - 缓存块(CPU Line)
      - 数据结构
            索引，组标记，有效位，数据块
      - 字
            CPU读取CPU Cache不读取CPU Line中的整个数据块，而是读一个数据片段 
   - 直接映射 Cache（Direct Mapped Cache）
      - 内存块(Block)
            读取的时候我们要拿到数据所在内存块的地址
      - 直接映射
            使⽤「取模运算」，取模运算的结果就是内存块地址对应的 CPU Line（缓存块）的地址
      - 组标记（Tag）
            区别不同的内存块
      - 内存的访问地址
            包括组标记，CPU Line索引，偏移量
   - 确认内存地址对应数据是否已储存在CPU Cache中
        1. 根据内存地址中索引信息，计算在 CPU Cache 中的索引，也就是找出对应的 CPU Line 的地址
        2. 找到对应 CPU Line 后，判断 CPU Line 中的有效位，确认 CPU Line 中数据是否是有效的，如果是⽆效的， CPU 就会直接访问内存，**并重新加载数据**，如果数据有效，则往下执⾏
        3. 对⽐内存地址中组标记和 CPU Line 中的组标记，确认 CPU Line 中的数据是我们要访问的内存数据，如果不是的话， CPU 就会直接访问内存，**并重新加载数据**，如果是的话，则往下执⾏
        4. 根据内存地址中偏移量信息，从 CPU Line 的数据块中，读取对应的字
   - 读取过程
        首先读取高速缓存，无数据时访问内存，并将内存中数据读入高速缓存，再读取高速缓存。而当我们读取内存地址对应数据时就要先判断是否存储在高速缓存中
