[toc]


####一些要点

1. 防卫式声明
2. 是否传入引用,是否返回引用
   - 函数传入引用时，输入的必须是左值
   - 引用作为函数参数可以加const
3. 传入数据是否添加const,函数是否添加const,对象定义加const
   - 成员函数后加const:不改变数据成员
   - 函数参数加const:传入为引用,不修改原数据
   - const对象只能调用const成员函数
   - 函数前加const表示返回的值为const
   - 非常量引用不能指向常量对象
     - 相当于返回类型也加了const所以定义函数也要加const,但是一下例子const没必要，因为没有改变自己的数据成员
      ```
        Point& returnPoint(){return *this;}
        const Point* returnPointp()const {return this;}
      ```
4. 为什么类内析构已经写了delete，还要在实际调用时自己写delete？
   - 直接声明的对象，比如shape a，即在栈上面的对象，所在作用域结束后，会自动执行析构函数，而new出来的在堆上的对象，不调用delete，即使它所在的作用域已经结束，也不会调用析构函数
   - 注意，类里面如果也new了对象，那么类的析构也一定要写对应的delete，如果使用类定对象时也new了，那么就有两个new，都要写delete

5. C与C++结构体的区别
   - C++
    ```
    struct Simple{...}s1;Simple s2,s3;
    typedef struct Simple{...}Simple;Simple s1,s2.s3;
    ```
     - 在C++中，struct和class是完全相同的，除了该struct默认为public可见，class默认为private不可见
   - C
     ```
    struct {...}s1;
    struct Simple {...}s1;struct Simple s2,s3;
    typedef struct {...}Simple;Simple s1,s2,s3;
     ```
   - 区别 
     1. 结构内的成员函数：C中的结构不能在结构内部具有成员函数，但C ++中的结构可以与成员函数一起使用。
     2. 直接初始化：我们不能直接初始化C中的结构数据成员，但我们可以在C ++中实现。
     3. 使用struct关键字： 在C中，我们需要使用struct声明一个struct变量。
     4. 静态成员：结构不能有静态成员，但C++允许使用。
     5. sizeof运算符：该运算符将为C中的空结构生成0，而在C++中为空结构生成1。
     6. 数据隐藏：C结构不允许数据隐藏的概念，但在C ++中允许，因为C++是面向对象的语言，而C不是。
     7. 访问修饰符：C结构没有访问修饰符，因为这些修饰符不被语言支配。C++结构可以具有这个概念，因为它在语言中是内置的。

6. 定义类时可以对数据成员直接赋值吗？
   - 不可以,只有产生类的实例(对象)以后才分配内存空间，此时才能初始化数据成员
   - 哪怕可以也削弱了面向对象的概念，不抽象

7. 引用
   - 定义
     - 引用就是别名，对引用的操作就是对所引用变量的操作
     - <数据类型>&<引用名>=<变量名>
     - 指针变量:<数据类型>*&<引用名>=<指针变量名>
   - 注意  
     - 必须用已知变量为其初始化
     - 初始化后不能修改
     - 不会为引用分配内存空间，与被引用对象所指为同一片内存空间
   - 应用
     - 为了在函数内部能够更改参数的值，
        - 使用引用:swap(x,y);
        - 传递指针:swap(&x,&y);
     - 函数的形参声明为引用
     - 函数的返回类型为引用,**返回的就是变量，可以作为赋值语句的左值**：index(3)=15;
       - 好处是不产生返回值的副本，且不调用临时对象的拷贝构造函数
       - 返回值`float a=fn1(5.0);`,fn1先创建临时变量再将temp的值**拷贝**给该临时变量，再将值赋值给a
       - 返回引用`float c=fn2(5.0);`,直接返回temp变量，再将值赋值给c
       - 用函数的返回值作为引用的初始化值`float &b=fn1(5.0);`,b是**临时对象**的引用,会报错
       - 用函数返回的引用作为新引用的初始化值`float &d=fn2(5.0);`,d为**全局变量**temp的引用,所以有效

8. 函数重载(overload)，函数重写(override)，函数重定义(redefining)
   - 函数重载
     - 当函数具有相同的名称，但是参数列表不相同的情形（包括参数的个数不同或参数的类型不同），这样的同名而不同参数的函数之间，互相被称之为重载函数。
     - 基本条件
       - 函数名必须相同；
       - 函数参数必须不相同，可以是参数类型或者参数个数不同；
       - 函数返回值可以相同，也可以不相同。（备注：但是如果函数的名称和参数完全相同，仅仅是返回值类型不同，是无法进行函数重载的。）
     - 用于
       - 类的构造函数
       - 类的成员函数
   - 函数重写
     - 函数重写，也被称为覆盖，是指子类重新定义父类中有**相同名称和参数**的虚函数，主要在继承关系中出现。
     - 基本条件
       - 重写的函数和被重写的函数必须都为virtual函数，并分别位于基类和派生类中；
       - 重写的函数和被重写的函数，函数名和函数参数必须完全一致；
       - 重写的函数和被重写的函数，返回值相同，或者返回指针或引用，并且派生类虚函数返回的指针或引用的类型是基类中被替换的虚函数返回的指针或引用的类型的字类型。
   - 函数重定义
     - 子类重新定义父类中有相同名称的非虚函数，参数列表可以相同可以不同，会覆盖其父类的方法，未体现多态。
     - 基本条件
       - 如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。
       - 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏。
     - 用于
       - a.show();重定义，fun(&a){a.printinfo();}重写
       - 如果fun(&b){b.show()}没有多态，哪怕fun(a),调用的还是基类函数
    - 编译时多态性：通过重载函数实现。
      运行时多态性：通过虚函数实现。
9. int a[]与int* a