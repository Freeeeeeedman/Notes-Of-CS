[toc]
### 0. 杂
1. 写算法时要考虑
   - 输入是否合规
   - 有没有特殊情况
   - 如果没有完成目的返回什么
2. 刷算法的一些小建议：
   1. 尽量使用存白板模式写题，同时加强自己的debug的能力，我们不能保证面试的时候写的代码直接AC，通过平时的debug，避免自己在面试时手足无措的情况通过bug也能加深自己对该类型的题目的理解
   2. 先分析清楚题目，确定了整体思路，再开始硬编码，不然代码越写越乱
   3. 编码期间，可以先写好整体的逻辑，再做具体的细节实现
### 1. 编程素养

#### 1.1 代码风格
1. 大驼峰命名法
    C++的函数，结构体
2. 下划线命名法
    python，linux环境下C++编程
3. 水平留白
    操作符左右一定有空格
    分隔符（, 和;）前一位没有空格，后一位保持空格
    大括号和函数保持同一行，并有一个空格
    控制语句（while，if，for）前都有一个空格
4. google规范

#### 1.2 核心代码模式和ACM模式
1. 国内企业多用牛客ACM模式
2. 要熟悉ACM模式：自己构造输入输出并编译运行
3. ACM模式构建二叉树

### 2. 算法性能分析

#### 2.1 时间复杂度$T(n)$
1. 时间复杂度
    - 假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 $O(f(n))$
2. 大O
    - 大O用来表示上界，但业内默认规定大O表示一般情况而非最坏情况。
    - 面试中说道算法的时间复杂度是多少指的都是一般情况。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着**数据用例的不一样，时间复杂度也是不同的**，这一点是一定要注意的。
3. 不同数据规模的差异
    - 一般时间复杂度是忽略常数项，是因为一般默认数据规模足够大
    - 算法不是时间复杂度越底的越好，当数据规模很小时且有常数项的情况下$O(n^2)$的算法比$O(n)$的更合适
    - 注意大常数项
    - $O(1)$常数阶 < $O(\log n)$对数阶（忽略底数） < $O(n)$线性阶 < $O(n^2)$平方阶 < $O(n^3)$立方阶 < $O(2^n)$指数阶

#### 2.2 算法超时
1. 一般OJ（online judge）的超时时间就是1s
2. 注意
    - CPU执行每条指令所需的时间实际上并不相同
    - 频繁访问相同地址的数据和访问不相邻元素所需的时间也不同
    - 计算机同时运行多个程序，每个程序里还有不同的进程线程在抢占资源

#### 2.3 递归算法的时间复杂度
1. 递归算法的时间复杂度 = 递归的次数 * 每次递归中的操作次数
2. 例：求x的n次方：$O(n)$——>$O(n)$——>$O(\log n)$
3. 满二叉树在递归算法中的应用

#### 2.4 空间复杂度$S(n)$
1. 空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小\
2. 空间复杂度是预先大体评估程序内存使用的大小,很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。

#### 2.5 递归算法的空间复杂度
1. 递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度
2. 递归调用栈最大的长度就是递归的深度
3. 例：二分法递归实现，时间复杂度是$O(\log n)$，空间复杂度为 $1 * logn = O(logn)$。但如果传递函数是拷贝整个数组而非拷贝地址时，空间复杂度为$O(n\log n)$

#### 2.6 代码的内存消耗
1. 不同语言的内存管理
   - C/C++这种内存堆空间的申请和释放完全靠自己管理
   - Java 依赖JVM来做内存管理
   - Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作
2. C++的内存管理
   - 栈区(Stack) ：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈
   - 堆区(Heap) ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS收回
   - 未初始化数据区(Uninitialized Data)： 存放未初始化的全局变量和静态变量
   - 初始化数据区(Initialized Data)：存放已经初始化的全局变量和静态变量
   - 程序代码区(Text)：存放函数体的二进制代码
3. C++数据类型大小
    ![avatar](https://img-blog.csdnimg.cn/20200804193045440.png)
4. 内存对齐
    - 跨平台的编程语言(如C++，python，java)都需要
    - 原因
      - 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐
      - 硬件原因：经过内存对齐后，CPU访问内存的速度大大提升
    - 例:int型非内存对齐，读取需要两次寻址，一次合并，浪费内存自由

### 3. 数组
#### 3.1 数组理论基础
1. 定义
    数组是存放在连续内存空间上的相同类型数据的集合
2. 注意
   - 数组下标都是从0开始的
   - 数组内存空间的地址是连续的，所以只能覆盖不能删除

#### 3.2 二分法
1. 前提
   - 有序数组
   - 数组内无重复元素，有重复时下标不唯一
2. 循环不变量原则
   - [left,right]
   - [left,rigth)
3. 例
   - 704二分查找
     - 核心:left<=right,定义找寻区间[left,right]
     - 防止溢出:int middle = left + ((right-left)/2);  
     - 未找到目标值时return -1;
   - 35搜索插入位置
     - 四种情况:在前，在后，在范围内但里面没有，在范围内里面有：return right + 1
     - 无论时哪种情况，最后退出循环时，left的值总比right大1，即此时left - right = 1
   - 34在排序数组中查找元素的第一个和最后一个位置
     - 核心:分别查找左右界rightBorder = left;
     - 判断在前或者在后的情况：设定初值int rightBorder = -2;
     - 判断在范围内并且有：(rightBorder - leftBorder)>1
   - 69x 的平方根
     - 核心:满足 k*k <= x的最大k值
     - if((long long)mid * mid <= x){k=mid;}
   - 367有效的完全平方数
     - 核心:同上
#### 3.3 双指针法
1. 数组只能覆盖不能删除某个元素
2. 暴力解法
3. 双指针法(快慢指针)
4. 例
   - 27移除元素
     - 核心:nums[slowIndex++] = nums[fastIndex];
     - 返回数组长度时return slowIndex而不是nums.size()
   - 26删除排序数组中的重复项
     - 这里nums[fastIndex] != nums[fastIndex - 1]，快慢指针初始值均为1，防止越界
     - 特殊情况，nums.size()==0时
   - 283移动零
     - 覆盖法
     - 交换法while (right < n){swap(,)}
   - 844比较含退格的字符串
     - 核心:设定#数目，双层循环，内层模拟#退格，没#时break，外层比较每个字符
     - 最终只有if(i == -1 && j == -1)才return true;
   - 977有序数组的平方
     - 核心:数组平方的最大值就在数组的两端,i,j分别指向两端，取平方大的值到新数组
   - 209长度最小的子数组
     - 核心：内外循环调整子序列的位置
     - result = result < subLength ? result : subLength;通过判断更新结果
   - 904水果成篮
     - 核心：求只包含两种元素的最长连续子序列
     - 利用慢指针的回退找齐所有同类保证连续while(left >= 1 && fruits[left - 1] = ln)left--;
     - 需要更新左右篮子的值，再通过比较更新数据max(ans,right + 1 -left);
   - 76最小覆盖子串(_困难_)


#### 3.4 模拟行为
- 59螺旋矩阵II
  - 核心:循环不变量原则，左闭右开
  - 循环内赋值i = x;j = y;确定每次螺旋开始位置
  - j < y + n - cut
  - n为奇数情况
- 54螺旋矩阵
  - 核心:设置上下左右边界，循环遍历后重新定义边界，每去掉一条边后判断该边是否交错，是则循环结束break
  - 结束循环时有可能处在任何一条边界

### 3. 链表

#### 3.1 链表理论基础
- 链表
  数据域，指针域，头结点
- 类型
  - 单链表
  - 双链表
  - 循环链表
- 存储方式
  非连续分布，分配机制取决于操作系统的内存管理
- **链表节点定义**_一定要会写！_
  ```
  struct ListNode {
    int val;
    LinkNode *next;
    ListNode(int x) : val(x), next(NULL) {}
  }
  ```
- 性能分析
  数组
  插入/删除时间复杂度O(n)，查询时间复杂度O(1),适用于数据量固定，查找频繁，较少增删的场景
  链表
  插入/删除时间复杂度O(1)，查询时间复杂度O(n),适用于数据量不固定，频繁增删，较少查询的场景

#### 203移除链表元素
- 核心:添加虚拟头结点避免特殊情况，ListNode* dummyHead = new ListNode(10);
- 判断条件位cur-> != NULL,因为下面时对cur->next节点进行操作
- 设置当前节点来遍历，ListNode* cur = dummyHead;
- 注意new了就必须delete删除，对于由题目已经创建的节点内存，要指定指针指向然后delete;
- cur->next赋值给别人意味着讲指向对象赋值，被赋值意味着指向别人(左值和右值)
#### 707设计链表
- 注意LinkedNode和MyLinkedList()的格式，以及初始化dummyHead
- 注意这题的Index是从0开始，cur = _dummyHead循环结束后执行的是Index节点的前一位节点
- while(cur->next != nullptr)，而不能是cur != nullptr，因为这样最后循环结束cur指空无法确定位置
- LinkedNode* cur = _dummyHead->next，前提是已经判断_size != 0(可以通过检查index > _size - 1判断),不然会指空
- 空指针赋值用nullptr而非null
- 删除节点一定会用到临时指针指向临时节点，然后delete

#### 206反转列表
- 双指针法，pre = pullptr，cur = head，tmp循环遍历依次反转

#### 19删除链表的倒数第N个节点
- 双指针法，slowIndex，fastIndex，注意循环次数为n+1次，才好让slowIndex取要删除节点的前一个节点
- 注意为什么要返回dummyHead->next，而不是直接返回head，要记住如果删除的为head呢？
- 一定要注意循环条件，根据题目要求而定，正着想就想行

#### 24两两交换链表中的节点
- 一定要画图，方便操作指针
- 设置cur，tmp，tmp1指针操作

#### 07链表相交
- 尾端对齐，开始比较
- 通过swap固定lenA和curA总是针对最长链表的

#### 142环形链表II
- 图：![](https://img-blog.csdnimg.cn/20210318162938397.png)
- 寻找相遇节点：设置快慢指针
- 寻找入口：从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点
- 返回nullptr:(fast != nullptr && fast->next != nullptr)


### 3. 哈希表

#### 3.1哈希表理论基础
1. 哈希表(散列表)Hash table
    哈希表是根据关键码的值而直接进行访问的数据结构
    底层实现是数组+链表或者数组+树
2. 概念
    关键字key
    值value
    键值对entry
    哈希值(哈希函数)hash function
3. 作用
    一般哈希表都是用来快速判断一个元素是否出现集合里
4. 映射
    保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作
5. 哈希碰撞
    映射后的索引位置相同
   - 拉链法
     - entry里有next指针，用链表存储
     - 拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间
   - 线性探索法
     - 冲突时向下寻找空位放置信息，要求tablesize必须大于datasize
6. _常见的三种哈希结构_
   - 数组
   - 集合set
     - std::set
     - std::multiset
     - std::unordered_set
   - 映射map
     - std::map
     - std::multimap
     - std::unordered_map
   - 使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset
   - 虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理
