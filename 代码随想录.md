[toc]
### 0. 杂
1. 写算法时要考虑
   - 输入是否合规
   - 有没有特殊情况
   - 如果没有完成目的返回什么
   - 赋初始值或者循环语句内的数据结构，为空的情况
2. 刷算法的一些小建议：
   1. 尽量使用存白板模式写题，同时加强自己的debug的能力，我们不能保证面试的时候写的代码直接AC，通过平时的debug，避免自己在面试时手足无措的情况通过bug也能加深自己对该类型的题目的理解
   2. 先分析清楚题目，确定了整体思路，再开始硬编码，不然代码越写越乱
   3. 编码期间，可以先写好整体的逻辑，再做具体的细节实现
### 1. 编程素养

#### 1.1 代码风格
1. 大驼峰命名法
    C++的函数，结构体
2. 下划线命名法
    python，linux环境下C++编程
3. 水平留白
    操作符左右一定有空格
    分隔符（, 和;）前一位没有空格，后一位保持空格
    大括号和函数保持同一行，并有一个空格
    控制语句（while，if，for）前都有一个空格
4. google规范

#### 1.2 核心代码模式和ACM模式
1. 国内企业多用牛客ACM模式
2. 要熟悉ACM模式：自己构造输入输出并编译运行
3. ACM模式构建二叉树

### 2. 算法性能分析

#### 2.1 时间复杂度$T(n)$
1. 时间复杂度
    - 假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 $O(f(n))$
2. 大O
    - 大O用来表示上界，但业内默认规定大O表示一般情况而非最坏情况。
    - 面试中说道算法的时间复杂度是多少指的都是一般情况。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着**数据用例的不一样，时间复杂度也是不同的**，这一点是一定要注意的。
3. 不同数据规模的差异
    - 一般时间复杂度是忽略常数项，是因为一般默认数据规模足够大
    - 算法不是时间复杂度越底的越好，当数据规模很小时且有常数项的情况下$O(n^2)$的算法比$O(n)$的更合适
    - 注意大常数项
    - $O(1)$常数阶 < $O(\log n)$对数阶（忽略底数） < $O(n)$线性阶 < $O(n^2)$平方阶 < $O(n^3)$立方阶 < $O(2^n)$指数阶

#### 2.2 算法超时
1. 一般OJ（online judge）的超时时间就是1s
2. 注意
    - CPU执行每条指令所需的时间实际上并不相同
    - 频繁访问相同地址的数据和访问不相邻元素所需的时间也不同
    - 计算机同时运行多个程序，每个程序里还有不同的进程线程在抢占资源

#### 2.3 递归算法的时间复杂度
1. 递归算法的时间复杂度 = 递归的次数 * 每次递归中的操作次数
2. 例：求x的n次方：$O(n)$——>$O(n)$——>$O(\log n)$
3. 满二叉树在递归算法中的应用

#### 2.4 空间复杂度$S(n)$
1. 空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小\
2. 空间复杂度是预先大体评估程序内存使用的大小,很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。

#### 2.5 递归算法的空间复杂度
1. 递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度
2. 递归调用栈最大的长度就是递归的深度
3. 例：二分法递归实现，时间复杂度是$O(\log n)$，空间复杂度为 $1 * logn = O(logn)$。但如果传递函数是拷贝整个数组而非拷贝地址时，空间复杂度为$O(n\log n)$

#### 2.6 代码的内存消耗
1. 不同语言的内存管理
   - C/C++这种内存堆空间的申请和释放完全靠自己管理
   - Java 依赖JVM来做内存管理
   - Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作
2. C++的内存管理
   - 栈区(Stack) ：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈
   - 堆区(Heap) ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS收回
   - 未初始化数据区(Uninitialized Data)： 存放未初始化的全局变量和静态变量
   - 初始化数据区(Initialized Data)：存放已经初始化的全局变量和静态变量
   - 程序代码区(Text)：存放函数体的二进制代码
3. C++数据类型大小
    ![avatar](https://img-blog.csdnimg.cn/20200804193045440.png)
4. 内存对齐
    - 跨平台的编程语言(如C++，python，java)都需要
    - 原因
      - 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐
      - 硬件原因：经过内存对齐后，CPU访问内存的速度大大提升
    - 例:int型非内存对齐，读取需要两次寻址，一次合并，浪费内存自由

### 3. 数组
#### 3.1 数组理论基础
1. 定义
    数组是存放在连续内存空间上的相同类型数据的集合
2. 注意
   - 数组下标都是从0开始的
   - 数组内存空间的地址是连续的，所以只能覆盖不能删除

#### 3.2 二分法
1. 前提
   - 有序数组
   - 数组内无重复元素，有重复时下标不唯一
2. 循环不变量原则
   - [left,right]
   - [left,rigth)
3. 例
   - 704二分查找
     - 核心:left<=right,定义找寻区间[left,right]
     - 防止溢出:int middle = left + ((right-left)/2);  
     - 未找到目标值时return -1;
   - 35搜索插入位置
     - 四种情况:在前，在后，在范围内但里面没有，在范围内里面有：return right + 1
     - 无论时哪种情况，最后退出循环时，left的值总比right大1，即此时left - right = 1
   - 34在排序数组中查找元素的第一个和最后一个位置
     - 核心:分别查找左右界rightBorder = left;
     - 判断在前或者在后的情况：设定初值int rightBorder = -2;
     - 判断在范围内并且有：(rightBorder - leftBorder)>1
   - 69x 的平方根
     - 核心:满足 k*k <= x的最大k值
     - if((long long)mid * mid <= x){k=mid;}
   - 367有效的完全平方数
     - 核心:同上
#### 3.3 双指针法
1. 数组只能覆盖不能删除某个元素
2. 暴力解法
3. 双指针法(快慢指针)
4. 例
   - 27移除元素
     - 核心:nums[slowIndex++] = nums[fastIndex];
     - 返回数组长度时return slowIndex而不是nums.size()
   - 26删除排序数组中的重复项
     - 这里nums[fastIndex] != nums[fastIndex - 1]，快慢指针初始值均为1，防止越界
     - 特殊情况，nums.size()==0时
   - 283移动零
     - 覆盖法
     - 交换法while (right < n){swap(,)}
   - 844比较含退格的字符串
     - 核心:设定#数目，双层循环，内层模拟#退格，没#时break，外层比较每个字符
     - 最终只有if(i == -1 && j == -1)才return true;
   - 977有序数组的平方
     - 核心:数组平方的最大值就在数组的两端,i,j分别指向两端，取平方大的值到新数组
   - 209长度最小的子数组
     - 核心：内外循环调整子序列的位置
     - result = result < subLength ? result : subLength;通过判断更新结果
   - 904水果成篮
     - 核心：求只包含两种元素的最长连续子序列
     - 利用慢指针的回退找齐所有同类保证连续while(left >= 1 && fruits[left - 1] = ln)left--;
     - 需要更新左右篮子的值，再通过比较更新数据max(ans,right + 1 -left);
   - 76最小覆盖子串(_困难_)
   - 15三数之和
     - 采用**双指针法**，如果使用哈希表法使得查重比较麻烦
     - 两处查重，第一处查i处，if(i > 0 && nums[i] == nums[i - 1])，注意不能从i=0处开始查，否则会缺失，如[-1,-1,2]
     - 第二处查left和right，while(right > left&&nums[right] == nums[right - 1])
     - 注意排序后当num[i]>0，就可直接返回值
   - 四数之和
     - 这题与四数相加II思路不同，四数相加II不会重复，更简单
     - 不需要判断nums[i] > target就返回,如{-5，-3，-2，0}，target==-10时则会出错
     - 防止溢出：nums[i] + nums[j] > target - nums[left] - nums[right]
#### 3.4 模拟行为
- 59螺旋矩阵II
  - 核心:循环不变量原则，左闭右开
  - 循环内赋值i = x;j = y;确定每次螺旋开始位置
  - j < y + n - cut
  - n为奇数情况
- 54螺旋矩阵
  - 核心:设置上下左右边界，循环遍历后重新定义边界，每去掉一条边后判断该边是否交错，是则循环结束break
  - 结束循环时有可能处在任何一条边界

### 4. 链表

#### 链表理论基础
- 链表
  数据域，指针域，头结点
- 类型
  - 单链表
  - 双链表
  - 循环链表
- 存储方式
  非连续分布，分配机制取决于操作系统的内存管理
- **链表节点定义**_一定要会写！_
  ```
  struct ListNode {
    int val;
    LinkNode *next;
    ListNode(int x) : val(x), next(NULL) {}
  }
  ```
- 性能分析
  数组
  插入/删除时间复杂度O(n)，查询时间复杂度O(1),适用于数据量固定，查找频繁，较少增删的场景
  链表
  插入/删除时间复杂度O(1)，查询时间复杂度O(n),适用于数据量不固定，频繁增删，较少查询的场景

#### 203移除链表元素
- 核心:添加虚拟头结点避免特殊情况，ListNode* dummyHead = new ListNode(10);
- 判断条件位cur-> != NULL,因为下面时对cur->next节点进行操作
- 设置当前节点来遍历，ListNode* cur = dummyHead;
- 注意new了就必须delete删除，对于由题目已经创建的节点内存，要指定指针指向然后delete;
- cur->next赋值给别人意味着讲指向对象赋值，被赋值意味着指向别人(左值和右值)
#### 707设计链表
- 注意LinkedNode和MyLinkedList()的格式，以及初始化dummyHead
- 注意这题的Index是从0开始，cur = _dummyHead循环结束后执行的是Index节点的前一位节点
- while(cur->next != nullptr)，而不能是cur != nullptr，因为这样最后循环结束cur指空无法确定位置
- LinkedNode* cur = _dummyHead->next，前提是已经判断_size != 0(可以通过检查index > _size - 1判断),不然会指空
- 空指针赋值用nullptr而非null
- 删除节点一定会用到临时指针指向临时节点，然后delete

#### 206反转列表
- 双指针法，pre = pullptr，cur = head，tmp循环遍历依次反转

#### 19删除链表的倒数第N个节点
- 双指针法，slowIndex，fastIndex，注意循环次数为n+1次，才好让slowIndex取要删除节点的前一个节点
- 注意为什么要返回dummyHead->next，而不是直接返回head，要记住如果删除的为head呢？
- 一定要注意循环条件，根据题目要求而定，正着想就想行

#### 24两两交换链表中的节点
- 一定要画图，方便操作指针
- 设置cur，tmp，tmp1指针操作

#### 07链表相交
- 尾端对齐，开始比较
- 通过swap固定lenA和curA总是针对最长链表的

#### 142环形链表II
- 图：![](https://img-blog.csdnimg.cn/20210318162938397.png)
- 寻找相遇节点：设置快慢指针
- 寻找入口：从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点
- 返回nullptr:(fast != nullptr && fast->next != nullptr)


### 5. 哈希表

#### 5.1哈希表理论基础
1. 哈希表(散列表)Hash table
    哈希表是根据关键码的值而直接进行访问的数据结构
    底层实现是数组+链表或者数组+树
2. 概念
    关键字key
    值value
    键值对entry
    哈希值(哈希函数)hash function
3. 作用
    一般哈希表都是用来快速判断一个元素是否出现集合里
4. 映射
    保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作
5. 哈希碰撞
    映射后的索引位置相同
   - 拉链法
     - entry里有next指针，用链表存储
     - 拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间
   - 线性探索法
     - 冲突时向下寻找空位放置信息，要求tablesize必须大于datasize
6. _常见的三种哈希结构_
   - 数组
   - 集合set
     - std::set
     - std::multiset
     - std::unordered_set
   - 映射map
     - std::map
     - std::multimap
     - std::unordered_map
   - 使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset
   - 虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理

#### 5.2 数组的映射
- 数组其实就是一个简单哈希表,将字母映射到数组上
- 定义一个数组用来记录字母出现的次数不需要记住a的ASCII，只需求出相对数值s[i] - a
- 例
  - 242有效的字母异位词
  - 383赎金信：和242稍有不同
  - _49.字母异位词分组_ 涉及标准库容器内容！还没学！
  - 438.找到字符串中所有字母异位词
    - 滑动窗口法
    - sLen < pLen的特殊情况需要直接return array<int>ans();
    - 因为先判断一开始是否匹配，所以i < sLen - pLen,最后返回的位置也是i+1;
#### 5.3 unorder_set
- 349两个数组的交集
  - 题目要求可以无序且不唯一，那么就使用unordered_set；
  - 这题不能使用数组来做哈希表，因为题目没有限制数值的大小，而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费
  - 不能所有问题都要set，因为直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算，时间开销大
- 202快乐数
  - 如何取数字各位上的数:通过循环while(n),n%10,n/=10
  - 题目描述中“无限循环”，说明会有重复的sum出现

#### 5.4 unorder_map
- 350两个数组的交集 II
  - 题目要求是返回交集且交集内重复元素数目为两者对应元素数目最小
  - 假定nums1比nums2短，若假定不成立，return intersect(nums2,nums1)；
  - unordered_map<int,int>m，m[i]，i为key，m[i]++为value表示i出现的次数
- 1两数之和
  - set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用
  - map只允许key与 value一一对应；multimap一个key可对应多个value
  - 这题注意两种特殊情况,nums[i]和nums[i]相加为目标值以及一个key对应多个value情况，通过先查找值再插入避免这两种情况
- 四数之和
  - 先求num1,num2之和，作为key-value放入map中，核心思想和两数之和一样

### 6. 字符串

#### 344反转字符串
- 注意库函数的使用，在非解题核心思路处可以使用库函数
- 双指针，swap()
#### 541反转字符串II
- 需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章
- 自己设计reverse时，**注意传入的为引用**，string& s

#### 剑指Offer 05替换空格
- 双指针法
- 数组填充类题目，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作
- 不用申请新数组，从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动导致$T(n)=O(n^2)$

#### 剑指Offer58-II.左旋转字符串
- 旋转题目：整体旋转+局部旋转
- reverse函数自定义

#### 151翻转字符串里的单词
 - 思路是先移除空格(包括开头，中间，末尾的空格)，再翻转整个字符串，再翻转被空格隔开的每个单词
 - 使用快慢指针移除多余空格，注意如果末尾有多个空格，移除完中间空格后，总是会多加一个空格，这时要判断resize(slowIndex)还是resize(slowIndex - 1)
#### KMP算法 [_还不会！_]
1. 28实现strStr()
   - 核心是通过以及匹配过的内容，减少匹配的次数
   - 直接背吧，以后再来看。构造next[i]的步骤：初始化，处理前后缀不相同的情况，处理前后缀相同的情况
   - 具体实现（实际上是模式串自己和自己匹配的过程）
     - 定义j指向前缀起始位置，i指向后缀起始位置
     - j同时表示最长相等后缀
     - 前缀表减一了，相当于右移
     - next[i]表示 i（包括i）之前最长相等的前后缀长度（其实就是j）
     - next[i] = j; // 将j（前缀的长度）赋给next[i]
2. 459重复的字符串
   - 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。
### 7. 双指针法
1. 27移除元素
2. 344反转字符串
3. 剑指Offer 05替换空格
4. 151翻转字符串里的单词
5. 206反转链表
6. 19删除链表的倒数第N个节点
7. 面试题 02.07.链表相交
8. 142环形链表II
9. 15三数之和
10. 18四数之和
11. 总结
除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将$O(n^2)$的时间复杂度，降为$O(n)$


### 8. 栈与队列
#### 栈与队列理论基础
1. 基本原理
    队列是先进先出，栈是先进后出
2. 问题
   - C++中stack 是容器么？
   - 我们使用的stack是属于那个版本的STL？
   - 我们使用的STL中stack是如何实现的？
   - stack 提供迭代器来遍历stack空间么？
3. 栈和队列是STL（C++标准库）里面的两个数据结构
   - HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。
   - P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。
   - SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。
   - 我们所用的栈和队列也是SGI STL里面的数据结构
4. 栈不提供迭代器
    栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。
5. 栈不是容器
   - 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。所以STL中栈往往不被归类为容器，而被归类为**container adapter（容器适配器）**。
   - 栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现
   - 我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。
   - 指定vector为栈的底层实现：`std::stack<int, std::vector<int> > third;`
6. 关于队列
   - 队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。
   - 队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。
   - 指定list 为起底层实现，初始化queue的语句如下`std::queue<int, std::list<int>> third; // 定义以list为底层容器的队列`

#### 232用栈实现队列
1. 使用输入栈和输出栈组合实现队列
2. stack<int>的push(),pop():不返回元素,top():返回元素

#### 225用队列实现栈
1. 使用两个队列，一个队列输入输出，另一个队列用来pop()时备份
2. queue():pop(),front(),back(),size()

#### 20有效的括号
1. 栈适合做对称匹配的题目，遇到左括号向栈内push对应的右括号
2. 三种错误情况，右括号多余，左右不匹配，左括号多余

#### 1047删除字符串中的所有相邻重复项
1. 用栈匹配
2. 遍历字符串，for(char ch : s)
3. 遍历栈，while(!st.empty())
4. 反转字符串reverse(ans.begin(), ans.end())
5. 注意要考虑栈为空时,无法调用top()
#### 150逆波兰表达式求值
1. 逆波兰表达式指的是后缀表达式
   - 优点：去掉括号后表达式无歧义
   - 适合用栈操作运算，对计算机操作友好
2. 用栈匹配，遇到算符则计算再将结果压入栈内
3. 注意string内为字符，需要stoi()转化为数字
4. 13 5 /逆波兰表达式为13/5而非5/13

#### 239滑动窗口最大值
1. 构造单调队列记录滑动窗口内可能的最大值
2. 单调队列内数值由大到小排序，端口输出，段尾输入，通过pop()和push()来实现
3. deque<int> que: pop_front(),pop_back(),push_back(),front()
4. 需要输入一开始k个值，再开始滑动窗口
5. pop时，队列内队首数值只能是最大值，所以要么之前的最大值已经被push后加入的值替代这时不能删去，要么最大值就是要脱离窗口的值，要删去

#### 347前 K 个高频元素 [_仿函数，map的迭代器还不会！_]
1. 思路：先用map构建频率，再用优先队列小顶堆对频率排序，同时优先队列小顶堆内保留k个元素
2. 仿函数传入优先队列，> 小顶堆，< 大顶堆
3. 通过迭代器遍历map，`for(unordered_map<int,int>::iterator it = map.begin(); it != map.end(); it++)`
4. 注意这里返回vector<int>(k)，倒序输入是int i = k - 1;
5. 加const 和 & 提高安全性和效率

#### 71简化路径 [_还没写_]


### 9. 二叉树
#### 9.1 二叉树理论基础
1. 二叉树的种类
   - 满二叉树
     - 如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树
     - 也可以说深度为k，有2^k-1个节点的二叉树
   - 完全二叉树
     - 结点与相同深度的满二叉树中的结点完全编号一致的二叉树
     - 优先级队列为一个堆，而堆就是一颗完全二叉树，并同时保证父子节点的顺序关系。完全二叉树一定是平衡二叉树，堆的排序是父节点大于（或小于）子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树。
   - 二叉搜索树（二叉排序树，二叉查找树）(BST)
     - 二叉搜索树是一个有序树，二叉搜索树是有数值的
     - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
     - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
     - 它的左、右子树也分别为二叉排序树
   - 平衡二叉树
   - 平衡二叉搜索树AVL（Adelson-Velsky and Landis）树
     - 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
     - C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，增删操作时间时间复杂度是logn
     - unordered_map、unordered_map底层实现是哈希表
     - **一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等**
   
2. 二叉树的存储方式
   - 链式存储
      通过指针把分布在散落在各个地址的节点串联一起
   - 顺序存储
      其实就是用数组来存储二叉树，父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2
   - 一般我们都是用链式存储二叉树
3. 二叉树的遍历方式
   - 深度优先遍历(DFS)
     - 先往深走，遇到叶子节点再往回走，左子树，根结点，右子树的访问次序
     - 前序遍历（递归法，迭代法）
     - 中序遍历（递归法，迭代法）：1.中序遍历左子树 2.访问根结点 3.中序遍历右子树
     - 后序遍历（递归法，迭代法）
   - 广度优先遍历(BFS)
     - 层次遍历（迭代法）
   - 深度优先遍历可以使用递归实现，也可以借助栈非递归实现（栈本身就是递归的一种实现结构）
   - 广度优先遍历一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树
4. 二叉树的定义（要会手写）
    ```
    二叉树结点定义
    struct TreeNode {
        int val;
        TreeNode* left;
        TreeNode* right;
        TreeNode(int x):val(x),left(nullptr),right(nullptr){}
    };
5. 二叉树中高度和深度的定义
   - 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
   - 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。
   - 注意leetcode中强调的深度和高度很明显是按照节点来计算的
   - 深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）
   - 求根节点的高度时，由于根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历。
#### 9.2 二叉树的递归遍历
   - 递归算法三要素
     1. 确定递归函数的参数和返回值
        确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
     2. 确定终止条件
        写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
     3. 确定单层递归的逻辑
         确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
   - **递归函数什么时候需要返回值？**
     - 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。
     - 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 
     - 需要的返回值时候，往往遍历不需要遍历整课树，通过返回值来判断是否需要返回
   - 整个流程
     - 主函数内判断输入是否有误（有时可以放在调用的递归函数内），判断输入有误和递归终止条件的判断要分清楚，有时是同一个，有时不是
     - 递归函数判断递归终止条件，看情况之前是否要访问某个节点处理某些情况
     - 写入单次递归内容及左右子树的递归
     - 返回值
   - 遍历函数参数内result一定要带引用，因为result是传出参数！
   - 使用某个节点的值或者调用某个数据结构的值必须其不为空，要先判断,否则会报错
   - 根据题意，有时终止条件需要多个判断
#### 9.3 二叉树的迭代遍历
   - 144前序遍历
     - 访问顺序与要处理的元素顺序一致，都是中间结点
     - 注意先要判别root结点是否为空
     - 压入左右结点时也要判断是否为空，注意输出与压入顺序相反
   - 145后序遍历
     - 前序遍历输出顺序为中左右，则改为中右左，最后再反转结果为左右中
   - 94中序遍历
     - 访问顺序与处理的元素顺序不一致
     - 先访问到最底层左结点将其压入栈内
     - 循环控制为while(cur != nullptr || !st.empty())
#### 9.4 二叉树的层序遍历
   - 102
   - 层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上
   - 借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑
   - queue是FIFO，而deque是双端队列，两者的函数不同
   - 注意返回的是vector<vector<int>>
#### 9.5 二叉树的一般性质
   - 226翻转二叉树
     - 采用递归前序，栈前序翻转
     - 采用队列层次翻转
     - 栈，队列翻转把输出到vector换成swap即可
   - 101对称二叉树
     - 递归，比较的两个树而非左右结点
     - 分别比较outside和inside，先判断有节点为空情况，再写递归内容
   - 100相同的树
     - 递归，类似101对称二叉树
     - 注意每次判断的是两个树相同位置的节点，而不是分别判断p，q的左右结点
   - 617合并二叉树
     - 前序遍历合并，可以在原树上修改，也可以新建树
     - 注意递归三要素的思路
   - 404左叶子之和
     - 审题！这里要的是左叶子之和而不是左节点之和
     - 左叶子要通过其根节点来判断，访问到根节点的适合就已经把左叶子值加上了
     - 要判断左节点是否是左叶子，最后相加
   - 513找树左下角的值
     - 层次遍历，每层的第一个值
   - 236二叉树的最近公共祖先
     - 采用后序查找，终止条件为if(root == q || root == p || root == nullptr) return root;
     - 思路是找到了p或q就一直return 对应值，如果有一个节点左右子树return的都不为nullptr，就说明其为公共子节点，return的值会一直随边传递
#### 9.6 完全二叉树
  - 222完全二叉树的节点个数
    - 采用递归后序访问
    - 使用完全二叉树的性质，递归左右子树若为满二叉树，则其节点数目为2*树深度 - 1
#### 9.7 平衡二叉树
   - 110平衡二叉树
     - 注意二叉树中高度和深度概念的差比
     - 递归：后序访问求高度,一定要判断左右子树返回值是否为-1，否则都为-1时，差值为0
     - **单层递归逻辑**：递归思路把每个节点都当成根节点，取中间一个根节点，假设其左右节点高度已知再判断
     - 根节点的高度就是二叉树的最大深度
     - 求最大最小深度（等于求对应高度），以及求高度都是从下向上遍历，所以用后序遍历
#### 9.8 二叉树深度问题
   - 104二叉树的最大深度
     - 递归：后序访问，求分别求左右子树最大深度，结果为两者之中最大+1
     - 迭代：层次遍历
     - 根节点的高度就是二叉树的最大深度
   - 559N叉树的最大深度
     - 递归：后序访问，通过循环取depth = max(depth,...);
     - 迭代;层次遍历
   - 111二叉树的最小深度
     - 递归：后序访问，注意和求最大深度不同，需要分别判断左子树为空，右子树为空，左右子树都不为空的情况
     - 因为最短路径是到叶子节点的路径，等于每个子树根结点到其叶子结点的最短路径之和
#### 9.9 二叉树路径问题
  - 注意对于路径问题，要找到的是叶子节点，终止条件都为
    if (cur->left == NULL && cur->right == NULL) {
    终止处理逻辑
    }注意后面的代码其实控制了空节点不入循环
  - 257二叉树的所有路径
    - 采用递归，前序遍历，终止条件为找到叶子节点
    - 这里访问左右子树要用到回溯的思想，递归后即回溯
    - 这题要先把根结点压入栈中再写终止条件
  - 112路径总和
    - 判断总和用减法，判断减后的值是否为0，因为这题判断count == 0即可返回，所以有返回值
    - 这题要理清思路，每一层的返回，由哪返回，返回到哪
    - if(traversal(cur->left, count)) return true;一直返回到最初调用的地方
  - 113路径总和II
    - 递归里定义的vector是临时变量，不是全局的
    - 由于采用了减法，要先把root的值输入
    - 由于要遍历整棵树，所以没有返回值，通过传出参数输出结果
    - vector<int>path; path.pop_back()
#### 9.10 二叉树构造问题
   - 106从中序与后序遍历序列构造二叉树
      - 中序与后序数组可以构造二叉树，先用后序数组的最后一个值切割中序数组，为中右左和中右，因为一个树的中序和后序数组长度一定一样，所以再用中左去切割后序数组，以此递归，返回根结点值
      - 每次切割使用左闭右开的循环不变量
      - 注意这题的终止条件
        - 如果到达的节点是叶子节点，即postBegin == postEnd,那么需要返回nullptr
        - 注意postEnd - postBegin == 1不要也行
   - 105从前序与中序遍历序列构造二叉树
     - 这题思路和106一致，也是用前序数组切割中序数组，判断终止条件也是通过前序判断
     - 注意 终止语句if(preBegin == preEnd) return nullptr;要写在赋值语句int cutValue = preorder[preBegin];前面，因为是左闭右开，不然会溢出
     - 前序和后序不能唯一确定一棵二叉树！，因为没有中序遍历无法确定左右部分，也就是无法分割，例：左123和右123，对应前序后序完全相同，但是两颗树
   -  654最大二叉树
      - 这题与105，106思路类似，也是通过maxIndex分割，再递归左右子树
      - 采用左闭右开的循环不变量
      - 注意终止条件为左右切完后为空数组，即left == right
      - 寻找数组内最大值的写法！是要找切完的数组内的最大值而是不所有的最大值！先定义maxIndex = left;再循环找！
      - 以及
           root->left = traversal(nums, left, maxIndex);
           root->right = traversal(nums, maxIndex + 1, right);
           不能把left替换为0，right替换为nums.size()
      - 注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销
#### 9.11 二叉搜索树
   - 路径搜索（迭代法）
     - 700二叉搜索树中的搜索
       - 注意对于二叉搜索树，搜索的路径是唯一确定的（这里使用前序访问方便搜索）
       - 递归法和迭代法，由于路径唯一，所以而二叉搜索树的搜索**采用迭代法十分简单**
     - 235二叉搜索树的最近公共祖先
       - 与搜索一遍二叉树的最近公共祖先不同，不采用递归来回溯采用迭代法（递归也可以用但迭代最方便）
       - 由于二叉搜索树的特性，对于p，q最近的公共节点，要么p在其左子树q在其右子树，要么相反，故采用迭代最方便，**迭代法用来搜寻特定节点很方便，因为路径唯一**
     - 701二叉搜索树中的插入操作
       - 二叉搜索树不需要搜索整个二叉树（当然！）
       - 思路：递归：按搜索路径找到空节点插入即可，通过递归函数的返回值完成父子节点的赋值
       - 这题同上题一样，采用迭代最方便
   - 构造与修改
     - 对于二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
     - 108将有序数组转换为二叉（平衡）搜索树
       - 构造二叉树时即考虑分割后递归
       - 和之前的题目不同，这题采用左闭右闭，所以递归终止条件为left > right 
       - 防止溢出：int mid = left + (right - left) / 2;
       - 如果数组不有序？那就先排序即可
       - 模板：先写终止条件，再处理每次递归的内容，再递归左右子树，最后返回当前节点给上一层
     - 669修剪二叉搜索树
       - 注意这题先要检查当前节点是否在区间内，然后返回的是递归检查当前左子树或者右子树后的结果，即要挨个寻找符合区间[low, high]的节点     
     - 450删除二叉搜索树中的节点
       - 这不同于插入操作，要涉及结构调整
       - 前序遍历，通过返回值将取代要删除节点的那个节点返回至上一层
       - 注意访问当前节点时，根据要删除节点是否为空，是否有左右节点一共有五种情况。对于左右都有节点的情况，先要将应删除节点的左子树根节点作为其右子树最左边节点的左节点，再返回其右子树的根节点，这样才复合二叉搜索树的逻辑
   - 二叉搜索树的属性
     - 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了
     - 98验证二叉搜索树
       - 二叉搜索树的特性：采用中序遍历的时候为递增序列
       - 注意
         - 不能单纯的比较左节点小于中间节点，右节点大于中间节点，我们要比较的是左子树所有节点小于中间节点，右子树所有节点大于中间节点
         - 样例中最小节点可能是int的最小值
       - 采用pre指针来代表前一个元素，要满足所有节点小于或者大于就必须采用中序遍历，每遍历到当前根节点，判断前一节点和当前节点的数值，并更新数值
     - 530二叉搜索树的最小绝对差    
       - 思路同98
       - 一定要记住二叉搜索树采用中序遍历，其实就是一个有序数组，遇到在二叉搜索树上求什么**最值，差值**之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点
       - 不要采用对待一般树的方式进行递归
     - 501二叉搜索树中的众数
       - 对于一般树，求众数采用遍历中通过哈希表统计元素频率，再将其赋值到vector<pair<int, int>>中，定义cmp，用sort对其排序，取出最高值
       - 对于二叉搜索树，中序遍历，定义pre，count，maxCount，当count > maxCount，清空result并更新maxCount即可
       - 注意pre == nullptr，赋值count = 1
     - 538把二叉搜索树转换为累加树
       - 二叉树中序遍历为有序数组
       - 使用pre，再右左中遍历即可
       - 二叉搜索树左中右遍历后相当于升序数组，右中左遍历后相当于降序数组


### 10. 回溯算法

#### 10.1 回溯算法理论基础
1. 回溯法
   - 回溯法即回溯搜索法，是一种搜索的方式
   - 回溯是递归的副产品，只要有回溯就会有递归
   - 回溯函数也就是递归函数，指的都是一个函数
2. 回溯法的效率
   - 回溯法本质为穷举，最多再加上剪枝
   - 对于一些问题暴力搜索就是最高效的解法
3. 回溯法锁解决的问题
   - 组合问题：N个数里面按一定规则找出k个数的集合
   - 分割问题：一个字符串按一定规则有几种分割方式
   - 子集问题：一个N个数的集合里有多少符合条件的子集
   - 排列问题：N个数按一定规则全排列，有几种排列方式
   - 棋盘问题：N皇后，解数独等等
   - （组合无序，排列有序；例：{1，2}，{2，1}）
4. 回溯算法的本质
   - 回溯法解决的问题都可以抽象为树形结构
   - 回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，就构成的树的深度
   - 递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）
5. 回溯法模板
   - 回溯三部曲
     - 回溯函数模板返回值以及参数
     - 回溯函数终止条件
     - 回溯搜索的遍历过程
   ```
   void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
   }
   ```
6. 复杂度分析
   - 子集问题分析：
     - 时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。
     - 空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。
   - 排列问题分析：
     - 时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。
     - 空间复杂度：$O(n)$，和子集问题同理。
   - 组合问题分析：
     - 时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
     - 空间复杂度：$O(n)$，和子集问题同理。
   - 去重的时间复杂度分析
       - uset开销大原因在回溯算法：程序运行的时候对unordered_set 频繁的insert，unordered_set需要做哈希映射相对费时间，而且insert的时候其底层的符号表也要做相应的扩充，也是费时的。
       - 而使用used数组在时间复杂度上几乎没有额外负担
       - 使组合，子集，排列问题的空间复杂度都是$O(n)$，但如果使用set去重，空间复杂度就变成了$O(n^2)$，因为每一层递归都有一个set集合，系统栈空间是n，每一个空间都有set集合。
       - used数组是全局变量，每层与每层之间公用一个used数组，所以空间复杂度是$O(n + n)$，最终空间复杂度还是$O(n)$
7. 去重总结

#### 10.2 组合问题
1. 同一个集合内的组合
   - 77组合
      -  经典问题，回溯终止条件为返回的集合大小等于要求大小
      -  在for横向遍历的时候，通过continue剪枝
   - 216组合总和 III
      - 这题用自己的写法好了，便于记忆，没写剪枝
      - 和77思路一样，在终止条件设置判断是否和是否为n
   - 39组合总和
      - 这题同样要求结果不能重复，但可以有相同的数字
      - 传递给下一层的startIndex就是i
      - 剪枝：先对数组进行排序，for循环内判断条件添加sum + candidates[i] <= target，于是如果本层之和已经大于target接下来就不用再循环
   - 40.组合总和 II
      - 先排序后去重
      - 这题集合内有重复元素，但结果不能有重复组合。要注意去重的是同一树层还是同一数枝上的元素，是同一树层的
      - 去重通过 if (i > startIndex && candidates[i] == candidates[i - 1]) {continue;}不能是i > 0；否则第一个i第二层会直接返回必须是i > startIndex
2. 不同集合内的组合
   - 17电话号码的字母组合
    - 这题总体思路同77，注意由于字符串序号从0开始，所以终止条件为index == digits.size();即每次递归开始时index值为ans中的字符串数目；index也表示树的深度
    - 数字和字符串的映射：const string letterMap[10] = { "", "", "abc",...};注意这里为了方便，0，1的映射也加入其中，为空
    - 取映射值 int num = digits[index] - '0';
    - string: push_back(),pop_back();
    - 与77，216的不同
      - 77，216求同一个集合中的组
      - 本题每一个数字代表的是不同集合，也就是求不同集合之间的组合
    - 注意：输入1 * #按键等等异常情况
      - 代码中最好考虑这些异常情况
      - 要知道会有这些异常，如果是现场面试中，一定要考虑到！

#### 10.3 分割问题
1. 131分割回文串
   - 理清思路，startIndex是每次要切割的子串的开始位置，[startIndex, i]为切下来的子串
   - 终止条件为切到末尾，注意是startIndex == s.size()
   - 注意这里的剪枝是在每次递归内判断而不是遍历到结尾后判断，用continue
   - s.substr(开始位置,切割的大小i  - startIndex + 1)
2. 93复原 IP 地址
   - 终止条件为'.'数目为3时，同时也要检查切割下来的第四段是否满足要求
   - 判断子串是否满足要求
     - start > end
     - s[start] == '0' &&  start != end
     - s[i] > '9' || s[i] < '0')
     - string cut = s.substr(start, end - start + 1); stoi(cut) > 255
   - 在原字符串上插入和删除, s.insert(s.begin() + i + 1, '.');s.erase(s.begin() + i + 1);
   - 剪枝（必须）if(s.size() > 12) return result;
   - break

#### 10.4 子集问题
1. 78子集
   - 注意组合问题的区别，组合问题不需要遍历整颗树，到叶子节点返回
   - 集合问题需要遍历整颗树，并且每遍历到当前节点就返回一次
   - 所以在终止条件前就要push_back()当前遍历当前节点前的结果
2. 90子集 II
   - 思路和78一致
   - 需要排序后去重，去重方法和组合里去重方法一致
3. 491递增子序列
   - 由于这题本身不能重排序，所以采用unorder_set去重
   - 去重方法：set.find(nums[i]) != set.end()，注意去的是横向遍历的重而不是纵向遍历的重，纵向遍历还是要依靠startIndex

#### 10.5 排列问题
1. 46全排列
   - 由于是排列所以不需要用startIndex
   - 但是需要用vector<bool> used(nums.size(), false);来标识已经用过的元素,注意这里去的是纵向遍历的重
2. 47全排列II
   - 审题：nums包含重复数据，所以要去纵向遍历的重同时也要去横向遍历的重
   - 去纵向遍历的重： if(used[i] == true) continue;
   - 去横向的重，if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {continue;}，不能只写前两个条件，因为是通过判断两个值相等来去重的，所以要通过used[i - 1] == false来判断是否是在同一层，在同一层才能横向去重,同时要先排序
3. 332重新安排行程
   - 本题要点：
     1. 终止条件为(result.size() == ticketNum + 1，即地点数是票数+1
     2. 按字典排序：通过 unordered_map<string, map<string, int>> targets;来映射，前者为出发地点，后者为到达地点
     3. 防止循环：通过target : targets，target.second > 0来限制
     4. 每层循环：  for(auto& target : targets[result[result.size() - 1]]
     5. 首先要把出发地push进result
   - 这题不需要遍历整棵树，只要找到唯一正确的路径就必须返回，所以if(backtracking(ticketNum)) return true;否则会返回空，因为这样最后一次遍历的为错误路径，会直接回溯

#### 10.6 棋盘问题
1. 51N 皇后
   - 列横向遍历，行纵向遍历
   - 排列规则
     - 不能在同一行
     - 不能在同一列
     - 不能在同一斜线
   - 行row即树的深度，列col即树的宽度
   - 注意判断是否满足规则时，只需要判断和已经放置的棋子之间是否满足规则：即向上同列，向上45°，向上135°,而对于同行的限制已经在循环内实现即row + 1
   - **for循环内多个结束条件要用&&连接而不是，！**
2. 37解数独
   - 思路
      - 通过两层循环依次访问宫格，两个continue，第一个跳过已填入的格子，第二个判断填入后的格子是否满足要求，递归直到找到一个答案直接开始返回
      - 这题没有直接的返回条件，如果针对一个任意一个格子填入的9个数字都不满足要求那么就返回false;
      - 连续返回if (backtracking(board)) return true;
   - 判断棋盘是否合法
     - 同行是否重复
        i < board.size()
     - 同列是否重复
        i < board[0].size() 因为之前已经有数值填入了！
     - 9宫格里是否重复
       int startRow = (row / 3) * 3;
       int startCol = (col / 3) * 3;
3. 这两题的差别
   - N皇后需要返回所有答案，所以为void；解数独只要返回唯一正确的答案，所以为bool
   - N皇后需要返回条件来返回答案而解数独不需要返回条件
   - N皇后是用行纵向递归+列横向循环访问，解数独是用两个for循环+continue+递归访问

### 11. 贪心算法

#### 11.1 贪心算法理论基础
1. 贪心算法的本质
    贪心的本质是选择每一阶段的局部最优，从而达到全局最优
2. 贪心算法的适用场景
   - 常识性推导加上举反例
   - 贪心算法并没有固定的套路
   - 刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心
   - 因为贪心有时候就是常识性的推导，有时也需要数学推导
4. 贪心一般解题步骤
   - 将问题分解为若干个子问题
   - 找出适合的贪心策略
   - 求解每一个子问题的最优解
   - 将局部最优解堆叠成全局最优解
#### 11.2 一般贪心
1. 455分发饼干
   - 局部最优解：最大饼干分给胃口最大的孩子
   - 不要采用两层循环来访问，而是用一层循环来遍历孩子，再用index--来遍历饼干。逻辑更加简单
2. 376摆动序列
   - 局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值
   - 整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列
   - 注意对于当前节点，curDiff指后一节点减去当前节点的值，所以i < nums.size() - 1
   - 只要1个节点或者0个直接返回其长度
   - 对于删除单一坡度上的节点，实际上是统计数组的峰值数量（节点数目>=2）
     - 对于最左节点，假设其preDiff = 0，算为1个峰值
     - 对于最右节点，定义 result = 1，算为1个峰值
     - 对于中间节点，从左向右遍历，定义 preDiff >= 0 && curDiff < 0 || preDiff <= 0 && curDiff > 0算为1个峰值。注意这样定义curDiff = 0的情况也算是单调的，就要删除对应节点，例：112211，其结果为3
3. 53最大子数组和
   - 局部最优：每次子数组之和为负就丢弃，从下一位再开始计数，因为之后的数组再加上之前和为负的数组只会变小不会变大，所以要舍弃之前的数组
   - 通过result和sum的比较来记录最大的子数组之和
   - 连续和是可以加上负数的，只要加上后的子数组和大于0，因为子数组之和是自己的值+之前的数组之和
4. 1005 K次取反后最大化的数组和
   - 局部最优：把数组内绝对值最大的负数取反，如果没有负数了且k仍大于0且为奇数则将最小的正数值取反
   - 这里按照绝对值从大到小对数组进行排序
   -  sort(nums.begin(), nums.end(), cmp);，cmp必须为static函数！
5. 134加油站
   - 局部最优：从当前地点出发到达下一地点剩下的汽油量>0
   - 注意如果对于i和i+1位置差值都大于0，由于题目要求结果要么没有要么唯一，则如果可以从i+1出发，那么必然也可以从i出发
6. 860柠檬水找零
   - 局部最优
     - 记录当前持有five，ten的数目
     - ten：找给five
     - twenty：先找five + ten，没有再找five * 3
7. 738单调递增的数字
    - 从右向左遍历，当左值大于右值时，左值-1，记录当前位置
    - 从记录的位置开始都要置为9（因为要的是最大的单调递增的值）
    - flag一开始要定义为strNum.size(),防止给的数字就满足递增的情况
8. 968监控二叉树
    - 局部最优：让叶子节点的父节点安摄像头，所用摄像头最少
    - 整体最优：全部摄像头数量所用最少
    - 三种状态
      - 无覆盖：0
      - 有摄像头：1
      - 有覆盖：2
    - 针对空节点：有覆盖2
    - 针对整棵树的跟节点：需要判断，如果为0则还要加一个摄像头
    - 后序遍历，对当前节点三种情况判断
      - 左右节点都被覆盖即left == 2 && right == 2 返回0
      - 左右节点有一个没被覆盖即left == 0 || right == 0 加摄像头，返回1
      - 左右节点有一个有摄像头即left == 1 || right == 1 返回2
      - 注意顺序不能替换，因为对于left == 1 && right == 0的这种情况必须加摄像头，返回1
#### 11.3 跳跃游戏
1. 55跳跃游戏
   - 局部最优：每次跳跃后可以得到的跳跃范围最大
   - 整体最优：得到最大跳跃范围
   - 注意判断为：cover + 1 >= nums.size()
2. 45跳跃游戏II
   - 局部最优：每次用最短的跳跃步骤找到最大的跳跃值
   - 跳跃范围：左闭右闭
   - cover含义：对于当前整个跳跃范围的下一次能跳到的最大的数组下标
   - 核心：跳到下一次跳跃范围内的任意地点只需要跳一次，下一次跳跃不需要考虑从跳跃范围内的哪一个地点跳，只需要考虑针对该跳跃范围，其能够跳跃到的最大距离是否到达数组最后一个位置，没有则还需要再跳一次
#### 11.4 区间问题
1. 452用最少数量的箭引爆气球
   - 同样两个维度
   - 局部最优：当气球出现重叠，一起射，所用弓箭最少
   - 先按开始的位置排序，当points[i][0] > points[i - 1][1]时就要增加箭
   - 箭至少要射1次所以其数目开始定义为1
   - 排序一定要传引用，不然会超时
   - 重叠时要更新当前重叠的气球的最小的右边界
   - 时间复杂度：$O(n\log n)$，因为有一个快排
   - 空间复杂度：$O(1)$
2. 435无重叠区间
   - 思路和452很像，射箭的数目即是重叠的区间数，返回为总数-重叠区间数目
   - 注意这题[0，1][1，2]不是相邻区间，所以判断条件要加上等号
   - result相当于不重叠的区间的数量
3. 56合并区间
   - for遍历，在遍历中定义每次start，end的区间，用while循环合并重叠的区间
   - 注意这题由于程序设计要对最后一个区间做单独判断，利用bool flag来判断有无添加
   - [1,2] [2,3] 算重叠
4. 763划分字母区间
   - 先记录每个字母的最远边界
   - 遍历中如果找到之前遍历的所有的字母的最远边界，那么这个边界就是分割点right = max(right, hash[s[i] - 'a']);是所有字母的最远边界
#### 11.5 股票问题
1. 122买卖股票的最佳时机 II
   - 局部最优：收集每天的正利润
   - 全局最优：全局最优：求得最大利润
   - 核心：最终利润是可以分解的，prices[3] - prices[0] = (prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。所以我们只需要记录正利润即可。每个连续正利润都组成了一次售出
   - 这题思路其实和最大子数组和很像
2. 买卖股票的最佳时机含手续费
   - 局部最优：最低值买，最高值卖
   - 通过更新minPrice设置买入
   - 当遇到连续正利润时，除了第一次假买入要减去fee，后面都不减去，即minPirce = price[i] - fee,这样组合的真正的一次买入才只减去了一次fee

#### 11.6 贪心维度权衡问题
1. 135分发糖果
   - 局部最优
     - 从左向右遍历，要求当前孩子rating如果比左孩子大则+1
     - 从右向左遍历，要求当前孩子rating如果比右孩子大则要同时满足其的糖果值大于右孩子+1以及与左孩子的比较结果，即取max
     - 注意每个孩子至少有1个糖果
2. 406根据身高重建队列
   - 多个维度先对其余一个维度排序再操作另一个维度
   - 先按身高排序，身高相同，前面人数少的排前面
   - 局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性
   - 注意
     - 这题要用链表来实现插入list<vector<int>> qlist;通过迭代器位移来插入。因为如果用vector动态数组来insert，考虑到其底层实现扩容时会再拷贝，时间复杂度会很高
     - 时间复杂度：O(nlog n + n^2)
     - 空间复杂度：O(n)

### 12. 动态规划(Dynamic Programming，DP)

#### 12.1 动态规划理论基础
1. 动态规划与贪心的区别
   - 如果某一问题有很多重叠子问题，使用动态规划是最有效的
   - 动态规划中每一个状态一定是由上一个状态推导出来的
   - 贪心没有状态推导，而是从局部直接选最优的
2. 动态规划的步骤
   - 确定dp数组（dp table）以及下标的含义
   - 确定递推公式
   - dp数组如何初始化
   - 确定遍历顺序
   - 举例推导dp数组
3. 动态规划的Debug
   - 状态转移公式是否正确
   - 打印dp数组，其是否和预想的一致
#### 12.2 一般动态规划
1. 343整数拆分
   - dp[i]对于i可获得的最大乘积
   - dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
   - 由于dp[0],dp[1],dp[2]无意义，所以循环内j < i - 1
2. 96不同的二叉搜索树
   - dp[i]i个不同元素节点组成的二叉搜索树的个数
   - dp[i] += dp[j - 1] * dp[i - j]，左边个数*右边个数
#### 12.3 楼梯问题
1. 509斐波那契数
   - 记住动态规划五部曲
   - 这题只用记录前后两个值
   - 时间复杂度O(n)， 空间复杂度O(1)
2. 70爬楼梯
   - dp[i]：到第i个阶梯有多少种方法，不需要考虑dp[0]的初始化
   - 递推公式：dp[i] = dp[i - 1] + dp[i - 2]
   - 空间复杂度也可以优化到O(1)
3. 746使用最小花费爬楼梯
   - dp[i]:到第i个阶梯最低的花费是多少，注意楼梯顶为dp[cost.size()]
   - 递推公式：dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);

#### 12.4 不同路径问题
1. 62不同路径
   - dp[i][j]：到达(i,j)有多少种路径
   - 递推公式：dp[i][j] += dp[i - 1][j] + dp[i][j - 1];
   - 时间，空间复杂度O(mxn)
2. 63不同路径 II
   - 有障碍时即跳过：if(obstacleGrid[i][j] == 1) continue;
   - 对于第一行和第一列有障碍时，障碍后都为0

#### 12.5 01背包问题
1. 01背包理论基础
   - 01背包问题
      有n件物品和最多能背重量为w的背包，第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
   - 二维dp数组
     - dp[i][j]：从下标0~i的物品中任意取出，放进容量为j的背包中，最大的价值总和
     - 不放背包：dp[i][j] = dp[i - 1][j]
     - 放背包： dp[i][j] = dp[i - 1][j -weight[i]] + value[i]
     - 所以dp[i][j] = max(dp[i - 1][j], dp[i - 1][j -weight[i]] + value[i])
     - 初始化：dp[0][j], dp[i][0]
     - 遍历顺序：先遍历物品，再遍历背包；也可以先遍历背包再遍历物品
   - 一维dp数组
     - dp[j]:容量为j的背包能放下的物品最大价值总和
     - dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
     - 遍历顺序：从后往前遍历，防止重复添加dp[0]
     - 两次遍历，必须先遍历物品，再遍历背包，否则相当于每次只加入一个物品
     - 遍历背包时，通过max来和上一层即之前一次循环的结果进行比较
     - 注意实现细节和二维的dp很不同！
     - j >= weight[i]相当于if(weight[i] > j) dp[i][j] = dp[i - 1][j];
     - dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);相当于dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
2. 416分割等和子集
   - 思路：相当于求重量为sum / 2的背包的最大能放入的物品重量
   - 对于这题物理重量即物品的价值，因为背包重量实际意义为sum / 2, 装满则说明里面的物品价值之和也为sum / 2
   - 如果sum%2 == 1直接返回false，最后判断背包能放的最大重量是否为target
3. 1049最后一块石头的重量 II
   - 思路：分两堆重量最相近的石头，其和之差的结果就是答案
   - dp[j]表示容量为j的背包，最多可以背dp[j]这么重的石头
   - 同样重量就是价值
4. 组合问题：494目标和
   - 思路：和的为一组，减的为一组，两者相减为target，即 int bagSize  = (target + sum) / 2;
   - 两种情况下不可能有结果：
     - if((target + sum) % 2 == 1) return 0;
     - int bagSize  = (target + sum) / 2;
   - dp[j]:背包大小为j有多少种方法将其装满
   - 初始化dp[0] = 1 ！
   - dp[j] += dp[j - nums[i]];
   - 注意遍历i时代表，从0~i中取出。逻辑是：在当前i层，如果i大于背包容量，那么这时的方法数就是上一层的方法数，当i小于背包容量，那么这时的方法数为加入i时剩余容量的方法数(即上一层的方法数)。容量j的方法数即为遍历i的方法数之和（放i和不放i的方法数之和）
5. 474一和零
   - 01背包且背包为二维
   - dp[i][j]：最多有i个0和j个1的strs的最大子集的大小
   - 注意是三层嵌套循环

#### 12.6 完全背包问题
1. 完全背包理论基础
   - 完全背包和01背包问题不同的地方就是，每种物品有无限件
   - 代码层面体现在：从小到大去遍历
   - 在纯完全背包问题中，两个for循环的先后循序，都不影响计算dp[j]所需要的值
   - 因为dp[j] 是根据下标j之前所对应的dp[j]计算出来的（正序遍历）。 只要保证下标j之前的dp[j]都是经过计算的就可以了
   - 注意对于方法问题：如果先遍历物品再遍历背包为组合问题；先遍历背包再遍历物品为排列问题！
2. 组合问题：518零钱兑换 II
   - 同样dp[j] += dp[j - coins[i]]
  
3. 排列问题：377组合总和 Ⅳ
   - 先遍历背包再遍历物品为排序问题
   - 此时背包从0开始遍历，且根据题意要求，所以要 if(i < nums[j] || dp[i] > INT_MAX - dp[i - nums[j]]) continue;
4. 排列问题：70爬楼梯
   - 采用完全背包的排列问题做法，每次可以爬1~m阶楼梯
5. 求最小值：322零钱兑换
   - 注意由于这题的要求是最少硬币个数，所以为避免值被初始值覆盖，dp数组初始化必须为INT_MAX
   - 循环内要跳过dp[j - coins[i]] == INT_MAX的情况，防止溢出
6. 求最小值：279完全平方数
   - 注意对于一般的完全背包问题先遍历背部还是物品都没有问题，dp[i]指背包为i最多能装多少物品
   - 而对于要计算方法数的完全背包问题，即dp[i]代表的是把背包为i装满的方法数
     - 组合：先遍历物品再遍历背包
     - 排列：先遍历背包再遍历物品
7. 139单词拆分
   - dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。
   - 初始化：dp[0] = true;
   - 遍历顺序：先背包后物品
   - 注意要通过unordered_set来判断子串是否在字典内