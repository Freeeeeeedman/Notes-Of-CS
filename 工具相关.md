
#### gcc
1. GCC
   - GCC(GNU Compiler Collection)即GNU编译器套件，属于一种编程语言编译器
   - 其原名为GCC（GNU C Compiler）即GNU c语言编译器，虽然缩写一样但是功能上区别很大。
   - GCC的初衷是为GNU操作系统专门编写的一款编译器，原本的GNU是专用于编译C代码，现如今已扩展为可以编译C、C++、Java、Objective-C等多种编程语言的编译器集合了
2. GCC、gcc、g++三者关系
   - gcc（GNU C Compiler）是GCC中的c编译器，而g++（GNU C++ Compiler）是GCC中的c++编译器。
   - gcc和g++两者都可以编译c和cpp文件，但存在差异。
     - gcc在编译cpp时语法按照c来编译但默认不能链接到c++的库导致会在编译和链接阶段报错。
     - g++编译.c和.cpp文件都统一按cpp的语法规则来编译,编译.c时调用gcc，所以不会报错
   - 所以一般编译c用gcc，编译c++用g++
3. gcc和g++编译选项
   - 一般流程
     - 预处理: g++ -E test.cpp -o test.i(预处理代码)
     - 编译: g++ -S test.i -o test.s(汇编代码)
     - 汇编: g++ -c test.s -o test.o(二进制机器码)
     - 链接: g++ test.o -o test(可执行文件)
   - 动态链接与静态链接
     - 动态链接: 为默认情况g++ test.cpp -o test 
     - 静态链接: g++ -static test.cpp -o test1, test1会比test大很多
   - 静态库与动态库创建
     - 注意在包含有多个源文件的情况下，编译时需要将源文件也加上
         g++ test.cpp hello.cpp -o test
     - 静态库
       - 先汇编：g++ hello.cpp -o hello.o
       - 再打包：ar -crv libmyhello.a hello.o
       - 最后链接：g++ test.cpp libmyhello.a -o test
       - ar打包命令
         - -c：新建打包文件
         - -r：替换归档中已有的文件或加入新文件
         - -v：显示运行的完整信息
         - -t：显示归档文件的内容
         - -x：从归档文件中解压文件，利用选项-o可以指定解压的文件
               ar -x libfunc.a -o add.o
     - 动态库
       - 先汇编：g++ hello.cpp -o hello.o
       - 创建动态库：g++ -fpic -shared hello.cpp -o ../lib/libhello.so
       - 动态链接：g++ test.cpp ../lib/libhello.so -o ../bin/test1
       - 查看依赖关系:ldd test1
       - 目录树：
         - 源文件src：*.cpp, *.h, *.o
         - 库文件lib: *.so, *.a
         - 可执行文件bin:*
   - 额外选项
     - 路径
       - -l:指定库文件
       - -L：指定库文件目录
            g++ test.cpp -o test -lmyhello -L../lib
       - -I：指定头文件目录
            g++ test.cpp -o test -lmyhello -L../lib -I../head
     - -Wall: 允许发出gcc提供的所有有用的报警信息
     - -g:    产生带有调试信息的目标代码
        
#### makefile
1. 功能
   - 自动化编译，极大的提高了软件开发的效率。
   - makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令    
2. 规则
   - 如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。
   - 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。
   - 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序   
3. 格式
   - 执行：make
   - 执行指令：make 指令
   - 新旧：按照规则，依赖文件比目标文件新时就可以执行，旧的话就没必要执行
    ```
      目标XX1:依赖文件
      <TAB>命令1
      <TAB>命令2
      
      指令1：
         命令1
         命令2
    ```
4. 举例
   ```
   CC=g++
   OBJS=main.o tool1.o tool2.o
   EXE=main

   $(EXE):$(OBJS)
      $(CC) $^ -o $@
   %.o:%.cpp
      $(CC) -c $< -o $@

   .PHONY:clean print
   clean:
      rm -rf *.o main
   print:
	   @echo 编译器是:$(CC)
   ```
5. 变量定义
   - =，值取决于最后一次赋值
      ```
      buf = a
      name = $(name)
      buf = b
      //最后name的值为b
      ```
   - :=，值取决于当前的赋值
   - +=，变量追加，用空格隔开
6. 自动化变量
   - $@:目标集合
   - $^:依赖集合
   - $<:依赖集合中的第一个依赖,在有匹配符%的情况下，等效于表示所有依赖的集合
   - $?:比目标新的依赖集合
7. %, *, $, @, ;, \, #
   - 匹配符%
     - 是匹配而不是通配
     - 例先要找test1.o的构造规则，看看Makefile中那个规则符合，发现%.o:%.c的规则匹配，于是先执行%.o:%.c
     - 先查找具体命令，查找不到再执行匹配符的命令。
     - 当需要编译一个文件夹下的所有.c文件时，必须先设置没有匹配符的目标
         ```
         all:$(subst .c,.o,$(wildcard *.c))
         
         %.o:%.c
            gcc -o $@ $<         
         ```
   - 通配符*
      *.c代表当前目录所有后缀为.c的文件集合
   - $
     - 变量引用：`$(name)`
     - 函数调用：`SRCS = $(wildcard *.cpp)`
     - shell命令:`SRCS = $(shell ls *.cpp`  
   - @
     避免回显，不再显示要被执行的命令
      `@echo $(name)`
   - ;
     - 每行命令都是在一个独立的子shell进程中被允许。如果不同的命令要在个子shell中执行
     - 在同一行书写，用 ; 隔开
     - 在不同行书写，以 \ 结尾
     - 例
      ```
      print:
         cd ../;\
         pwd      
      ```
   - `#`
      用于注释
8. 伪目标
   - 格式
      ```
      .PHONY:clean print
      clean:
         rm -rf *.o main      
      ```
   - 原因
      没有标注为伪目标时，会将clean作为目标文件来使用，这样如果当前目录已经有clean文件，而clean后又无依赖，会报出clean是最新文件，导致下面的命令无法执行。设置为伪目标时可以避免这种情况
9.  常用函数
   - \$(wildcard 寻找的文件)
   - \$(subst 要被替换的字符串,用来替换的字符串,被处理的字符串)
      `all:$(subst .c,.o,$(wildcard *.c))`
   - \$(patsubst <pattern>, <replacement>, <text>)模式匹配字符串替换
      `$(patsubst %.c, %.o, $(wildcard *.c))`
   - \$(basename 文件名)取文件名
      `$(basename a.c)`得到a
   - \$(dir <name...>)取目录
      `$(dir </src/a.c>)`得到/src
   - \$(notdir <name...>)
      `$(notdir <src/a.c>)`得到a.c
   - foreach：完成循环
      ```
      $(foreach <var>, <list>, <text>)
      SRCDIRS := dira dirb dirc 
      $(foreach dir, $(SRCDIRS), $(wildcard $(dir) / *.c))      
      ```

#### shell

#### gdb
1. 启动调试
   - 被调试的程序需要带调试信息
     - gcc -g -o hello_server hello_server.c
     - 关闭编译器优化
       - gcc -g -o - O0 hello_server hello_server.c
       - 使得调试的时候，符号文件显示的调试变量等能与源代码完全对应
     - 移除调试信息
         strip hello_server
   - 启动gdb调试
     - 直接调试目标程序
        gdb filename
     - 附加进程（运行中调试）
       - ps -ef | grep chatserver
       - gdb attach 程序进程ID   
       - detach
     - 调试 core 文件（进程Crash之后定位问题）
       - ulimit -c unlimited
       - 永久生效：~/.bashrc
       - gdb filename corename
       - 注意多个程序崩溃时产生多个core文件，由于程序已结束，无法通过core文件的PID来区分core文件对应的到底是哪个服务
         - 程序启动时记录PID
         - 自定义 core 文件的名称和目录：echo "/corefile/core-%e-%p-%t" > /proc/sys/kernel/core_pattern
2. 控制命令
   - help 
      help info
   - run (r) 
     - 第一次r：启动调试
     - 启动后ctrl + c，r：重启程序
   - continue (c)
      继续运行
   - break (b)
     - 添加断点
     - 在函数名为functionname的入口处添加一个断点
         break functionname
     - 在当前文件行号为LineNo处添加一个断点
         break LineNo
     - 在filename文件行号为LineNo处添加一个断点(多文件编译后调试时很实用)
         break filename:LineNo
   - tbreak 临时断点
   - backtrace (bt), frame (f)
     - 查看当前调用堆栈
         bt
     - 切换堆栈
         f 堆栈编号（编号不用加#）
   - info break (info b), enable, disable, delete
      注意这些命令后不加编号则表示针对所有断点
   - next (n), step (s), until (u), finish, return, jump (j)
     - next(n)
       - ”单步步过“（step over），即遇到函数调用不进入函数体内部而直接跳过；
       - 注意在 gdb 命令行界面如果直接按下回车键，默认是将最近一条命令重新执行一遍，所以，当我们使用 next 命令单步调试时，不必反复输入 n 命令，直接回车就可以了
     - step(s)
       - ”单步步入“（step into），遇到函数调用，进入函数内部
       - 注意对于fun3(func1(), func2())情形，函数调用是从右往左的
     - finish
         执行完当前函数并回到上一层调用处
     - return
         立即结束执行当前函数并返回，也就是说，如果当前函数还有剩余的代码未执行完毕，也不会执行了
     - until (u)
       - 指定程序运行到某一行停下来
       - 可以用于直接跳到某一行
            u 2774
     - jump (j)
       - 让程序执行流跳转到指定位置执行
            行为也是不可控制的，例如您跳过了某个对象的初始化代码，直接执行操作该对象的代码，那么可能会导致程序崩溃或其他意外行为 
       - 如果 jump 跳转到的位置后续没有断点，那么 gdb 会执行完跳转处的代码会继续执行
       - 也可以执行一些我们想要执行的代码，而这些代码在正常的逻辑下可能并不会执行，当然也因此会产生一些非预期结果
   - set args, show args
     - set args
       设置命令行参数后再执行
     - show args
       显示命令行参数
     - 如果您单个命令行参数之间含有空格，可以使用引号将参数包裹起来
       set args "999 xx" "hu jj"
     - 如果想清除掉已经设置好的命令行参数，使用 set args 不加任何参数即可  
   - dir
     - 让被调试的可执行程序匹配源代码
     - gcc/g++ 编译出来的可执行程序并不包含完整源码，-g 只是加了一个可执行程序与源码之间的位置映射关系，我们可以通过 dir 命令重新定位这种关系。比如当cpp源文件被移动时。         
     - 加一个源文件路径到当前路径的前面,指定多个路径，可以使用”:”
         dir SourcePath1:SourcePath2:SourcePath3
3. 显示命令
   - list (l)
     - 查看当前断点附近的代码
     - 往前和往后显示代码
         list +, list -
   - print (p)
     - 打印变量值
     - 输出一些函数的执行结果
         p strerror(errno)
     - 修改变量的值
         p server.port=6400
     - 指定输出格式
         print /format variable
     - 输出一个变量的类型
         ptype server避免查看定义
   - info, thread **多线程调试**
     - 查看所有线程
         info threads
     - 切换线程
         thread 2
     - 查看当前函数参数值
         info args
     - 查看指针指向的对象的值
         p *eventLoop
         p eventLoop->maxfd
     - disassemble
       - 查看汇编指令
       - 这个命令在我们只有程序崩溃后产生 core 文件，且无对应的调试符号时非常有用，我们可以通过分析汇编代码定位一些错误。
4. 监视命令
   - watch
     - 功能 
         非常强大，可以用来监视一个变量或者一段内存，当这个变量或者该内存处的值发送变化时，gdb 就会中断下来。监视某个变量或者某个内存地址会产生一个“watch point”（观察点）。
     - 应用情形
         有一个变量其值被意外的改掉了，通过单步调试或者挨个检查使用该变量的代码，工作量非常大，如何快速地定位到该变量在哪里被修改了
     - 注意
         需要注意的是：当设置的观察点是一个局部变量时。局部变量无效后，观察点也会失效。
     - 格式
       - 整形变量
            int i;
            watch i
       - 指针类型
            char *p;
            watch p 与 watch *p
            watch p 与 watch *p 是有区别的，前者是查看 *(&p)， 是 p 变量本身；后者是 p 所指的内存的内容，一般是我们所需要的，我们大多数情况就是要看某内存地址上的数据是怎样变化的。
       - watch 一个数组或内存区间
            char buf[128];
            watch buf
            这里是对 buf 的 128 个数据进行了监视。
   - display
     - 监视的变量或者内存地址，每次程序中断下来都会自动输出这些变量或内存的值
     - display $ebx
5. **多线程调试**
   - 一般流程
     - gdb main, ctrl + c, info threads, thread 2, bt, frame 3, print, b func1, r, bt, b func2, r, bt
     1. 使用 gdb main将程序跑起来，然后按 Ctrl + C 将程序中断下来，使用 info threads 命令查看当前进程有多少线程
     2. 使用 thread 线程编号 可以切换到对应的线程去，然后使用 bt 命令可以查看对应线程从顶到底层的函数调用，以及上层调用下层对应的源码中的位置；当然，你也可以使用 frame 栈函数编号切换到当前函数调用堆栈的任何一层函数调用中去，然后分析该函数执行逻辑，使用 print 等命令输出各种变量和表达式值(栈底为main函数说明是主线程)
     3.  接着我们分别通过得到的各个线程的线程函数名去源码中搜索，找到创建这些线程的函数（下文为了叙述方便，以 f 代称这个函数），再接着通过搜索 f 或者给 f 加断点重启程序，再通过bt查看函数f是如何被调用的，这些操作一般在程序初始化阶段
   - 多线程调试存在的问题
     - 希望执行流一直在某个线程执行，而不是切换到其他线程
     - A, B, C, D四个线程，为 B, C, D分别设置了断点，会导致在对A进行调试时，可能是线程 B、C、D 触发了各自的的断点，此时调试的线程会变为 B、C 或者 D，而此时打印相关的变量值，可能就不是我们期望的线程 A 函数中的相关变量值
     - 同时我们单步调试线程 A 时，我们不希望线程 A 函数中的值被其他线程改变
   - 锁定执行流
     - set scheduler-locking on 
         可以用来锁定当前线程，只观察这个线程的运行情况， 当锁定这个线程时， 其他线程就处于了暂停状态
     - set scheduler-locking step 
         也是用来锁定当前线程，当且仅当使用 next 或 step 命令做单步调试时会锁定当前线程
     - set scheduler-locking off 
         用于关闭锁定当前线程
6. 多进程调试
   - 含义
      这里说的多进程程序指的是一个进程使用 Linux 系统调用 fork 函数产生的子进程，没有相互关联的进程就是普通的 gdb 调试，不必刻意讨论
   - 方法1
     - 流程
         用 gdb 先调试父进程，等子进程被 fork 出来后，使用 gdb attach 到子进程上去。当然，您需要重新开启一个 Shell 窗口用于调试
     - 缺点
         程序已经启动了，我们只能使用 gdb 观察程序在这之后的行为，如果我们想调试程序从启动到运行起来之间的执行流程，方法一可能不太适用。有些读者可能会说，我用 gdb附加到进程后，我加好断点然后使用 run 命令重启进程这样不就可以调试程序从启动到运行起来之间的执行流程了。问题是这种方法不是通用的，因为对于多进程服务模型，有些父子进程有一定的依赖关系，是不方便在运行过程中重启的。这个时候就可以使用方法二来调试了
   - **方法2(推荐使用)**
     - set follow-fork mode
         gdb 调试器提供一个选项叫 follow-fork ，通过 set follow-fork mode 来设置是当一个进程 fork 出新的子进程时，gdb 是继续调试父进程（取值是 parent）还是子进程（mode取值是 child），默认是父进程（mode取值是 parent）
     - show follow-fork mode
         查看当前值
     - 调试父进程
         gdb nigx, ctrl + c, bt
     - 调试子进程
         gdb nigx
         set follow-fork child
         run
         ctrl + c
         bt
7. gdb实用调试技巧
   - 将 print 显示的字符串或字符数组显示完整
      set print element 0,这样再次使用 print 命令就能完整地显示该变量所有字符串了。
   - 让被gdb调试的程序接收信号
     - 默认ctrl + c即SIGINT被gdb接受，无法模拟被调试的程序接受改信号
     - signal SIGINT
         手动发送
     - handle SIGINT nostop print
         改变 gdb 信号处理的设置，通过 handle SIGINT nostop print 告诉 gdb 在接收到 SIGINT 时不要停止、并把该信号传递给调试目标程序 
   - 明明函数存在，添加断点时却无效的解决方案
      使用使用 break functionName断点无效时，就应当使用该函数所在的代码文件和行号这种方式添加断点就能添加同样效果的断点
8. 调试中的断点
   - 硬件断点
     - 硬件断点又叫数据断点，这样的断点其实就是我们上文中介绍的用 watch 命令添加的部分断点（atch 添加的断点，有部分是软中断实现的，不属于硬件断点）。
     - 硬件断点触发时机是当监视的内存地址或者变量值发送变化时，就会触发
   - 普通断点
     添加的断点除去条件断点和硬件断点以外的断点
   - 条件断点
     - 满足某个条件才会触发的断点
     - 对于大型项目在代码内增加if条件再重新编译耗费时间
     - break [lineNo] if [condition]
         其中lineNo 是程序触发断点后需要停的位置，condition 是断点触发的条件
     - condition 断点编号 断点触发条件
         先添加一个普通断点，再使用condition 断点编号 断点触发条件
         b 11
         info b
         condition 1 i==5000
9. 自定义gdb调试命令
   - 有些场景下，我们需要根据自己的程序情况，自定义一些可以在调试时输出我们程序特定信息的命令。
   - 在 Linux 用户根目录下，root 用户就是 /root 目录，非 root 用户，是/home/用户名 这个目录。在上述目录中自定义一个 .gdbinit 文件即可，注意在 linux 系统中这是一个隐藏文件，可以使用 ls -a 命令查看；如果不存在，创建一个就可以。然后在这个文件中写上你自定义命令的 shell 脚本就可以
10. gdbtui
    - list显示源码不方便，gdbtui直接显示所有源码
    - 开启
      - gdbtui -q 需要调试的程序名
      - 直接使用 gdb 调试代码，在需要的时候使用切换键 ctrl + x + a 调出 gdbtui
11. **cgdb(强烈推荐使用)**
    - cgdb 本质上只是对 gdb 命令的一层封装，所以原来所有适用gdb 的命令也同样适用 cgdb
12. VisualGDB(以后学)
    - VisualGDB 是一款 Visual Studio 插件，安装以后可以在 Windows 系统上利用 Visual Studio 中调试远程的 Linux 程序，这样的好处就是可以利用 Visual Studio 强大代码阅读和调试功能阅读、调试 Linux程序
#### git
1. 简介
   git是版本控制系统，特点是支持分支管理与版本回退。
2. 工作流程
   - 克隆 Git 资源作为工作目录。
   - 在克隆的资源上添加或修改文件。
   - 如果其他人修改了，你可以更新资源。
   - 在提交前查看修改。
   - 提交修改。
   - 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。
3. 基本概念
   - 工作区:即当前目录
   - 暂存区：.git/index
   - 版本库：.git
   - 本地仓库，远程仓库
4. 基本操作
   - 创建仓库
      git init
   - 拷贝远程仓库(也是创建)
      git clone https://github.com/Freeeeeeedman/hello-world
   - 配置
      git config --list
      git config --global user.name "freedman1984"
      git config --global user.email "freedman1984@hotmail.com"
   - 提交与修改
     - git add
         添加文件到暂存区
     - git status
         查看仓库当前的状态，显示有变更的文件
         缩略-s
     - git diff
         - git diff [file]:显示暂存区和工作区的差异
         - git diff --cached [file]:显示暂存区和上一次提交(commit)的差异
         - git diff [first-branch]...[second-branch]:显示两次提交之间的差异
     - git commit
         - git commit [file] -m "message"
         - git commit -a:修改文件后不需要执行 git add 命令，直接提交
     - git rm
         - git rm <file>:将文件从暂存区和工作区中删除
         - git rm --cached <file>:从跟踪清单中删除,但仍保留在当前工作目录中
     - git mv
         git mv [file] [newfile]:移动或重命名一个文件、目录或软连接
   - 查看提交历史
     - git log --oneline:查看历史记录的简洁的版本
     - git log --graph:查看版本记录的图形
   - 回退版本 
     - git reset --mixed
       - 默认方式，等同于git reset
       - 重置HEAD和暂存区，保留工作区。修改内容还在，变成未add的状态。
     - git reset --soft
       - 重置HEAD，保留暂存区和工作区。修改内容还在，变成已add的状态。
     - git reset --hard（使用时一定要小心！）
       - 重置HEAD,暂存区和工作区。修改内容直接丢失，修改的代码不会变成未add的状态。
     - 回退多个版本
         git reset HEAD^^^
         git reset HEAD~3
5. 分支管理
   - 创建分支
      git branch (branchname)
   - 切换分支命令:
      git checkout (branchname)
   - 创建并切换分支
      git checkout -b (branchname) 
   - 删除分支
      git branch (branchname)
   - 合并分支
      git checkout master
      git pull origin master(多人开发时需要先拉取别人的更新)
      git merge test
      git push origin master(多人开发时提交到服务器)
   - 切换至历史版本
      git checkout [version ID]
   - 在历史版本基础上修改，创建分支
      git switch -c [branchname]
6. 变基
   - merge合并分支的方式
      三方合并。将两个分支的最新快照(C3, C4)和二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）
   - rebase变基合并分支的方式
      - 检出 experiment 分支，然后将它变基到 master 分支
         git checkout experiment
         git rebase master
      - 首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。即相当于在C3上又进行了C4的操作。最终experiment和master都指向C4'
   - 用途
      变基使得提交历史更加整洁。确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先**在自己的分支里进行开发**，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。
   - 风险
      - 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。
      - 因为变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。当别人进行合并提交后，我们git pull合并了，然后别人再回滚改为变基，会多出来内容相同但是实际不同的提交，而我们如此再次git pull会合并两次相同内容的提交。并且导致由于变基丢失的提交又回来了，使得整个历史非常混乱。
7. 标签
   - 创建带注解的标签
      git tag -a v1.0 -m ''
   - 追加标签
      git tag -a v0.9 85fc7e7
   - 查看所有标签
      git tag
   - 查看此版本所修改的内容
      git show v1.0
   - 删除标签
      git tag -d v1.1
8. 远程仓库
   - 创建远程仓库
      - 直接clone
         git clone https://github.com/Freeeeeeedman/hello-world
      - 创建本地仓库再添加远程库
         git init
         git remote add origin https://github.com/Freeeeeeedman/hello-world
         git pull
      - 注意一般一个本地仓库连接一个远程仓库，当有时候需要提交到多个远程仓库时，也可以连接到多个远程仓库
   - 添加仓库
      - git remote -v 显示所有远程仓库
      - git remote show [remote] 显示某个远程仓库的信息   
      - git remote add [shortname] [url] 添加远程版本库
      - git remote rm name 删除远程仓库
      - git remote rename old_name new_name 修改仓库名
   - 拉取更新
     - git fetch <远程主机名> 将某个远程主机的更新全部取回本地
     - git fetch <远程主机名> <分支名> 取回特定分支的更新
     - git log -p FETCH_HEAD 
     - 最终要将拉取的更新合并到当前本地分支
         git merge FETCH_HEAD
     - git fetch remote_repo remote_branch_name:local_branch_name 
         这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name ，并在本地创建local_branch_name 本地分支保存远端分支的所有数据。
   - 拉取更新并合并到本地
     - git pull <远程主机名> <远程分支名>:<本地分支名>
     - 如果远程分支是与当前分支合并，则冒号后面的部分可以省略
   - 推送更新到远程仓库
     - git push <远程主机名> <本地分支名>:<远程分支名>
         git push origin master:main
     - 如果本地分支名与远程分支名相同，则可以省略冒号：git push <远程主机名> <本地分支名>
     - 强制推送(不建议使用！不可逆！)
        - 会直接用本地分支替换远程分支：git push --force origin master
        - 一般用于回退后再推送
            git reset --hard commit ID
            git push --force origin master
     - 删除主机分支
         git push origin --delete master

#### vim
1. 正常模式
   - 默认模式，两下ESC进入
   - 移动光标
      首行：gg，末行：G
      翻屏：ctrl + u （up），ctrl + d （down）
   - 复制/粘贴
      5yy, p, P
   - 剪切/删除
      删除行5dd+p, dd, D(清空)
      删除字符：x, nx, X
   - 撤销与恢复
      u, ctrl+r
2. 命令模式
   - 正常模式下，:进入
   - 保存，退出
      :w, :wq
   - 查找
      /word 光标之后查找字符串word，按n向后搜索，按N向前搜索
      ?word光标之前查找字符串word，按n向前搜索，按N向前搜索
   - 替换
      `:s/要替换的关键词/替换后的关键词`
      `:s/要替换的关键词/替换后的关键词/g`
      `:%s/要替换的关键词/替换后的关键词`
      `:%s/要替换的关键词/替换后的关键词/g`
   - 显示行号
     :set nu， 取消行号:set nonu
3. 插入模式
   - 正常模式下，i, a进入
   - i 在光标所在字符前开始输入文字并进入插入模式。
   - I 在行首开始输入文字并进入插入模式。此行首指第一个非空白字符处。如果行首有空格，则在空格之后输入文字并进入插入模式
   - a 在光标所在字符后开始输入文字并进入插入模式
   - A 在行尾开始输入文字并进入插入模式。这个好用，您不必管光标在此行的什麽地方，只要按 A 就会在行尾等着您输入文字。
   - o 在光标所在行的下面单独开一新行，来输入文字并进入插入模式
   - O 在光标所在行的上面单独开一新行来输入文字并进入插入模式
4. 可视模式
   - 正常模式下，ctrl + v（可视列）或V（可视行）或v（可视）
   - 其他操作同正常模式
   - 添加#多行注释
     - 按Esc退出到命令模式，按gg切换到第1行
     - 然后按Ctrl+v进入到可视列模式
     - 在行首使用上下键选择需要注释的多行
     - 按下键盘（大写）“I”键，进入插入模式（Shift + i）
     - 输入#号注释符
   - 去除#多行注释（!）
     - 按Esc退出到命令模式，按gg切换到第1行
     - 然后按Ctrl+v进入可视化区块模式（列模式）
     - 使用键盘上的方向键的上下选中需要移除的#号注释



