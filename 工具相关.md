
#### gcc
1. GCC
   - GCC(GNU Compiler Collection)即GNU编译器套件，属于一种编程语言编译器
   - 其原名为GCC（GNU C Compiler）即GNU c语言编译器，虽然缩写一样但是功能上区别很大。
   - GCC的初衷是为GNU操作系统专门编写的一款编译器，原本的GNU是专用于编译C代码，现如今已扩展为可以编译C、C++、Java、Objective-C等多种编程语言的编译器集合了
2. GCC、gcc、g++三者关系
   - gcc（GNU C Compiler）是GCC中的c编译器，而g++（GNU C++ Compiler）是GCC中的c++编译器。
   - gcc和g++两者都可以编译c和cpp文件，但存在差异。
     - gcc在编译cpp时语法按照c来编译但默认不能链接到c++的库导致会在编译和链接阶段报错。
     - g++编译.c和.cpp文件都统一按cpp的语法规则来编译,编译.c时调用gcc，所以不会报错
   - 所以一般编译c用gcc，编译c++用g++
3. gcc和g++编译选项
   - 一般流程
     - 预处理: g++ -E test.cpp -o test.i(预处理代码)
     - 编译: g++ -S test.i -o test.s(汇编代码)
     - 汇编: g++ -c test.s -o test.o(二进制机器码)
     - 链接: g++ test.o -o test(可执行文件)
   - 动态链接与静态链接
     - 动态链接: 为默认情况g++ test.cpp -o test 
     - 静态链接: g++ -static test.cpp -o test1, test1会比test大很多
   - 静态库与动态库创建
     - 注意在包含有多个源文件的情况下，编译时需要将源文件也加上
         g++ test.cpp hello.cpp -o test
     - 静态库
       - 先汇编：g++ hello.cpp -o hello.o
       - 再打包：ar -crv libmyhello.a hello.o
       - 最后链接：g++ test.cpp libmyhello.a -o test
       - ar打包命令
         - -c：新建打包文件
         - -r：替换归档中已有的文件或加入新文件
         - -v：显示运行的完整信息
         - -t：显示归档文件的内容
         - -x：从归档文件中解压文件，利用选项-o可以指定解压的文件
               ar -x libfunc.a -o add.o
     - 动态库
       - 先汇编：g++ hello.cpp -o hello.o
       - 创建动态库：g++ -fpic -shared hello.cpp -o ../lib/libhello.so
       - 动态链接：g++ test.cpp ../lib/libhello.so -o ../bin/test1
       - 查看依赖关系:ldd test1
       - 目录树：
         - 源文件src：*.cpp, *.h, *.o
         - 库文件lib: *.so, *.a
         - 可执行文件bin:*
   - 额外选项
     - 路径
       - -l:指定库文件
       - -L：指定库文件目录
            g++ test.cpp -o test -lmyhello -L../lib
       - -I：指定头文件目录
            g++ test.cpp -o test -lmyhello -L../lib -I../head
     - -Wall: 允许发出gcc提供的所有有用的报警信息
     - -g:    产生带有调试信息的目标代码
        
#### makefile
1. 功能
   - 自动化编译，极大的提高了软件开发的效率。
   - makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令    
2. 规则
   - 如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。
   - 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。
   - 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序   
3. 格式
   - 执行：make
   - 执行指令：make 指令
   - 新旧：按照规则，依赖文件比目标文件新时就可以执行，旧的话就没必要执行
    ```
      目标XX1:依赖文件
      <TAB>命令1
      <TAB>命令2
      
      指令1：
         命令1
         命令2
    ```
4. 举例
   ```
   CC=g++
   OBJS=main.o tool1.o tool2.o
   EXE=main

   $(EXE):$(OBJS)
      $(CC) $^ -o $@
   %.o:%.cpp
      $(CC) -c $< -o $@

   .PHONY:clean print
   clean:
      rm -rf *.o main
   print:
	   @echo 编译器是:$(CC)
   ```
5. 变量定义
   - =，值取决于最后一次赋值
      ```
      buf = a
      name = $(name)
      buf = b
      //最后name的值为b
      ```
   - :=，值取决于当前的赋值
   - +=，变量追加，用空格隔开
6. 自动化变量
   - $@:目标集合
   - $^:依赖集合
   - $<:依赖集合中的第一个依赖,在有通配符号的情况下，等效于表示所有依赖的集合
   - $?:比目标新的依赖集合
7. %, *, $, @, ;, \, #
   - 匹配符%
     - 是匹配而不是通配
     - 例先要找test1.o的构造规则，看看Makefile中那个规则符合，发现%.o:%.c的规则匹配，于是先执行%.o:%.c
     - 先查找具体命令，查找不到再执行匹配符的命令。
     - 当需要编译一个文件夹下的所有.c文件时，必须先设置没有匹配符的目标
         ```
         all:$(subst .c,.o,$(wildcard *.c))
         
         %.o:%.c
            gcc -o $@ $<         
         ```
   - 通配符*
      *.c代表当前目录所有后缀为.c的文件集合
   - $
     - 变量引用：`$(name)`
     - 函数调用：`SRCS = $(wildcard *.cpp)`
     - shell命令:`SRCS = $(shell ls *.cpp`  
   - @
     避免回显，不再显示要被执行的命令
      `@echo $(name)`
   - ;
     - 每行命令都是在一个独立的子shell进程中被允许。如果不同的命令要在个子shell中执行
     - 在同一行书写，用 ; 隔开
     - 在不同行书写，以 \ 结尾
     - 例
      ```
      print:
         cd ../;\
         pwd      
      ```
   - `#`
      用于注释
8. 伪目标
   - 格式
      ```
      .PHONY:clean print
      clean:
         rm -rf *.o main      
      ```
   - 原因
      没有标注为伪目标时，会将clean作为目标文件来使用，这样如果当前目录已经有clean文件，而clean后又无依赖，会报出clean是最新文件，导致下面的命令无法执行。设置为伪目标时可以避免这种情况
9.  常用函数
   - $(wildcard 寻找的文件)
   - $(subst 要被替换的字符串,用来替换的字符串,被处理的字符串)
      `all:$(subst .c,.o,$(wildcard *.c))`
   - $(patsubst <pattern>, <replacement>, <text>)模式匹配字符串替换
      `$(patsubst %.c, %.o, $(wildcard *.c))`
   - $(basename 文件名)取文件名
      `$(basename a.c)`得到a
   - $(dir <name...>)取目录
      `$(dir </src/a.c>)`得到/src
   - $(notdir <name...>)
      `$(notdir <src/a.c>)`得到a.c
   - foreach：完成循环
      ```
      $(foreach <var>, <list>, <text>)
      SRCDIRS       := dira dirb dirc 
      $(foreach dir, $(SRCDIRS), $(wildcard $(dir) / *.c))      
      ```

#### gdb

#### shell

#### git
1. 工作流程
   - 克隆 Git 资源作为工作目录。
   - 在克隆的资源上添加或修改文件。
   - 如果其他人修改了，你可以更新资源。
   - 在提交前查看修改。
   - 提交修改。
   - 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。
2. 基本概念
   - 工作区:即当前目录
   - 暂存区：.git/index
   - 版本库：.git
   - 本地仓库，远程仓库
3. 基本操作
   - 创建仓库
      git init
   - 拷贝远程仓库(也是创建)
      git remote add origin https://github.com/Freeeeeeedman/hello-world
   - 配置
      git config --list
      git config --global user.name "freedman1984"
      git config --global user.email "freedman1984@hotmail.com"
   - 提交与修改
     - git add
         添加文件到暂存区
     - git status
         查看仓库当前的状态，显示有变更的文件
         缩略-s
     - git diff
         - git diff [file]:显示暂存区和工作区的差异
         - git diff --cached [file]:显示暂存区和上一次提交(commit)的差异
         - git diff [first-branch]...[second-branch]:显示两次提交之间的差异
     - git commit
         - git commit [file] -m "message"
         - git commit -a:修改文件后不需要执行 git add 命令，直接提交
     - git rm
         - git rm <file>:将文件从暂存区和工作区中删除
         - git rm --cached <file>:从跟踪清单中删除,但仍保留在当前工作目录中
     - git mv
         git mv [file] [newfile]:移动或重命名一个文件、目录或软连接
   - 查看提交历史
     - git log --oneline:查看历史记录的简洁的版本
     - git log --graph:查看版本记录的图形
   - 回退版本 
     - git reset --mixed
            
     - git reset --soft
     - git reset --hard
#### vim
1. 正常模式
   - 默认模式，两下ESC进入
   - 移动光标
      首行：gg，末行：G
      翻屏：ctrl + u （up），ctrl + d （down）
   - 复制/粘贴
      5yy, p, P
   - 剪切/删除
      删除行5dd+p, dd, D(清空)
      删除字符：x, nx, X
   - 撤销与恢复
      u, ctrl+r
2. 命令模式
   - 正常模式下，:进入
   - 保存，退出
      :w, :wq
   - 查找
      /word 光标之后查找字符串word，按n向后搜索，按N向前搜索
      ?word光标之前查找字符串word，按n向前搜索，按N向前搜索
   - 替换
      :s/要替换的关键词/替换后的关键词
      :s/要替换的关键词/替换后的关键词/g
      :%s/要替换的关键词/替换后的关键词
      :%s/要替换的关键词/替换后的关键词/g
   - 显示行号
     :set nu， 取消行号:set nonu
3. 插入模式
   - 正常模式下，i, a进入
   - i 在光标所在字符前开始输入文字并进入插入模式。
   - I 在行首开始输入文字并进入插入模式。此行首指第一个非空白字符处。如果行首有空格，则在空格之后输入文字并进入插入模式
   - a 在光标所在字符后开始输入文字并进入插入模式
   - A 在行尾开始输入文字并进入插入模式。这个好用，您不必管光标在此行的什麽地方，只要按 A 就会在行尾等着您输入文字。
   - o 在光标所在行的下面单独开一新行，来输入文字并进入插入模式
   - O 在光标所在行的上面单独开一新行来输入文字并进入插入模式
4. 可视模式
   - 正常模式下，ctrl + v（可视列）或V（可视行）或v（可视）
   - 其他操作同正常模式
   - 添加#多行注释
     - 按Esc退出到命令模式，按gg切换到第1行
     - 然后按Ctrl+v进入到可视列模式
     - 在行首使用上下键选择需要注释的多行
     - 按下键盘（大写）“I”键，进入插入模式（Shift + i）
     - 输入#号注释符
   - 去除#多行注释（!）
     - 按Esc退出到命令模式，按gg切换到第1行
     - 然后按Ctrl+v进入可视化区块模式（列模式）
     - 使用键盘上的方向键的上下选中需要移除的#号注释



