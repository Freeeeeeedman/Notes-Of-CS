
#### gcc
1. GCC
   - GCC(GNU Compiler Collection)即GNU编译器套件，属于一种编程语言编译器
   - 其原名为GCC（GNU C Compiler）即GNU c语言编译器，虽然缩写一样但是功能上区别很大。
   - GCC的初衷是为GNU操作系统专门编写的一款编译器，原本的GNU是专用于编译C代码，现如今已扩展为可以编译C、C++、Java、Objective-C等多种编程语言的编译器集合了
2. GCC、gcc、g++三者关系
   - gcc（GNU C Compiler）是GCC中的c编译器，而g++（GNU C++ Compiler）是GCC中的c++编译器。
   - gcc和g++两者都可以编译c和cpp文件，但存在差异。
     - gcc在编译cpp时语法按照c来编译但默认不能链接到c++的库导致会在编译和链接阶段报错。
     - g++编译.c和.cpp文件都统一按cpp的语法规则来编译,编译.c时调用gcc，所以不会报错
   - 所以一般编译c用gcc，编译c++用g++
3. gcc和g++编译选项
   - 一般流程
     - 预处理: g++ -E test.cpp -o test.i(预处理代码)
     - 编译: g++ -S test.i -o test.s(汇编代码)
     - 汇编: g++ -c test.s -o test.o(二进制机器码)
     - 链接: g++ test.o -o test(可执行文件)
   - 动态链接与静态链接
     - 动态链接: 为默认情况g++ test.cpp -o test 
     - 静态链接: g++ -static test.cpp -o test1, test1会比test大很多
   - 静态库与动态库创建
     - 注意在包含有多个源文件的情况下，编译时需要将源文件也加上
         g++ test.cpp hello.cpp -o test
     - 静态库
       - 先汇编：g++ hello.cpp -o hello.o
       - 再打包：ar -crv libmyhello.a hello.o
       - 最后链接：g++ test.cpp libmyhello.a -o test
       - ar打包命令
         - -c：新建打包文件
         - -r：替换归档中已有的文件或加入新文件
         - -v：显示运行的完整信息
         - -t：显示归档文件的内容
         - -x：从归档文件中解压文件，利用选项-o可以指定解压的文件
               ar -x libfunc.a -o add.o
     - 动态库
       - 先汇编：g++ hello.cpp -o hello.o
       - 创建动态库：g++ -fpic -shared hello.cpp -o ../lib/libhello.so
       - 动态链接：g++ test.cpp ../lib/libhello.so -o ../bin/test1
       - 查看依赖关系:ldd test1
       - 目录树：
         - 源文件src：*.cpp, *.h, *.o
         - 库文件lib: *.so, *.a
         - 可执行文件bin:*
   - 额外选项
     - 路径
       - -l:指定库文件
       - -L：指定库文件目录
            g++ test.cpp -o test -lmyhello -L../lib
       - -I：指定头文件目录
            g++ test.cpp -o test -lmyhello -L../lib -I../head
     - -Wall: 允许发出gcc提供的所有有用的报警信息
     - -g:    产生带有调试信息的目标代码
        
#### makefile
1. 功能
   - 自动化编译，极大的提高了软件开发的效率。
   - makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令    
2. 规则
   - 如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。
   - 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。
   - 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序   
3. 格式
   - 执行：make
   - 执行指令：make 指令
   - 新旧：按照规则，依赖文件比目标文件新时就可以执行，旧的话就没必要执行
    ```
      目标XX1:依赖文件
      <TAB>命令1
      <TAB>命令2
      
      指令1：
         命令1
         命令2
    ```
4. 举例
   ```
   CC=g++
   OBJS=main.o tool1.o tool2.o
   EXE=main

   $(EXE):$(OBJS)
      $(CC) $^ -o $@
   %.o:%.cpp
      $(CC) -c $< -o $@

   .PHONY:clean print
   clean:
      rm -rf *.o main
   print:
	   @echo 编译器是:$(CC)
   ```
5. 变量定义
   - =，值取决于最后一次赋值
      ```
      buf = a
      name = $(name)
      buf = b
      //最后name的值为b
      ```
   - :=，值取决于当前的赋值
   - +=，变量追加，用空格隔开
6. 自动化变量
   - $@:目标集合
   - $^:依赖集合
   - $<:依赖集合中的第一个依赖,在有匹配符%的情况下，等效于表示所有依赖的集合
   - $?:比目标新的依赖集合
7. %, *, $, @, ;, \, #
   - 匹配符%
     - 是匹配而不是通配
     - 例先要找test1.o的构造规则，看看Makefile中那个规则符合，发现%.o:%.c的规则匹配，于是先执行%.o:%.c
     - 先查找具体命令，查找不到再执行匹配符的命令。
     - 当需要编译一个文件夹下的所有.c文件时，必须先设置没有匹配符的目标
         ```
         all:$(subst .c,.o,$(wildcard *.c))
         
         %.o:%.c
            gcc -o $@ $<         
         ```
   - 通配符*
      *.c代表当前目录所有后缀为.c的文件集合
   - $
     - 变量引用：`$(name)`
     - 函数调用：`SRCS = $(wildcard *.cpp)`
     - shell命令:`SRCS = $(shell ls *.cpp`  
   - @
     避免回显，不再显示要被执行的命令
      `@echo $(name)`
   - ;
     - 每行命令都是在一个独立的子shell进程中被允许。如果不同的命令要在个子shell中执行
     - 在同一行书写，用 ; 隔开
     - 在不同行书写，以 \ 结尾
     - 例
      ```
      print:
         cd ../;\
         pwd      
      ```
   - `#`
      用于注释
8. 伪目标
   - 格式
      ```
      .PHONY:clean print
      clean:
         rm -rf *.o main      
      ```
   - 原因
      没有标注为伪目标时，会将clean作为目标文件来使用，这样如果当前目录已经有clean文件，而clean后又无依赖，会报出clean是最新文件，导致下面的命令无法执行。设置为伪目标时可以避免这种情况
9.  常用函数
   - \$(wildcard 寻找的文件)
   - \$(subst 要被替换的字符串,用来替换的字符串,被处理的字符串)
      `all:$(subst .c,.o,$(wildcard *.c))`
   - \$(patsubst <pattern>, <replacement>, <text>)模式匹配字符串替换
      `$(patsubst %.c, %.o, $(wildcard *.c))`
   - \$(basename 文件名)取文件名
      `$(basename a.c)`得到a
   - \$(dir <name...>)取目录
      `$(dir </src/a.c>)`得到/src
   - \$(notdir <name...>)
      `$(notdir <src/a.c>)`得到a.c
   - foreach：完成循环
      ```
      $(foreach <var>, <list>, <text>)
      SRCDIRS := dira dirb dirc 
      $(foreach dir, $(SRCDIRS), $(wildcard $(dir) / *.c))      
      ```

#### gdb

#### shell

#### git
1. 简介
   git是版本控制系统，特点是支持分支管理与版本回退。
2. 工作流程
   - 克隆 Git 资源作为工作目录。
   - 在克隆的资源上添加或修改文件。
   - 如果其他人修改了，你可以更新资源。
   - 在提交前查看修改。
   - 提交修改。
   - 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。
3. 基本概念
   - 工作区:即当前目录
   - 暂存区：.git/index
   - 版本库：.git
   - 本地仓库，远程仓库
4. 基本操作
   - 创建仓库
      git init
   - 拷贝远程仓库(也是创建)
      git clone https://github.com/Freeeeeeedman/hello-world
   - 配置
      git config --list
      git config --global user.name "freedman1984"
      git config --global user.email "freedman1984@hotmail.com"
   - 提交与修改
     - git add
         添加文件到暂存区
     - git status
         查看仓库当前的状态，显示有变更的文件
         缩略-s
     - git diff
         - git diff [file]:显示暂存区和工作区的差异
         - git diff --cached [file]:显示暂存区和上一次提交(commit)的差异
         - git diff [first-branch]...[second-branch]:显示两次提交之间的差异
     - git commit
         - git commit [file] -m "message"
         - git commit -a:修改文件后不需要执行 git add 命令，直接提交
     - git rm
         - git rm <file>:将文件从暂存区和工作区中删除
         - git rm --cached <file>:从跟踪清单中删除,但仍保留在当前工作目录中
     - git mv
         git mv [file] [newfile]:移动或重命名一个文件、目录或软连接
   - 查看提交历史
     - git log --oneline:查看历史记录的简洁的版本
     - git log --graph:查看版本记录的图形
   - 回退版本 
     - git reset --mixed
       - 默认方式，等同于git reset
       - 重置HEAD和暂存区，保留工作区。修改内容还在，变成未add的状态。
     - git reset --soft
       - 重置HEAD，保留暂存区和工作区。修改内容还在，变成已add的状态。
     - git reset --hard（使用时一定要小心！）
       - 重置HEAD,暂存区和工作区。修改内容直接丢失，修改的代码不会变成未add的状态。
     - 回退多个版本
         git reset HEAD^^^
         git reset HEAD~3
5. 分支管理
   - 创建分支
      git branch (branchname)
   - 切换分支命令:
      git checkout (branchname)
   - 创建并切换分支
      git checkout -b (branchname) 
   - 删除分支
      git branch (branchname)
   - 合并分支
      git checkout master
      git pull origin master(多人开发时需要先拉取别人的更新)
      git merge test
      git push origin master(多人开发时提交到服务器)
   - 切换至历史版本
      git checkout [version ID]
   - 在历史版本基础上修改，创建分支
      git switch -c [branchname]
6. 变基
   - merge合并分支的方式
      三方合并。将两个分支的最新快照(C3, C4)和二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）
   - rebase变基合并分支的方式
      - 检出 experiment 分支，然后将它变基到 master 分支
         git checkout experiment
         git rebase master
      - 首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。即相当于在C3上又进行了C4的操作。最终experiment和master都指向C4'
   - 用途
      变基使得提交历史更加整洁。确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先**在自己的分支里进行开发**，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。
   - 风险
      - 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。
      - 因为变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。当别人进行合并提交后，我们git pull合并了，然后别人再回滚改为变基，会多出来内容相同但是实际不同的提交，而我们如此再次git pull会合并两次相同内容的提交。并且导致由于变基丢失的提交又回来了，使得整个历史非常混乱。
7. 标签
   - 创建带注解的标签
      git tag -a v1.0 -m ''
   - 追加标签
      git tag -a v0.9 85fc7e7
   - 查看所有标签
      git tag
   - 查看此版本所修改的内容
      git show v1.0
   - 删除标签
      git tag -d v1.1
8. 远程仓库
   - 创建远程仓库
      - 直接clone
         git clone https://github.com/Freeeeeeedman/hello-world
      - 创建本地仓库再添加远程库
         git init
         git remote add origin https://github.com/Freeeeeeedman/hello-world
         git pull
      - 注意一般一个本地仓库连接一个远程仓库，当有时候需要提交到多个远程仓库时，也可以连接到多个远程仓库
   - 添加仓库
      - git remote -v 显示所有远程仓库
      - git remote show [remote] 显示某个远程仓库的信息   
      - git remote add [shortname] [url] 添加远程版本库
      - git remote rm name 删除远程仓库
      - git remote rename old_name new_name 修改仓库名
   - 拉取更新
     - git fetch <远程主机名> 将某个远程主机的更新全部取回本地
     - git fetch <远程主机名> <分支名> 取回特定分支的更新
     - git log -p FETCH_HEAD 
     - 最终要将拉取的更新合并到当前本地分支
         git merge FETCH_HEAD
     - git fetch remote_repo remote_branch_name:local_branch_name 
         这将更新名称为remote_repo 的远程repo上的分支： remote_branch_name ，并在本地创建local_branch_name 本地分支保存远端分支的所有数据。
   - 拉取更新并合并到本地
     - git pull <远程主机名> <远程分支名>:<本地分支名>
     - 如果远程分支是与当前分支合并，则冒号后面的部分可以省略
   - 推送更新到远程仓库
     - git push <远程主机名> <本地分支名>:<远程分支名>
         git push origin master:main
     - 如果本地分支名与远程分支名相同，则可以省略冒号：git push <远程主机名> <本地分支名>
     - 强制推送(不建议使用！不可逆！)
        - 会直接用本地分支替换远程分支：git push --force origin master
        - 一般用于回退后再推送
            git reset --hard commit ID
            git push --force origin master
     - 删除主机分支
         git push origin --delete master

#### vim
1. 正常模式
   - 默认模式，两下ESC进入
   - 移动光标
      首行：gg，末行：G
      翻屏：ctrl + u （up），ctrl + d （down）
   - 复制/粘贴
      5yy, p, P
   - 剪切/删除
      删除行5dd+p, dd, D(清空)
      删除字符：x, nx, X
   - 撤销与恢复
      u, ctrl+r
2. 命令模式
   - 正常模式下，:进入
   - 保存，退出
      :w, :wq
   - 查找
      /word 光标之后查找字符串word，按n向后搜索，按N向前搜索
      ?word光标之前查找字符串word，按n向前搜索，按N向前搜索
   - 替换
      `:s/要替换的关键词/替换后的关键词`
      `:s/要替换的关键词/替换后的关键词/g`
      `:%s/要替换的关键词/替换后的关键词`
      `:%s/要替换的关键词/替换后的关键词/g`
   - 显示行号
     :set nu， 取消行号:set nonu
3. 插入模式
   - 正常模式下，i, a进入
   - i 在光标所在字符前开始输入文字并进入插入模式。
   - I 在行首开始输入文字并进入插入模式。此行首指第一个非空白字符处。如果行首有空格，则在空格之后输入文字并进入插入模式
   - a 在光标所在字符后开始输入文字并进入插入模式
   - A 在行尾开始输入文字并进入插入模式。这个好用，您不必管光标在此行的什麽地方，只要按 A 就会在行尾等着您输入文字。
   - o 在光标所在行的下面单独开一新行，来输入文字并进入插入模式
   - O 在光标所在行的上面单独开一新行来输入文字并进入插入模式
4. 可视模式
   - 正常模式下，ctrl + v（可视列）或V（可视行）或v（可视）
   - 其他操作同正常模式
   - 添加#多行注释
     - 按Esc退出到命令模式，按gg切换到第1行
     - 然后按Ctrl+v进入到可视列模式
     - 在行首使用上下键选择需要注释的多行
     - 按下键盘（大写）“I”键，进入插入模式（Shift + i）
     - 输入#号注释符
   - 去除#多行注释（!）
     - 按Esc退出到命令模式，按gg切换到第1行
     - 然后按Ctrl+v进入可视化区块模式（列模式）
     - 使用键盘上的方向键的上下选中需要移除的#号注释



