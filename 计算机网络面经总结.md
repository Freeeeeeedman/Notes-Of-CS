### 计算机网络面经总结


### 3. TCP
#### 3.1 TCP三次握⼿与四次挥⼿
#### 3.1.1 TCP基础
1. TCP头格式
   - 源端口号，端口号（16位）
   - 序列号（32）：⽤来解决⽹络包乱序问题
   - 确认应答号（32）：⽤来解决不丢包的问题
   - 控制位（6）：ACK,RST,SYN,FIN
   - 首部长度（4）：存在选项长度，所以TCP头部大小不确定要标注，4位最大位15，所以TCP头部最大为15 * 4 = 60字节，即选项长度最大为20字节
   - 紧急指针（16）：URG=1时有效，代表紧急数据的字节数。窗口为0也可以发送紧急数据
2. 为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？
   - IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。
   - TCP 是⼀个⼯作在传输层的可靠数据传输的服务，它能确保接收端接收的⽹络包是⽆损坏、⽆间隔、⾮冗余和按序的
3. 什么是 TCP ？
   - TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议
   - ⾯向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀对多是⽆法做到的
   - 可靠的：⽆论的⽹络链路中出现了怎样的链路变化， TCP 都可以保证⼀个报⽂⼀定能够到达接收端
   - 字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的报⽂会⾃动丢弃
4. 什么是 TCP 连接？
    ⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝⼤⼩称为连接
5. 如何唯⼀确定⼀个 TCP 连接？
    TCP 四元组可以唯⼀的确定⼀个连接：源地址，源端⼝，⽬的地址，⽬的端⼝
6. 有⼀个 IP 的服务器监听了⼀个端⼝，它的 TCP 的最⼤连接数是多少？
    最大TCP连接数 = 客户端IP数（32） X 客户端端口数（16） = 2 ^ 48
7. 为什么服务端最⼤并发 TCP 连接数远不能达到理论上限？
   - ⽂件描述符限制， Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬
   - 内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的
8. UDP头部格式（8字节）
   - 源端口号与目标端口号（16）
   - 包长度（16）
   - 校验和（16）
9. TCP 和 UDP 区别
   - 连接
       TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。
       UDP 是不需要连接，即刻传输数据。
   - 服务对象
        TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点
        UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信
   - 可靠性
        TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不重复、按需到达。
        UDP 是尽最⼤努⼒交付，不保证可靠交付数
   - 拥塞控制、流量控制
        TCP 有拥塞控制和流量控制机制，保证数据传输的安全性
        UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率
   - ⾸部开销
        TCP:不确定，无选项头部20字节，最大60字节
        UDP：确定，8字节
   - 传输⽅式
        TCP 是流式传输，没有边界，但保证顺序和可靠。
        UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序
   - 分⽚不同
        TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚[MSS（最大数据报文）+ 首部=数据包]
        UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。[以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).]
   - 应用场景不同
        TCP:⾯向连接，能保证数据的可靠性交付,FTP ⽂件传输, HTTP / HTTPS
        UDP:⾯向⽆连接，随时发送数据,简单高效：包总量较少的通信，如 DNS，视频、⾳频等多媒体通信⼴播通信 
10. TCP可靠性如何保证？
     校验和；确认应答与序列号；超时重传； 连接管理；流量控制、拥塞控制
12. 为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢？
    原因是 TCP 有可变⻓的「选项」字段，⽽ UDP 头部⻓度则是不会变化的，⽆需多⼀个字段去记录 UDP 的⾸部⻓度
13. 为什么 UDP 头部有「包⻓度」字段，⽽ TCP 头部则没有「包⻓度」字段呢？
    TCP数据的长度 = IP总长度（IP首部中） - IP首部长度（IP首部中） - TCP首部长度（TCP首部中）。UDP也可以这么算。真正原因是为了⽹络设备硬件设计和处理⽅便，⾸部⻓度需要是 4 字节的整数倍。
#### 3.1.2 TCP连接建⽴
1. TCP通过什么来建立连接？
    建⽴连接是通过三次握⼿来进⾏的
2. 说一说TCP的三次握手的过程（状态变迁）
   - 首先客户端和服务端都处在CLOSE状态，服务端开始监听端口，接着处于LISTEN状态
   - 然后客户端初始化报文的序列号，SYN标志位置为1，将SYN报文发送给服务端，接着处于SYN_SENT状态
   - 服务端收到SYN报文，初始化自己报文的序列号，确认应答号为收到的SYN报文序列号+1，SYN和ACK标志位置为1，将SYN+ACK报文发给客户端，接着处于SYN_RCVD状态
   - 客户端收到ACK+SYN报文，回应最后一个应答报文，将ACK标志位置为1，确认应答号为ACK+SYN报文的序列号+1，接受处于ESTABLISHED状态
   - 服务端接收到ACK报文，处于ESTABLISHED状态
3. 三次握手可以携带数据吗？
    第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的
4. 为什么第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的
      第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据
5. 如何在 Linux 系统中查看 TCP 状态？
     netstat -napt 命令
6. 为什么是三次握⼿？不是两次握手？
   - ⾸要原因是为了防⽌历史连接初始化了连接
     -  客户端连续发送多次 SYN 建⽴连接的报⽂，在⽹络拥堵情况下：⼀个「旧 SYN 报⽂」⽐「最新的 SYN 」 报⽂早到达了服务端；那么此时服务端就会回⼀个 SYN + ACK 报⽂给客户端；客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送RST 报⽂给服务端，表示中⽌这⼀次连接。而如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双⽅就会成功建⽴连接；
   - 同步双⽅初始序列号
      - 接收⽅可以去除重复的数据；接收⽅可以根据数据包的序列号按序接收；可以标识发送出去的数据包中， 哪些是已经被对⽅收到的；
      - ⼀来⼀回，才能确保双⽅的初始序列号能被可靠的同步
   - 避免资源浪费
        如果客户端的 SYN 阻塞了，重复发送多次 SYN 报⽂，那么服务器在收到请求后就会建⽴多个冗余的⽆效链接，造成不必要的资源浪费
7. 为什么是三次握⼿？不是四次握手？
    三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数
8. 为什么客户端和服务端的初始序列号 ISN 是随机的？
   - 将不属于本连接的报⽂段丢弃，防止旧连接重用后的历史报文
   - 为了安全性，防⽌⿊客伪造的相同序列号的 TCP 报⽂被对⽅接收
9. 初始序列号 ISN 是如何随机产⽣的？
    随机算法：ISN = M（计时器） + F (哈希算法源 IP、⽬的 IP、源端⼝、⽬的端⼝⽣成⼀个随机数值)
10. 既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？
    IP没有超时重传机制。网络包大于MTU时，IP层就要分片。但如果⼀个 IP 分⽚丢失，整个 IP 报⽂的所有分⽚都得重传。 而TCP负责超时和重传，当接收⽅发现 TCP 报⽂的某一片丢失后，则不会响应 ACK，那么发送⽅的 TCP 在超时后，就会重发整个 TCP 报⽂。建⽴连接的时候通常要协商双⽅的 MSS 值，小于MTU，那么就不用IP分片了。经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后， 进⾏重发时也是以 MSS 为单位，⽽不⽤重传所有的分⽚，⼤⼤增加了重传的效率。
11. 什么是 SYN 攻击？
    客户端发送多个SYN报文，不应达服务端的ACK+SYN报文。会导致服务端处于SYN_REVC的状态的连接增多即SYN半连接队列占满，不能接受新连接。
12. 如何避免 SYN 攻击？
    - 修改 Linux 内核参数，设置半连接队列溢出时，直接回复RST报文丢弃连接
    - 打开tcp_syncookies
    - 减少 SYN+ACK 重传次数，加快处于 SYN_REVC 状态的 TCP 连接断开
#### 3.1.2 TCP 连接断开
1. TCP通过什么断开连接？
    TCP 断开连接是通过四次挥⼿⽅式
2. 说一说TCP四次挥手
   - 先是客户端和服务端都处于ESTABLISH状态。如果是客户端准备关闭连接，则发送FIN标志位为1的FIN报文，进入FIN_WAIT1状态
   - 服务端收到FIN报文，回复ACK报文，进入CLOSED_WAIR状态
   - 客户端收到ACK报文，进入TIME_WAIT2状态
   - 服务端处理完数据后发送FIN报文，进入LAST_ACK状态
   - 客户端收到FIN报文，回复ACK，进入TIME_WAIT状态
   - 服务端收到ACK报文，进入CLOSED状态
   - 客户端在经过2MSL后，进入CLOSED状态，连接关闭
3. 发送FIN报文表示什么
    不能发送数据，但还可以接受数据
4. 为什么挥⼿需要四次？
    因为服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次
5. 为什么需要 TIME_WAIT 状态（TIME_WAIT时间过短会怎么样）？
   - 防⽌旧连接的数据包
        旧的TCP连接被复用后，客户端可能正常接受旧数据，导致数据错乱。经过 2MSL 这个时间， ⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的
   - 保证双方连接正确关闭
        等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭。最后一次挥手ACK报文丢失，如果TIME_WAIT状态过短，那么服务端会一直处在LAST_ACK状态。那么当客户端发起新的SYN报文，会导致服务端回复RST报文，新的连接不能建立。而如果TIME_WAIT时间够长，那么当ACK丢失时，服务端会重发FIN报文并等待新的ACK报文。
6. 为什么 TIME_WAIT 等待的时间是 2MSL？
    MSL是报⽂最⼤⽣存时间。从发送方发送报文到接收方回复的报文再被发送方收到要2MSL。这样经过2MSL，TIME_WAIT前的发送的报文基本都会消失。
7. 报文如何消失？
    IP投中TTL 字段，是 IP 数据报可以经过的最⼤路由数，经过一路由即减一。一般 MSL 应该要⼤于等于 TTL 消耗为 0 的时间，以确保报⽂已被⾃然消亡。
8. 如果已经建⽴了连接，但是客户端突然出现故障了怎么办？
    TCP 有保活机制。定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动，每隔⼀个时间间隔，发送⼀个探测报⽂，如果连续⼏个探测报⽂都没有得到响应，则认为当前的TCP 连接已经死亡，即对方程序崩溃。如果对方回复RST报文，说明TCP连接已重置，即对方的程序崩溃并重启。

#### 3.1.3 Socket 编程
1. 说一说针对 TCP 应该如何 Socket 编程？
    服务端和客户端初始化 socket ，得到⽂件描述符；
    服务端调⽤ bind ，将绑定在 IP 地址和端⼝;
    服务端调⽤ listen ，进⾏监听；
    服务端调⽤ accept ，等待客户端连接；
    客户端调⽤ connect ，向服务器端的地址和端⼝发起连接请求；
    服务端 accept 返回⽤于传输的 socket 的⽂件描述符；
    客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据；
    客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完
    数据后，服务端调⽤ close ，表示连接关闭    
2. socket编程中，三次握手分别对应于哪个阶段
    客户端调用connect主动连接，第一次握手发送SYN报文,收到第二次握手的ACK报文后，connect返回。当第三次握手完成后，服务端accept返回，取出已完成连接的socket。connect和accept都是阻塞的。
3. listen 时候参数 backlog 的意义？
    int listen (int socketfd, int backlog)，accpet 全连接队列⻓度 = min(backlog, somaxconn)
4. 客户端调⽤ close 了，连接断开的流程是什么？
    四次挥手过程。同时两端在发送FIN报文时，会在其中插入文件结束符EOF到末尾，这样双方的应用程序在读到EOF时就知道对方不再发送数据。
5. 四次挥手时如果如果客户端第四次挥⼿ack丢失，服务端超时重发的fin报⽂也丢失，客户端timewait时间超过了2msl，这个时候会发⽣什么？
    当客户端 timewait 时间超过了 2MSL，则客户端就直接进⼊关闭状态。服务端超时重发 fin 报⽂的次数如果超过 tcp_orphan_retries ⼤⼩后，服务端也会关闭 TCP 连接。
6. TCP报文被在IP层MTU分片与在传输层MSS分片有什么区别？
    如果⼀个⼤的 TCP 报⽂是被 MTU 分⽚，那么只有「第⼀个分⽚」才具有 TCP 头部，后⾯的分⽚则没有TCP 头部。如果丢失了其中⼀个分⽚，那么就会等待对⽅超时重传这⼀整个 TCP 报⽂
    如果⼀个⼤的 TCP 报⽂被 MSS 分⽚，那么所有「分⽚都具有 TCP 头部」。如果其中⼀个 MSS 分⽚丢失，发送方没收到对应的ACK，会触发超时重传，就只需要重传这⼀个分⽚就可以。
7. 为什么TCP报文MTU分片丢失要整个重传？而与在传输层MSS分片丢失只需要重传其中一片？
    因为 MTU 分⽚，那么只有「第⼀个分⽚」才具有 TCP 头部，接收⽅ IP 层只有重组了这些分⽚，才会认为是⼀个 TCP 报⽂。而 MSS 分⽚，那么所有「分⽚都具有 TCP 头部」。

### 3.2  TCP 重传、滑动窗⼝、流量控制、拥塞控制
#### 3.2.1 TCP重传机制
1. TCP在哪些情况下会触发超时重传？
   - 发送方数据包丢失
   - 接收方确认应答丢
2. 超时时间应该设置为多少呢？
    超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值
3. 超时重传时间过大或过小会导致什么情况？
    过大，重发慢，效率低
    过小，重发快，可能包没有丢失就重发，增加⽹络拥塞，导致更多的超时，更多的超时导致更多的重
4. 如何计算超时重传时间？
    ⽹络时常变化，导致RTT也动态变化，进而导致RTO也动态变化。通过采用和统计RTT来计算RTO
5. 多少超时重传会发生什么？   
    超时间隔加倍。达到最大重传次数断开连接。
6. 超时重传缺点是什么？如何改进？
    超时周期可能相对较⻓。利用快速重传机制。
7. 说一说快速重传机制
    快速重传机制，它不以时间为驱动，⽽是以数据驱动重传。当发送方丢失了一段数据报文，接收方在收到之后的报文时，会连续发生三个相同的 ACK 报⽂时，提醒发送方重传丢失的报⽂段
8. 快速重传机制的缺点是什么？
    有可能连续丢失了几个报文，重传的时候，是重传之前的⼀个丢失的报文，还是重传之前所有的报文。
9. 如何改进快速重传？
    SACK选择性确认机制。TCP 头部「选项」字段⾥添加SACK，可以将缓存的地图发送给发送⽅，这样发送⽅就可以知道哪些数据收到了，哪些数据没收到，就可以只重传丢失的数据
10. TCP如果发送方丢失了一段数据会发生什么？
    TCP传输数据时是批量发送的，但只会回复ack为最后一段数据的序列号+1的ACK确认报文。如果丢失了一些数据，会触发快速重传和SACK选择性确认机制。同时回复已接受到的数据范围以及三次丢失的数据对应的ACK报文。
11. TCP如果传输数据时，接收方应答报文丢失会发生什么？
    首先触发超时重传机制。再触发D-SACK机制。当接收方收到重复的数据时，会向发送方发送有SACK字段的报文，提醒发送方哪些数据是已经被接受的。注意TCP三次握手和四次挥手报文丢失时只会触发超时重传。
12. TCP如果传输数据时，有网络延迟会发生什么？
    有网络延迟会导致发送方的部分数据包没有被接受。进而触发快速重传和SACK选择性确认机制。发送方重传后，被延迟的数据包又到达了接收方。这时接收方会回复对应的重复的数据的SACK即DACK提醒发送方已接受被延迟的数据
13. DACK的功能
    可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了;
    可以知道是不是「发送⽅」的数据包被⽹络延迟了;
    可以知道⽹络中是不是把「发送⽅」的数据包给复制了
#### 3.4 半连接和全连接队列

1. 什么是TCP半连接队列和全连接队列？
    第一次握手,服务端收到客户端发起的 SYN 请求后， 内核会把该连接存储到半连接队列.第三次握⼿,服务端收到 ACK 后， 内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。

2. 如何知道应⽤程序的 TCP 全连接队列⼤⼩？
    ss -lnt ,Recv-Q：当前全连接队列的⼤⼩,Send-Q：当前全连接最⼤队列⻓度，⾮ LISTEN 状态分别为已收到但未被应⽤进程读取的字节数,已发送但未收到确认的字节数

3. 如何模拟 TCP 全连接队列溢出的场景？
    wrk, HTTP 压测

4. TCP全连接队列溢出后会发生什么?
    默认⾏为tcp_abort_on_overflow = 0,服务器扔掉客户端发过来的ack.也可以设置tcp_abort_on_overflow = 1表示server发送⼀个reset复位报文给 client，表示废掉这个握⼿过程和这个连接.可以通过netstat -s | grep overflowed查看丢弃的连接数

5. tcp_abort_on_overflow为什么默认设置为0
    这样更有利于应对突发流量,提⾼连接建⽴的成功率.因为此时客户端连接状态为ESTABLISHED,只要服务器没有为请求回复 ACK，请求就会被多次重发.如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报⽂由于含有 ACK，仍然会触发服务器端成功建⽴连接。只有当TCP 全连接队列会⻓期溢出时，才能设置为 1 以尽快通知客户端

6. 如何增⼤ TCP 全连接队列呢?
    TCP 全连接队列的最⼤值sk_max_ack_backlog取决于 somaxconn(128) 和 backlog(511) 之间的最⼩值

7. 如何查看 TCP 半连接队列⻓度？
    服务端处于 SYN_RECV 状态的 TCP 连接数目，就是 TCP 半连接队列数目. nestat | grep SYN_RECV | wc -l

8. 如何模拟 TCP 半连接队列溢出场景？
    hping3 ⼯具模拟 SYN 攻击, 并关闭 tcp_syncookies。对服务端⼀直发送 TCP SYN 包，但是不回第三次握⼿ ACK。又称 SYN 洪泛、 SYN 攻击、 DDos 攻击。

9. TCP 半连接队列的最⼤值是如何决定的？
    - 半连接队列的⼤⼩并不单单只跟 tcp_max_syn_backlog(512)有关。当 max_syn_backlog > min(somaxconn, backlog) 时， 半连接队列最⼤值 max_qlen_log = min(somaxconn,backlog) * 2;当 max_syn_backlog < min(somaxconn, backlog) 时， 半连接队列最⼤值 max_qlen_log =max_syn_backlog * 2;
    - 每个 Linux 内核版本「理论」半连接最⼤值计算⽅式会不同
      在 Linux 5.0.0 的时候，「理论」半连接最⼤值就是全连接队列最⼤值

10. 第一次握手SYN因队列长度被丢弃的条件
    - 如果半连接队列满了，并且没有开启 tcp_syncookies，则会丢弃；
    - 若全连接队列满了，且没有重传 SYN+ACK 包的连接请求多于 1 个，则会丢弃；
    - 如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列⻓度⼩于(max_syn_backlog >> 2)，则会丢弃；


11. 半连接队列最⼤值max_qlen_log 就表示服务端处于 SYN_REVC 状态的最⼤个数吗？
    不一定。如果「当前半连接队列」 没超过「理论半连接队列最⼤值」，但是超过 max_syn_backlog - (max_syn_backlog >> 2)，那么处于 SYN_RECV 状态的最⼤个数就是 max_syn_backlog - (max_syn_backlog >> 2)；如果「当前半连接队列」 超过「理论半连接队列最⼤值」，那么处于 SYN_RECV 状态的最⼤个数就是「理论半连接队列最⼤值」；

12. 如果 SYN 半连接队列已满，只能丢弃连接吗？
      开启 syncookies 功能就可以在不使⽤ SYN 半连接队列的情况下成功建⽴连接。服务器根据当前状态计算出⼀个值，放在⼰⽅发出的 SYN+ACK 报⽂中发出，当客户端返回 ACK 报⽂时，取出该值验证，如果合法，就认为连接建⽴成功
13. 如何查看由于 SYN 半连接队列已满，⽽被丢弃连接的情况？
        netstat -s  | grep
14. SYN半连接满了怎么办？（如何防御 SYN/DDOS 攻击？）
    - 增⼤半连接队列
        想增⼤半连接队列，我们得知不能只单纯增⼤ tcp_max_syn_backlog 的值，还需⼀同增⼤ somaxconn 和 backlog，也就是增⼤全连接队列
    - 开启 tcp_syncookies 功能
    - 减少 SYN+ACK 重传次数
         SYN_REVC 状态的 TCP 连接会重传SYN+ACK ，当重传超过次数达到上限后，就会断开连接

15. TCP 内核参数在哪？
     在/proc/sys/net/ipv4/tcp*

#### 3.5 TCP性能提升策略
#### 3.5.1 三次握⼿的性能提升
1. 客户端优化
     - 优化SYN_SENT状态的SYN超时重传次数。重发的次数由 tcp_syn_retries 参数控制，默认是 5 次，每次超时的时间是上⼀次的 2 倍。怎么调整同下。
2. 服务端优化
     - 优化SYN_RCV 状态的 SYN+ACK 报⽂重传。当⽹络繁忙、不稳定时，报⽂丢失就会变严重，此时应该调⼤重发次数。反之则可以调⼩重发次数。 修改重发次数的⽅法是，调整 tcp_synack_retries 参数
     - 调整SYN半连接队列长度
     - 调整accept全连接队列长度
3.  绕过三次握手
   - 三次握⼿建⽴连接造成的后果是， HTTP 请求必须在⼀个 RTT（从客户端到服务器⼀个往返的时间）后才能发送。
   - 开启 TCP Fast Open 功能，这个功能可以减少 TCP 连接建⽴的时延
4. TCP Fast Open 功能的⼯作⽅式是什么？
   - 第⼀次发起 HTTP GET 请求的时候，还是需要正常的三次握⼿流程。客户端发送 SYN 报⽂，该报⽂包含 Fast Open 选项。⽀持 TCP Fast Open 的服务器⽣成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。
   - 客户端发送 SYN 报⽂，该报⽂包含「数据」以及此前记录的 Cookie；服务器会对收到 Cookie 进⾏校验：如果 Cookie 有效，服务器将在 SYN-ACK 报⽂中对 SYN 和「数据」进⾏确认。如果 Cookie ⽆效，服务器将丢弃 SYN 报⽂中包含的「数据」，且其随后发出的 SYN-ACK 报⽂将只确认 SYN 的对应序列号。如果服务器接受了 SYN 报⽂中的「数据」，服务器可在握⼿完成之前发送「数据」， 这就减少了握⼿带来的1 个 RTT 的时间消耗； 
5. 如果TCP Fast Open的SYN的数据没有被确认会怎样？
    客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报⽂中发送的「数据」没有被确认，则客户端将重新发送「数据」；
6. TFOCookie存放在哪？
    cookie 的值是存放到 TCP option 字段
7. Linux 下怎么打开 TCP Fast Open 功能呢？
    在 Linux 系统中，可以通过设置 tcp_fastopn 内核参数，来打开 Fast Open 功能。

#### 3.5.2 TCP 四次挥⼿的性能提升
1. TCP关闭连接的方式有哪几种？
    RST 报⽂关闭和 FIN 报⽂关闭。如果进程异常退出了，内核就会发送 RST 报⽂来关闭，不⾛四次挥⼿流程而暴⼒关闭连接。安全关闭连接的⽅式必须通过四次挥⼿，它由进程调⽤ close 和 shutdown 函数发起 FIN 报⽂。
2. 调⽤ close 函数和 shutdown 函数有什么区别？
   - 调⽤了 close 函数意味着完全断开连接， 完全断开不仅指⽆法传输数据，⽽且也不能发送数据。 此时，调⽤了close 函数的⼀⽅的连接叫做「孤⼉连接」
   -  shutdown 函数， 它可以控制只关闭⼀个⽅向的连接
      -  SHUT_RD(0)关闭连接的「读」这个⽅向，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进⾏ ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。
      -  关闭连接的「写」这个⽅向，这就是常被称为「半关闭」的连接。如果发送缓冲区还有未发送的数据，将被⽴即发送出去，并发送⼀个 FIN 报⽂给对端。
3. 如果遇到恶意攻击， FIN 报⽂根本⽆法发送出去怎么办？
   - ⾸先TCP 必须保证报⽂是有序发送的，当发送缓冲区还有数据没有发送时， FIN 报⽂不能提前发送
   - 其次， TCP 有流量控制功能，当接收⽅接收窗⼝为 0 时，发送⽅就不能再发送数据。所以，当攻击者下载⼤⽂件时，就可以通过接收窗⼝设为 0 ，这就会使得 FIN 报⽂都⽆法发送出去，那么连接会⼀直处于FIN_WAIT1 状态也不能提前发送。
   - 调整 tcp_max_orphans 参数，它定义了「孤⼉连接」的最⼤数量,如果孤⼉连接数量⼤于它，新增的孤⼉连接将不再⾛四次挥⼿，⽽是直接发送 RST 复位报⽂强制关闭。
4. 哪几种情况发送RST报文强制关闭连接
   进程异常退出时和孤儿连接超量时
5. 为什么FIN_WAIT2和 TIME_WAIT默认都要保持 2MSL（60s） 时⻓？
        因为这两个状态都需要保持 2MSL 时⻓，这样当, FIN(FIN_WAIT2)， ACK(TIME_WAIT)丢失时，被动方重发的报文会在第二个MSL内到达，保证连接正常关闭
6. 为什么不是4或者8MSL？
        这意味连续两次丢包，对于丢包率达到百分之⼀的糟糕⽹络，连续两次丢包的概率只有万分之⼀，这个概率实在是太⼩了，忽略它⽐解决它更具性价比
7. TIME_WAIT状态过多会怎样？
   - 如果是客户端，由于客户端 TIME_WAIT 过多，就会导致端⼝资源被占⽤，⽆法创建新连接
   - 如果是服务端，会导致系统资源被占满，⽆法创建新连接
8. 主动方优化
   - 降低主动方FIN重传次数
        主动发起 FIN 报⽂断开连接的⼀⽅，如果迟迟没收到对⽅的 ACK 回复，则会重传 FIN 报⽂，重传的次数由tcp_orphan_retries 参数决定。
   - 调整FIN_WAIT2状态的时间（只适用于close）
        如果 tcp_fin_timeout 秒内没有收到对⽅的 FIN 报⽂，连接就直接关闭。
   - 调整孤儿连接最大个数（只适用于close）
        大于最大个数则直接发送RST复位报文强制关闭，不走四次挥手
   - 调整TIME_WAIT最大个数（ tcp_max_tw_buckets ）
        超过该个数则不经历 TIME_WAIT ⽽直接关闭。当服务器的并发连接增多时应增大，减少不同连接间数据错乱的概率。但也不是越⼤越好，毕竟内存和端⼝都是有限的。
   - 复⽤处于 TIME_WAIT 状态的连接（tcp_tw_reuse ）
        只⽤于客户端（建⽴连接的发起⽅），因为在connect处启用
9. 复⽤处于 TIME_WAIT 状态的连接会不会使得连接无法正常关闭吗？
    不会，该复用要求连接双方必须打开时间戳，而时间戳保证了重复的数据包会因为时间戳过期被⾃然丢弃。当客户端复用连接后再发起新的连接时，会向服务端发送SYN，而LAST_ACK 状态的服务端会回复RST报文从而退出该状态。之后就是正常的三次握手，会花费1s在SYN重传上。
10. 为什么被动方CLOSE_WAIT没有时间限制？
    因为主动发可能是shutdown半关闭连接，还可能发送或接受数据
11. 当通过netstat发现大量CLOSE_WAIT状态该怎么办？
    需要排查应⽤程序，因为可能因为应⽤程序出现了 Bug， read 函数返回 0 时，没有调⽤ close 函数。
12. 什么情况下四次挥手可能会变成三次挥手？
    被动方迅速调用close函数，那么被动⽅的 ACK 和 FIN 有可能在⼀个报⽂中发送
13. 如果连接双⽅同时关闭连接，会怎么样？
    TCP双全工，可以同时发送FIN报文，都进⼊了 FIN_WAIT1 状态。双⽅在等待 ACK 报⽂的过程中，都等来了 FIN 报⽂。连接会进⼊⼀种叫做CLOSING 的新状态，它替代了 FIN_WAIT2 状态。接着，双⽅回复 ACK 确认对⽅发送通道的关闭后，进⼊TIME_WAIT 状态，等待 2MSL 的时间后，连接⾃动关闭。
14. 被动方的优化
    - 出现⼤量 CLOSE_WAIT 状态的连接时，应当从应⽤程序中找问题。
    - 控制重发 FIN 报⽂次数
         LAST_ACK 状态，在未等到 ACK 时，会重发FIN

#### 3.5.3 TCP 传输数据的性能提升
1. TCP超时重传有什么缺点？
   - 影响TCP的传输效率，如果存在大量超时重传说明网络状况很糟糕，超时重传的报文也会占用一部分网络资源
   - 由于TCP超时重传所以当TCP报文发出后，并不会⽴⻢从内存中删除。当连接数量非常多时，会占用系统内存资源
2. TCP如何传输包
   并⾏批量发送报⽂，再批量确认报⽂。如果有包丢失了，也不会进行重发，通过下一个确认应答进行确认。
3. 滑动窗口的作用是什么？
    接受方处理能力优先，发送⽅需要根据「接收⽅」的实际接收能⼒控制发送的数据量。
4. 发送⽅的窗⼝等价于接收⽅的窗⼝吗？
    如果不考虑拥塞控制，发送⽅的窗⼝⼤⼩「约等于」（存在时延）接收⽅的窗⼝⼤⼩
5. 滑动窗口大小是多少？
    定义在TCP头部，2个字节 * 窗⼝扩⼤因⼦（TCP 选项字段），最大为1G
6. 如何扩大滑动窗口的最大值的大小？
    打开窗口扩大因子功能，设置TCP内核参数tcp_window_scaling
7. 如何扩大滑动窗口的大小？
    扩大接受与发送缓冲区的大小，内核缓冲区决定了滑动窗⼝的上限
8. 接受缓冲区越大越好吗？
    不是。网络传输能力有限制，且缓冲区在内存中会影响服务器的并发能力
9. TCP的传输速度取决于什么？
    发送窗⼝与接收窗⼝，以及⽹络设备传输能⼒
10. 如何确定最⼤传输速度？
    带宽时延积BDP = RTT * 带宽.
11. 发送缓冲区大小如何确定？
    发送缓冲区⼤⼩决定了发送窗⼝的上限，⽽发送窗⼝⼜决定了「已发送未确认」的⻜⾏报⽂的上限。因此，发送缓冲区不能超过「带宽时延积」。超过则网络过载丢包，小于则没有充分利用网络
12. 怎样调整缓冲区⼤⼩？
   - 调节发送缓冲区范围
        设置TCP内核参数tcp_wmem最大最小值，系统动态调节
   - 调节接收缓冲区范围
        设置TCP内核参数tcp_rmem，系统动态调节，同时需要配置 tcp_moderate_rcvbuf 为 1 来开启调节功能
11. 什么时候调节接受缓冲区的大小？
    接收缓冲区可以根据系统空闲内存的⼤⼩来调节接收窗⼝。如果系统的空闲内存很多，就可以⾃动把缓冲区增⼤⼀些，这样传给对⽅的接收窗⼝也会变⼤，因⽽提升发送⽅发送的传输数据数量；反之，如果系统的内存很紧张，就会减少缓冲区，这虽然会降低传输效率，可以保证更多的并发连接正常⼯作
12. 如何调节TCP 内存范围
        设置TCP内核参数tcp_mem，系统动态调节。超出最大内存范围将无法建立TCP连接
13. 如何提高服务器的并发能力？
    为了兼顾⽹速与⼤量的并发连接， 我们应当保证缓冲区的动态调整的最⼤值达到带宽时延积，⽽最⼩值保持默认的 4K 不变即可。⽽对于内存紧张的服务⽽⾔，调低默认值是提⾼并发的有效⼿段。同时，如果这是⽹络 IO 型服务器，那么， 调⼤ tcp_mem 的上限可以让 TCP 连接使⽤更多的系统内存，这有利于提升并发能⼒
14. 如何优化TCP 传输数据的性能
    - 扩大窗口大小
    - 调整发送和接受缓冲区范围
    - 打开接受缓冲区动态调节
    - 调整内存范围
15. 讲一讲TCP的性能提升
    - 三次握手的性能提升
    - 四次挥手的性能提升
    - 传输过程中的性能提升
