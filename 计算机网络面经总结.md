### 计算机网络面经总结


### 3. TCP

#### 3.4 半连接和全连接队列

1. 什么是TCP半连接队列和全连接队列？
    第一次握手,服务端收到客户端发起的 SYN 请求后， 内核会把该连接存储到半连接队列.第三次握⼿,服务端收到 ACK 后， 内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。

2. 如何知道应⽤程序的 TCP 全连接队列⼤⼩？
    ss -lnt ,Recv-Q：当前全连接队列的⼤⼩,Send-Q：当前全连接最⼤队列⻓度，⾮ LISTEN 状态分别为已收到但未被应⽤进程读取的字节数,已发送但未收到确认的字节数

3. 如何模拟 TCP 全连接队列溢出的场景？
    wrk, HTTP 压测

4. TCP全连接队列溢出后会发生什么?
    默认⾏为tcp_abort_on_overflow = 0,服务器扔掉客户端发过来的ack.也可以设置tcp_abort_on_overflow = 1表示server发送⼀个reset复位报文给 client，表示废掉这个握⼿过程和这个连接.可以通过netstat -s | grep overflowed查看丢弃的连接数

5. tcp_abort_on_overflow为什么默认设置为0
    这样更有利于应对突发流量,提⾼连接建⽴的成功率.因为此时客户端连接状态为ESTABLISHED,只要服务器没有为请求回复 ACK，请求就会被多次重发.如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报⽂由于含有 ACK，仍然会触发服务器端成功建⽴连接。只有当TCP 全连接队列会⻓期溢出时，才能设置为 1 以尽快通知客户端

6. 如何增⼤ TCP 全连接队列呢?
    TCP 全连接队列的最⼤值sk_max_ack_backlog取决于 somaxconn(128) 和 backlog(511) 之间的最⼩值

7. 如何查看 TCP 半连接队列⻓度？
    服务端处于 SYN_RECV 状态的 TCP 连接数目，就是 TCP 半连接队列数目. nestat | grep SYN_RECV | wc -l

8. 如何模拟 TCP 半连接队列溢出场景？
    hping3 ⼯具模拟 SYN 攻击, 并关闭 tcp_syncookies。对服务端⼀直发送 TCP SYN 包，但是不回第三次握⼿ ACK。又称 SYN 洪泛、 SYN 攻击、 DDos 攻击。

9. TCP 半连接队列的最⼤值是如何决定的？
    - 半连接队列的⼤⼩并不单单只跟 tcp_max_syn_backlog(512)有关。当 max_syn_backlog > min(somaxconn, backlog) 时， 半连接队列最⼤值 max_qlen_log = min(somaxconn,backlog) * 2;当 max_syn_backlog < min(somaxconn, backlog) 时， 半连接队列最⼤值 max_qlen_log =max_syn_backlog * 2;
    - 每个 Linux 内核版本「理论」半连接最⼤值计算⽅式会不同
      在 Linux 5.0.0 的时候，「理论」半连接最⼤值就是全连接队列最⼤值

10. 第一次握手SYN因队列长度被丢弃的条件
    - 如果半连接队列满了，并且没有开启 tcp_syncookies，则会丢弃；
    - 若全连接队列满了，且没有重传 SYN+ACK 包的连接请求多于 1 个，则会丢弃；
    - 如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列⻓度⼩于(max_syn_backlog >> 2)，则会丢弃；


11. 半连接队列最⼤值max_qlen_log 就表示服务端处于 SYN_REVC 状态的最⼤个数吗？
    不一定。如果「当前半连接队列」 没超过「理论半连接队列最⼤值」，但是超过 max_syn_backlog - (max_syn_backlog >> 2)，那么处于 SYN_RECV 状态的最⼤个数就是 max_syn_backlog - (max_syn_backlog >> 2)；如果「当前半连接队列」 超过「理论半连接队列最⼤值」，那么处于 SYN_RECV 状态的最⼤个数就是「理论半连接队列最⼤值」；

12. 如果 SYN 半连接队列已满，只能丢弃连接吗？
      开启 syncookies 功能就可以在不使⽤ SYN 半连接队列的情况下成功建⽴连接。服务器根据当前状态计算出⼀个值，放在⼰⽅发出的 SYN+ACK 报⽂中发出，当客户端返回 ACK 报⽂时，取出该值验证，如果合法，就认为连接建⽴成功
13. 如何查看由于 SYN 半连接队列已满，⽽被丢弃连接的情况？
        netstat -s  | grep
14. 如何防御 SYN/DDOS 攻击？
    - 增⼤半连接队列
        想增⼤半连接队列，我们得知不能只单纯增⼤ tcp_max_syn_backlog 的值，还需⼀同增⼤ somaxconn 和 backlog，也就是增⼤全连接队列
    - 开启 tcp_syncookies 功能
    - 减少 SYN+ACK 重传次数
         SYN_REVC 状态的 TCP 连接会重传SYN+ACK ，当重传超过次数达到上限后，就会断开连接

15. TCP 内核参数
     在/proc/sys/net/ipv4/tcp*

#### 3.5 TCP性能提升策略
#### 3.5.1 三次握⼿的性能提升
1. 客户端优化
     - 优化SYN_SENT状态的SYN超时重传次数。重发的次数由 tcp_syn_retries 参数控制，默认是 5 次，每次超时的时间是上⼀次的 2 倍。怎么调整同下。
2. 服务端优化
     - 优化SYN_RCV 状态的 SYN+ACK 报⽂重传。当⽹络繁忙、不稳定时，报⽂丢失就会变严重，此时应该调⼤重发次数。反之则可以调⼩重发次数。 修改重发次数的⽅法是，调整 tcp_synack_retries 参数
     - 调整SYN半连接队列长度
     - 调整accept全连接队列长度
3.  绕过三次握手
   - 三次握⼿建⽴连接造成的后果是， HTTP 请求必须在⼀个 RTT（从客户端到服务器⼀个往返的时间）后才能发送。
   - 开启 TCP Fast Open 功能，这个功能可以减少 TCP 连接建⽴的时延
4. TCP Fast Open 功能的⼯作⽅式是什么？
   - 第⼀次发起 HTTP GET 请求的时候，还是需要正常的三次握⼿流程。客户端发送 SYN 报⽂，该报⽂包含 Fast Open 选项。⽀持 TCP Fast Open 的服务器⽣成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。
   - 客户端发送 SYN 报⽂，该报⽂包含「数据」以及此前记录的 Cookie；服务器会对收到 Cookie 进⾏校验：如果 Cookie 有效，服务器将在 SYN-ACK 报⽂中对 SYN 和「数据」进⾏确认。如果 Cookie ⽆效，服务器将丢弃 SYN 报⽂中包含的「数据」，且其随后发出的 SYN-ACK 报⽂将只确认 SYN 的对应序列号。如果服务器接受了 SYN 报⽂中的「数据」，服务器可在握⼿完成之前发送「数据」， 这就减少了握⼿带来的1 个 RTT 的时间消耗； 
5. 如果TCP Fast Open的SYN的数据没有被确认会怎样？
    客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报⽂中发送的「数据」没有被确认，则客户端将重新发送「数据」；
6. TFOCookie存放在哪？
    cookie 的值是存放到 TCP option 字段
7. Linux 下怎么打开 TCP Fast Open 功能呢？
    在 Linux 系统中，可以通过设置 tcp_fastopn 内核参数，来打开 Fast Open 功能。

#### 3.5.2 TCP 四次挥⼿的性能提升
1. TCP关闭连接的方式有哪几种？
    RST 报⽂关闭和 FIN 报⽂关闭。如果进程异常退出了，内核就会发送 RST 报⽂来关闭，不⾛四次挥⼿流程而暴⼒关闭连接。安全关闭连接的⽅式必须通过四次挥⼿，它由进程调⽤ close 和 shutdown 函数发起 FIN 报⽂。
2. 调⽤ close 函数和 shutdown 函数有什么区别？
   - 调⽤了 close 函数意味着完全断开连接， 完全断开不仅指⽆法传输数据，⽽且也不能发送数据。 此时，调⽤了close 函数的⼀⽅的连接叫做「孤⼉连接」
   -  shutdown 函数， 它可以控制只关闭⼀个⽅向的连接
      -  SHUT_RD(0)关闭连接的「读」这个⽅向，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进⾏ ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。
      -  关闭连接的「写」这个⽅向，这就是常被称为「半关闭」的连接。如果发送缓冲区还有未发送的数据，将被⽴即发送出去，并发送⼀个 FIN 报⽂给对端。
3. 如果遇到恶意攻击， FIN 报⽂根本⽆法发送出去怎么办？
   - ⾸先TCP 必须保证报⽂是有序发送的，当发送缓冲区还有数据没有发送时， FIN 报⽂不能提前发送
  其次， TCP 有流量控制功能，当接收⽅接收窗⼝为 0 时，发送⽅就不能再发送数据。所以，当攻击者下载⼤⽂件时，就可以通过接收窗⼝设为 0 ，这就会使得 FIN 报⽂都⽆法发送出去，那么连接会⼀直处于FIN_WAIT1 状态也不能提前发送。
   - 调整 tcp_max_orphans 参数，它定义了「孤⼉连接」的最⼤数量,如果孤⼉连接数量⼤于它，新增的孤⼉连接将不再⾛四次挥⼿，⽽是直接发送 RST 复位报⽂强制关闭。
4. 哪几种情况发送RST报文强制关闭连接
   进程异常退出时和孤儿连接超量时
5. 为什么TIME_WAIT2和 FIN_WAIT2默认都要保持 2MSL 时⻓？
    
6. 主动方优化
   - FIN_WAIT1 状态下，内核会定时重发 FIN 报⽂，其中重发次数由 tcp_orphan_retries 参数控制，默认8次。如果 FIN_WAIT1 状态连接很多，我们就需要考虑降低 tcp_orphan_retries 的值，当重传次数超过tcp_orphan_retries 时，连接就会直接关闭掉。
   - 对于FIN_WAIT2 状态，如果连接是⽤ shutdown 函数关闭的，连接可以⼀直处于 FIN_WAIT2 状态，因为它可能还可以发送或接收数据。但对于 close 函数关闭的孤⼉连接，由于⽆法再发送和接收数据，所以这个状态不可以持续太久，⽽tcp_fin_timeout 控制了这个状态下连接的持续时⻓，默认值是 60 秒。
   - 