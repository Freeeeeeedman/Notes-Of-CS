### 计算机网络面经总结


### 3. TCP

#### 3.4 半连接和全连接队列

1. 什么是TCP半连接队列和全连接队列？
    第一次握手,服务端收到客户端发起的 SYN 请求后， 内核会把该连接存储到半连接队列.第三次握⼿,服务端收到 ACK 后， 内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。

2. 如何知道应⽤程序的 TCP 全连接队列⼤⼩？
    ss -lnt ,Recv-Q：当前全连接队列的⼤⼩,Send-Q：当前全连接最⼤队列⻓度，⾮ LISTEN 状态分别为已收到但未被应⽤进程读取的字节数,已发送但未收到确认的字节数

3. 如何模拟 TCP 全连接队列溢出的场景？
    wrk, HTTP 压测

4. TCP全连接队列溢出后会发生什么?
    默认⾏为tcp_abort_on_overflow = 0,服务器扔掉客户端发过来的ack.也可以设置tcp_abort_on_overflow = 1表示server发送⼀个reset复位报文给 client，表示废掉这个握⼿过程和这个连接.可以通过netstat -s | grep overflowed查看丢弃的连接数

5. tcp_abort_on_overflow为什么默认设置为0
    这样更有利于应对突发流量,提⾼连接建⽴的成功率.因为此时客户端连接状态为ESTABLISHED,只要服务器没有为请求回复 ACK，请求就会被多次重发.如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报⽂由于含有 ACK，仍然会触发服务器端成功建⽴连接。只有当TCP 全连接队列会⻓期溢出时，才能设置为 1 以尽快通知客户端

6. 如何增⼤ TCP 全连接队列呢?
    TCP 全连接队列的最⼤值sk_max_ack_backlog取决于 somaxconn(128) 和 backlog(511) 之间的最⼩值

7. 如何查看 TCP 半连接队列⻓度？
    服务端处于 SYN_RECV 状态的 TCP 连接数目，就是 TCP 半连接队列数目. nestat | grep SYN_RECV | wc -l

8. 如何模拟 TCP 半连接队列溢出场景？
    hping3 ⼯具模拟 SYN 攻击, 并关闭 tcp_syncookies。对服务端⼀直发送 TCP SYN 包，但是不回第三次握⼿ ACK。又称 SYN 洪泛、 SYN 攻击、 DDos 攻击。

9. TCP 半连接队列的最⼤值是如何决定的？
    - 半连接队列的⼤⼩并不单单只跟 tcp_max_syn_backlog(512)有关。当 max_syn_backlog > min(somaxconn, backlog) 时， 半连接队列最⼤值 max_qlen_log = min(somaxconn,backlog) * 2;当 max_syn_backlog < min(somaxconn, backlog) 时， 半连接队列最⼤值 max_qlen_log =max_syn_backlog * 2;
    - 每个 Linux 内核版本「理论」半连接最⼤值计算⽅式会不同
      在 Linux 5.0.0 的时候，「理论」半连接最⼤值就是全连接队列最⼤值

10. 第一次握手SYN因队列长度被丢弃的条件
    - 如果半连接队列满了，并且没有开启 tcp_syncookies，则会丢弃；
    - 若全连接队列满了，且没有重传 SYN+ACK 包的连接请求多于 1 个，则会丢弃；
    - 如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列⻓度⼩于(max_syn_backlog >> 2)，则会丢弃；


11. 半连接队列最⼤值max_qlen_log 就表示服务端处于 SYN_REVC 状态的最⼤个数吗？
    不一定。如果「当前半连接队列」 没超过「理论半连接队列最⼤值」，但是超过 max_syn_backlog - (max_syn_backlog >> 2)，那么处于 SYN_RECV 状态的最⼤个数就是 max_syn_backlog - (max_syn_backlog >> 2)；如果「当前半连接队列」 超过「理论半连接队列最⼤值」，那么处于 SYN_RECV 状态的最⼤个数就是「理论半连接队列最⼤值」；

12. 如果 SYN 半连接队列已满，只能丢弃连接吗？
      开启 syncookies 功能就可以在不使⽤ SYN 半连接队列的情况下成功建⽴连接。服务器根据当前状态计算出⼀个值，放在⼰⽅发出的 SYN+ACK 报⽂中发出，当客户端返回 ACK 报⽂时，取出该值验证，如果合法，就认为连接建⽴成功
13. 如何查看由于 SYN 半连接队列已满，⽽被丢弃连接的情况？
        netstat -s  | grep
14. 如何防御 SYN/DDOS 攻击？
    - 增⼤半连接队列
        想增⼤半连接队列，我们得知不能只单纯增⼤ tcp_max_syn_backlog 的值，还需⼀同增⼤ somaxconn 和 backlog，也就是增⼤全连接队列
    - 开启 tcp_syncookies 功能
    - 减少 SYN+ACK 重传次数
         SYN_REVC 状态的 TCP 连接会重传SYN+ACK ，当重传超过次数达到上限后，就会断开连接

15. TCP 内核参数
     在/proc/sys/net/ipv4/tcp*

#### 3.5 TCP性能提升策略
#### 3.5.1 三次握⼿的性能提升
1. 客户端优化
     - 优化SYN_SENT状态的SYN超时重传次数。重发的次数由 tcp_syn_retries 参数控制，默认是 5 次，每次超时的时间是上⼀次的 2 倍。怎么调整同下。
2. 服务端优化
     - 优化SYN_RCV 状态的 SYN+ACK 报⽂重传。当⽹络繁忙、不稳定时，报⽂丢失就会变严重，此时应该调⼤重发次数。反之则可以调⼩重发次数。 修改重发次数的⽅法是，调整 tcp_synack_retries 参数
     - 调整SYN半连接队列长度
     - 调整accept全连接队列长度
3.  绕过三次握手
   - 三次握⼿建⽴连接造成的后果是， HTTP 请求必须在⼀个 RTT（从客户端到服务器⼀个往返的时间）后才能发送。
   - 开启 TCP Fast Open 功能，这个功能可以减少 TCP 连接建⽴的时延
4. TCP Fast Open 功能的⼯作⽅式是什么？
   - 第⼀次发起 HTTP GET 请求的时候，还是需要正常的三次握⼿流程。客户端发送 SYN 报⽂，该报⽂包含 Fast Open 选项。⽀持 TCP Fast Open 的服务器⽣成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。
   - 客户端发送 SYN 报⽂，该报⽂包含「数据」以及此前记录的 Cookie；服务器会对收到 Cookie 进⾏校验：如果 Cookie 有效，服务器将在 SYN-ACK 报⽂中对 SYN 和「数据」进⾏确认。如果 Cookie ⽆效，服务器将丢弃 SYN 报⽂中包含的「数据」，且其随后发出的 SYN-ACK 报⽂将只确认 SYN 的对应序列号。如果服务器接受了 SYN 报⽂中的「数据」，服务器可在握⼿完成之前发送「数据」， 这就减少了握⼿带来的1 个 RTT 的时间消耗； 
5. 如果TCP Fast Open的SYN的数据没有被确认会怎样？
    客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报⽂中发送的「数据」没有被确认，则客户端将重新发送「数据」；
6. TFOCookie存放在哪？
    cookie 的值是存放到 TCP option 字段
7. Linux 下怎么打开 TCP Fast Open 功能呢？
    在 Linux 系统中，可以通过设置 tcp_fastopn 内核参数，来打开 Fast Open 功能。

#### 3.5.2 TCP 四次挥⼿的性能提升
1. TCP关闭连接的方式有哪几种？
    RST 报⽂关闭和 FIN 报⽂关闭。如果进程异常退出了，内核就会发送 RST 报⽂来关闭，不⾛四次挥⼿流程而暴⼒关闭连接。安全关闭连接的⽅式必须通过四次挥⼿，它由进程调⽤ close 和 shutdown 函数发起 FIN 报⽂。
2. 调⽤ close 函数和 shutdown 函数有什么区别？
   - 调⽤了 close 函数意味着完全断开连接， 完全断开不仅指⽆法传输数据，⽽且也不能发送数据。 此时，调⽤了close 函数的⼀⽅的连接叫做「孤⼉连接」
   -  shutdown 函数， 它可以控制只关闭⼀个⽅向的连接
      -  SHUT_RD(0)关闭连接的「读」这个⽅向，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进⾏ ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。
      -  关闭连接的「写」这个⽅向，这就是常被称为「半关闭」的连接。如果发送缓冲区还有未发送的数据，将被⽴即发送出去，并发送⼀个 FIN 报⽂给对端。
3. 如果遇到恶意攻击， FIN 报⽂根本⽆法发送出去怎么办？
   - ⾸先TCP 必须保证报⽂是有序发送的，当发送缓冲区还有数据没有发送时， FIN 报⽂不能提前发送
   - 其次， TCP 有流量控制功能，当接收⽅接收窗⼝为 0 时，发送⽅就不能再发送数据。所以，当攻击者下载⼤⽂件时，就可以通过接收窗⼝设为 0 ，这就会使得 FIN 报⽂都⽆法发送出去，那么连接会⼀直处于FIN_WAIT1 状态也不能提前发送。
   - 调整 tcp_max_orphans 参数，它定义了「孤⼉连接」的最⼤数量,如果孤⼉连接数量⼤于它，新增的孤⼉连接将不再⾛四次挥⼿，⽽是直接发送 RST 复位报⽂强制关闭。
4. 哪几种情况发送RST报文强制关闭连接
   进程异常退出时和孤儿连接超量时
5. 为什么FIN_WAIT2和 TIME_WAIT默认都要保持 2MSL（60s） 时⻓？
        因为这两个状态都需要保持 2MSL 时⻓，这样当, FIN(FIN_WAIT2)， ACK(TIME_WAIT)丢失时，被动方重发的报文会在第二个MSL内到达，保证连接正常关闭
6. 为什么不是4或者8MSL？
        这意味连续两次丢包，对于丢包率达到百分之⼀的糟糕⽹络，连续两次丢包的概率只有万分之⼀，这个概率实在是太⼩了，忽略它⽐解决它更具性价比
7. TIME_WAIT状态过多会怎样？
   - 如果是客户端，由于客户端 TIME_WAIT 过多，就会导致端⼝资源被占⽤，⽆法创建新连接
   - 如果是服务端，会导致系统资源被占满，⽆法创建新连接
8. 主动方优化
   - 降低主动方FIN重传次数
        主动发起 FIN 报⽂断开连接的⼀⽅，如果迟迟没收到对⽅的 ACK 回复，则会重传 FIN 报⽂，重传的次数由tcp_orphan_retries 参数决定。
   - 调整FIN_WAIT2状态的时间（只适用于close）
        如果 tcp_fin_timeout 秒内没有收到对⽅的 FIN 报⽂，连接就直接关闭。
   - 调整孤儿连接最大个数（只适用于close）
        大于最大个数则直接发送RST复位报文强制关闭，不走四次挥手
   - 调整TIME_WAIT最大个数（ tcp_max_tw_buckets ）
        超过该个数则不经历 TIME_WAIT ⽽直接关闭。当服务器的并发连接增多时应增大，减少不同连接间数据错乱的概率。但也不是越⼤越好，毕竟内存和端⼝都是有限的。
   - 复⽤处于 TIME_WAIT 状态的连接（tcp_tw_reuse ）
        只⽤于客户端（建⽴连接的发起⽅），因为在connect处启用
9. 复⽤处于 TIME_WAIT 状态的连接会不会使得连接无法正常关闭吗？
    不会，该复用要求连接双方必须打开时间戳，而时间戳保证了重复的数据包会因为时间戳过期被⾃然丢弃。当客户端复用连接后再发起新的连接时，会向服务端发送SYN，而LAST_ACK 状态的服务端会回复RST报文从而退出该状态。之后就是正常的三次握手，会花费1s在SYN重传上。
10. 为什么被动方CLOSE_WAIT没有时间限制？
    因为主动发可能是shutdown半关闭连接，还可能发送或接受数据
11. 当通过netstat发现大量CLOSE_WAIT状态该怎么办？
    需要排查应⽤程序，因为可能因为应⽤程序出现了 Bug， read 函数返回 0 时，没有调⽤ close 函数。
12. 什么情况下四次挥手可能会变成三次挥手？
    被动方迅速调用close函数，那么被动⽅的 ACK 和 FIN 有可能在⼀个报⽂中发送
13. 如果连接双⽅同时关闭连接，会怎么样？
    TCP双全工，可以同时发送FIN报文，都进⼊了 FIN_WAIT1 状态。双⽅在等待 ACK 报⽂的过程中，都等来了 FIN 报⽂。连接会进⼊⼀种叫做CLOSING 的新状态，它替代了 FIN_WAIT2 状态。接着，双⽅回复 ACK 确认对⽅发送通道的关闭后，进⼊TIME_WAIT 状态，等待 2MSL 的时间后，连接⾃动关闭。
14. 被动方的优化
    - 出现⼤量 CLOSE_WAIT 状态的连接时，应当从应⽤程序中找问题。
    - 控制重发 FIN 报⽂次数
         LAST_ACK 状态，在未等到 ACK 时，会重发FIN