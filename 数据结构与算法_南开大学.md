[toc]
#数据结构与算法_南开大学
####模块化
1. 编译预处理
   - 定义
      编译程序前的处理，以#开头，末尾无分号
   - 包括
     - 文件包含
       - 系统头文件`#include <iostream>`
       - 自定义头文件`#include "test.h"`
     - 宏定义
       - 将程序中出现的宏名替换为它所对应的**字符串**
       - 无参宏定义"#define PI 3.1415926"
       - 有参宏定义"#define 宏名(形参表) 字符串"，使用：宏名(实参表)
         - 用实参替换宏定义的字符串中相应的形参
         - 再将替换后的字符串替换程序中的"宏名(实参表)"
         - 类似函数
     - 条件编译
       - 对某段代码有条件地参与编译或者不参与编译
        ```
        #ifdef 标识符
                程序段1
        [#else
                程序段2]
        #endif
       
        #ifndef 标识符
                程序段1
        [#else
                程序段2]
        #endif
        
        #if 表达式
                程序段1
        [#else
                程序段2]
        #endif
        ```
       - **利用无参宏编译和条件编译对象调试信息的显示控制** 
2. 多文件结构
   - 定义
    将同一类功能的函数，变量定义放在同一文件中，不同类功能放在多个文件中
   - 优点
     - 结构清晰，管理查找方便
     - 没有访问冲突
   - 头文件
     - 数据类型的定义：结构体，枚举等
     - 自定义函数的函数声明
     - 符号常量定义或宏定义`const int N=100;`
     - 全局变量的外部声明：`extern int g_num[N];`
     - **内联函数的定义**
       - 内联成员函数包括构造是对于当前文本可见
     - 其他头文件
     - 不含有函数定义
   - 源文件
     - 函数定义
     - 全局变量定义`int g_num[N];`
   - 防止重复定义
     - 方位式声明















####面向对象概念
1. 定义
   - 面向对象方法是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构造系统的软件开发方法
2. 对象
   - 静态特征
   - 动态特征
3. 类
   - 属性
   - 方法
4. 实例
5. 消息
   - 对象之间进行通信的机制，就是向对象发出的操作请求
6. 封装
   - 将对象的属性和方法结合构成一个独立实体并对外屏蔽内部细节
   - 有清晰的边界
   - 有确定的接口
   - 受保护的内部实现
7. 继承
   - 单继承
   - 多继承
   - 多重继承：传递性
8. 多态性
   - 在具有继承关系的类层次结构中可以定义同门的属性或方法，但不同层次的类的确可以按照各自的需求实现这个不一定相同的行为
9. 聚合
   - 一个对象由多个对象聚集而成，整体与部分的关系
   - 可分离，有各自的生命周期
10. 组合
    - 同样是整体与部分的关系
    - 不可分，同样的生命周期


####类
1. 定义
   - 类目，属性，方法
   - 数据成员(成员数据)
   - 成员函数(函数成员)
2. 语法格式
```
class<..>{
public:
private:
protect:
};//不要忘记类定义最后的分号；
```
3. 构造函数
   - 自动调用初始化对象
   - 可以被重载
   - 特点
     - 函数名必须与类目相同
     - 无返回类型，void也不行
     - 自动调用
     - 没有写时系统自动创造无参构造函数
4. 对象的定义
   - 类是用户自定义的数据类型，对象是定义类的变量
   - 定义对象的过程叫做类的实例化
   - 有初始值`Circle circleA;`
   - 无初始值`Circle circleB(2,2,12.5);`
5. 对象的访问
   - 对象名+“.”成员名(实参)
   - 对象指针+“—>”成员名(实参)
   - 消息机制即调用成员函数
   - 直接访问(破坏封装性)
   - 通过向对象发出消息访问
6. 类成员的访问控制
   - 类成员的访问控制实现了类的封装性
   - 公有成员public
     - 在程序的任何地方都可以被访问
     - 一般是接口函数
   - 私有成员private
     - 只能被该类的成员函数或该类的友元函数访问
     - 一般是数据成员
     - 实现封装
   - 保护成员protect
     - 只能在该类的内部或其派生类中使用
     - 可以被继承
   - 分别可以出现多个，没有顺序限制，默认为private成员
7. 析构函数
   - 函数名:~<classname>
   - 无返回类型
   - 无参数，所以不能被重载
   - 类声明时没有给出时，系统自动创造~<classname>(){}
   - 对象生命周期结束或者delete时系统自动调用
   - 释放空间或者实现最后一次使用对象后的任何操作
8. 拷贝构造函数
   - <cn>(<cn>&on)
   - 使用以及存在的对象来初始化新对象
   - 新参只有一个为对象的引用，无法重载
   - 无返回类型
   - 没有定义时系统默认给出，对位拷贝，浅拷贝
     - 有指针时，对位拷贝指向同一空间会出现内存泄漏
   - 何时自动调用
     - Circle circle1(circle2);Circle circle1=circle2;
     - 实参形参结合时
     - 函数返回值为类的对象时
9. 类声明与类实现的分离
   - 类声明描述类的结构".h"
   - 类实现定义成员函数的具体功能".cpp"
     - <函数类型><类名>::<函数名>(<形参数表>){函数体}
     - ::作用域运算符
   - 显得明晰
10. 类的静态成员
   - 静态数据成员属于类而非对象，所有对象共享
   - 数据成员
     - static
     - 类内声明，但需要在类外定义静态数据成员，且只能出现一次，不需要再加static
     - 最好放在类实现文件中
   - 静态成员函数
     - 访问私有静态数据成员的接口
     - 不能访问非静态成员函数
       - 为什么？:静态成员函数没有this指针
     - 通过构造和析构函数维护静态数据成员
     - 公有访问形式
       - <类名>::<静态成员函数名>([实参])
       - <对象名>.<静态成员函数名>([实参])
       - <对象指针>—><静态成员函数名>([实参])
11. 类的常量成员
    - 常量数据成员
      - 声明时不能被赋值，只有再定义对象时才能通过构造函数初始化，且之后不允许再被修改
    - 常量成员函数
      - 只有权读取对象的数据成员
      - <><>(<>)const
      - 类外定义时不可省略const
12. this指针
    - this指针是隐含于非静态成员函数中的特殊指针
    - 当一个对象调用非静态成员函数时，this就指向这个对象
    - 显式使用
        - 函数形参名与对象数据成员名相同时，this->a
        - 返回对象或对象地址
13. 类的友元
    - 定义
        - 友元提高了一般函数与类成员，不同类成员之间进行数据共享的机制
        - 提高程序运行效率
    - 类型
        - 友元函数：friend<type><funcname><paras>
        - 友元成员：friend<type><friendclassname>::<funcname>(paras)
        - 友类: friend<fcn>,friend class<fcn>
    - 类声明:使用其他类时先声明，记得传递引用
14. 类的对象成员
    - 聚合，组合，属于：数据成员味另一个类的对象
    - 对象成员的初始化
        - 是那个构造函数特有的初始化方法
    - 对对象成员的私有成员不可以直接调用
15. 自定义类的运算符重载
    - 关键字opeartor以及运算符+
    - 五种不能重载的运算符
        - 类属关系运算符 .
        - 成员指针运算符 .* ->* (指向一个类中某个成员的指针)
        - 作用域运算符 ::
        - sizeof运算符
        - 三目运算符 ？:
    - 特点
        - 不能创建新的运算符
        - 实质为函数重载
        - 不能改变优先级和结合性
        - 大部分运算符可以定义为类的成员函数或者友元函数
    - 成员函数运算符
        - <对象名><运算符><参数>
        - 实质<对象名>operator<运算符>(<参数>)，没有少参数，两个操作数
         `complex& operator += (const complex&);`
    - 友元函数运算符
        - 没有this指针，实质是opeartor<运算符>(<参数1>，<参数2>);
        - `friend complex& operator+ (complex &, const complex&);`
    - ？选择标准
        - 单目成员函数，双目友元函数
        - 以下双目只能重载为成员函数：=,(),[],->
        - 需要修改对象成员函数
        - 操作数有隐式类型转换友元函数
        - 最左边的操作数必须是类的对象或者该类对象的引用运算符时，成员函数
        - 最左边的操作数必须是不同类的对象或者内部类型的对象，友元函数(无this指针)
        - 具有可交换性，友元函数形式
16. 继承
    - 定义
        - 基类(父类)，派生类(子类)
        - 继承基类所有属性和方法并定义派生类特有属性和方法
    - 语法
         class 派生类名:继承方式 基类名
         {
            派生类成员声明
         };
    - 访问控制
        - 取决于 
          - 该成员在基类中的访问控制方式
          - 定义派生类所采用的继承方式

         |左继承上原成员|public|private|protect|
         |:-:|:-:|:-:|:-:|
         | public|public |不可直接访问|protected|
         | private|private |不可直接访问|private|
         | protected|protected |不可直接访问|protected|
    - 函数重定义
    - 派生类的构造函数与析构函数
        - 初始化/清除派生类中新添加的数据成员
        - 构造函数:先基后派
            派生类名(形参):基类名(实参)     后面不写等价于调用无参的构造函数
            {
               派生类中数据成员初始化
            }
            同时初始化基类：可以将派生类构造函数的形参，以及常量，全局变量等作为实参传递给基类构造函数l
        - 析构函数:先派后基
            ~派生类名()
    - 多继承
        - 语法
            class 派生类名:继承方式 基类名1，继承方式 基类名2
            {
               派生类成员声明
            };
        - 调用构造函数的顺序和继承顺序一致，析构函数相反
        - 二义性问题(菱形继承，即次级基类有共同基类)
          - 例：B,C类继承A类，D继承B,C类，那么D中会有两份A类的成员，调用时会报错
          - 虚拟继承和虚基类
               class 派生类名:virtual 继承方式 虚基类名{...}
              - 虚基类中的成员在类的继承关系中只会被继承一次，D只会继承一份A
              - 必须显式写出A类的初始化
               ```
               class B: virtual public A{...};
               class C: virtual public A{...};
               class D: public B,public C
               {
                  public:
                     D(...,int x,int y):B(...),C(...),A(x,y){}
                  ...
               }
          - 如果不是菱形继承，只是多个基类有同名成员，那么这个时候需要在成员名字前面加上类名和域解析符::，以显式地指明到底使用哪个类的成员，消除二义性。
17. 多态
    - 类型兼容
        - 指在基类对象可以出现的任何地方都可以用公有派生类的对象来替代
        - 可以用派生类对象为基类对象赋值
        - 可以用派生类对象初始化基类引用
        - 可以用派生类对象地址为基类指针赋值
        - 用派生类对象替代基类对象进行赋值操作后，通过基类对象，基类引用和基类指针**只能**访问派生类从基类继承的成员
    - 多态性
        - 定义：能够根据**指针**或**引用**所表示的对象的实际类型来调用该对象所属的类的函数，而不是每次都调用基类的函数的特性为多态性
        - 操作中使用相同函数进行统一处理
        - 绑定:建立函数调用和函数本体的关联
        - 先期绑定(静态绑定):绑定发生在程序运行前
        - 后期绑定(动态绑定):绑定发生在程序运行中
    - 虚函数
        - 实现动态绑定，基类函数加上virtual关键字
        - 具有继承性，基类函数为虚函数，派生类无论加不加virtual都是虚函数
        - 只有使用基类的指针或引用调用虚函数才能实现多态性，如果使用对象调用虚函数，则会调用基类的函数
18. 抽象类
    - 具体类
      - 实例化为对象
    - 抽象类
      - 仅仅表现概念，不可以实例化为对象(编译器会报错)
      - 用途：定义子类所共有的属性和方法，并作为子类的基类  
    - 纯虚函数
      - 如果一个类是抽象类，则至少有一个成员函数为纯虚函数
      - `virtual <类型>纯虚函数名(<参数表>)=0;`


####模板
1. 模板
   - 定义:模板是参数化的函数或类，将数据类型作为参数
   - 算法，通用
   - 分为函数模板和类模板
2. 泛化编程
     - 对抽象的算法的编程
     - 泛化指可以广泛适用于不同的数据类型
3. 函数模板
   - 定义
    用来描述一个与数据类型无关的函数(算法)，避免重载函数时函数体的重复设计
   - 语法
    template<<模板形参表>><函数类型><函数名>(<函数形参表>){函数体}
    `template <typename T> T Max(T a,T b)`
   - 模板函数
     - 实例化的函数模板
     - 调用时由编译器自动生成模板函数，根据传入的数据类型指定类型
     - 一般放在头文件，方便编译器寻找并调用
   - 与重载函数的区别
     - 重载函数各函数体内可以执行不同的代码
     - 函数模板执行相同代码，仅仅是数据类型相同
   - 函数模板与一般函数同名时
     - 首先寻找参数完全匹配的一般函数，找到就调用
     - 再寻找函数模板，使其实例化，生成一个匹配的模板函数，再调用该模板函数
4. 类模板
   - 定义
     - 用来描述一组与数据类型无关的类
     - 数据成员，函数成员的参数和返回值可以被模板化
     - 是一组类的统一描述
   - 语法
      template<<模板形参表>>
      class<类模板名>{类体};
      ```
      template<typename T,int length>
      class Array{...};

   - 类模板的成员函数在类模板外定义
      template<<模板形参表>>
      函数类型<类模板名><类型形参名表>::<成员函数名>(函数形参表){...};
      ```
      template<typename T,int length>
      void Array<T,length>::SetElement(T,x){...}
      ```
   - 模板类
      类模板的实例化必须由程序员在程序中显式指定，其中类型实参表必须与模板中模板形参表顺序和类型相同
      <类模板名><<模板形参表>><对象名表>
      `Array<int,10> a;`
   - 注意
     - 类模板成员函数也是模板但只有在它被调用时才实例化，类模板被实例化时它并不自动实例化
     - 类模板的声明和类模板成员函数的定义应放在同一头文件中