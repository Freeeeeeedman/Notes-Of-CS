[toc]
#数据结构与算法_南开大学

####面向对象概念
1. 定义
   - 面向对象方法是一种运用对象、类、继承、封装、聚合、关联、消息、多态性等概念来构造系统的软件开发方法
2. 对象
   - 静态特征
   - 动态特征
3. 类
   - 属性
   - 方法
4. 实例
5. 消息
   - 对象之间进行通信的机制，就是向对象发出的操作请求
6. 封装
   - 将对象的属性和方法结合构成一个独立实体并对外屏蔽内部细节
   - 有清晰的边界
   - 有确定的接口
   - 受保护的内部实现
7. 继承
   - 单继承
   - 多继承
   - 多重继承：传递性
8. 多态性
   - 在具有继承关系的类层次结构中可以定义同门的属性或方法，但不同层次的类的确可以按照各自的需求实现这个不一定相同的行为
9. 聚合
   - 一个对象由多个对象聚集而成，整体与部分的关系
   - 可分离，有各自的生命周期
10. 组合
    - 同样是整体与部分的关系
    - 不可分，同样的生命周期


####类
1. 定义
   - 类目，属性，方法
   - 数据成员(成员数据)
   - 成员函数(函数成员)
2. 语法格式
```
class<..>{
public:
private:
protect:
};//不要忘记类定义最后的分号；
```
3. 构造函数
   - 自动调用初始化对象
   - 可以被重载
   - 特点
     - 函数名必须与类目相同
     - 无返回类型，void也不行
     - 自动调用
     - 没有写时系统自动创造无参构造函数
4. 对象的定义
   - 类是用户自定义的数据类型，对象是定义类的变量
   - 定义对象的过程叫做类的实例化
   - 有初始值`Circle circleA;`
   - 无初始值`Circle circleB(2,2,12.5);`
5. 对象的访问
   - 对象名+“.”成员名(实参)
   - 对象指针+“—>”成员名(实参)
   - 消息机制即调用成员函数
   - 直接访问(破坏封装性)
   - 通过向对象发出消息访问
6. 类成员的访问控制
   - 类成员的访问控制实现了类的封装性
   - 公有成员public
     - 在程序的任何地方都可以被访问
     - 一般是接口函数
   - 私有成员private
     - 只能被该类的成员函数或该类的友元函数访问
     - 一般是数据成员
     - 实现封装
   - 保护成员protect
     - 只能在该类的内部或其派生类中使用
     - 可以被继承
   - 分别可以出现多个，没有顺序限制，默认为private成员
7. 析构函数
   - 函数名:~<classname>
   - 无返回类型
   - 无参数，所以不能被重载
   - 类声明时没有给出时，系统自动创造~<classname>(){}
   - 对象生命周期结束或者delete时系统自动调用
   - 释放空间或者实现最后一次使用对象后的任何操作
8. 拷贝构造函数
   - <cn>(<cn>&on)
   - 使用以及存在的对象来初始化新对象
   - 新参只有一个为对象的引用，无法重载
   - 无返回类型
   - 没有定义时系统默认给出，对位拷贝，浅拷贝
     - 有指针时，对位拷贝指向同一空间会出现内存泄漏
   - 何时自动调用
     - Circle circle1(circle2);Circle circle1=circle2;
     - 实参形参结合时
     - 函数返回值为类的对象时
9. 类声明与类实现的分离
   - 类声明描述类的结构".h"
   - 类实现定义成员函数的具体功能".cpp"
     - <函数类型><类名>::<函数名>(<形参数表>){函数体}
     - ::作用域运算符
   - 显得明晰
10. 类的静态成员
   - 静态数据成员属于类而非对象，所有对象共享
   - 数据成员
     - static
     - 类内声明，但需要在类外定义静态数据成员，且只能出现一次，不需要再加static
     - 最好放在类实现文件中
   - 静态成员函数
     - 访问私有静态数据成员的接口
     - 不能访问非静态成员函数
       - 为什么？:静态成员函数没有this指针
     - 通过构造和析构函数维护静态数据成员
     - 公有访问形式
       - <类名>::<静态成员函数名>([实参])
       - <对象名>.<静态成员函数名>([实参])
       - <对象指针>—><静态成员函数名>([实参])
11. 类的常量成员
    - 常量数据成员
      - 声明时不能被赋值，只有再定义对象时才能通过构造函数初始化，且之后不允许再被修改
    - 常量成员函数
      - 只有权读取对象的数据成员
      - <><>(<>)const
      - 类外定义时不可省略const
12. this指针
    - this指针是隐含于非静态成员函数中的特殊指针
    - 当一个对象调用非静态成员函数时，this就指向这个对象
    - 显式使用
        - 函数形参名与对象数据成员名相同时，this->a
        - 返回对象或对象地址
13. 类的友元
    - 定义
        - 友元提高了一般函数与类成员，不同类成员之间进行数据共享的机制
        - 提高程序运行效率
    - 类型
        - 友元函数：friend<type><funcname><paras>
        - 友元成员：friend<type><friendclassname>::<funcname>(paras)
        - 友类: friend<fcn>,friend class<fcn>
    - 类声明:使用其他类时先声明，记得传递引用
14. 类的对象成员
    - 聚合，组合，属于：数据成员味另一个类的对象
    - 对象成员的初始化
        - 是那个构造函数特有的初始化方法
    - 对对象成员的私有成员不可以直接调用
15. 自定义类的运算符重载
    - 关键字opeartor以及运算符+
    - 五种不能重载的运算符
        - 类属关系运算符 .
        - 成员指针运算符 .* ->* (指向一个类中某个成员的指针)
        - 作用域运算符 ::
        - sizeof运算符
        - 三目运算符 ？:
    - 特点
        - 不能创建新的运算符
        - 实质为函数重载
        - 不能改变优先级和结合性
        - 大部分运算符可以定义为类的成员函数或者友元函数
    - 成员函数运算符
        - <对象名><运算符><参数>
        - 实质<对象名>operator<运算符>(<参数>)，没有少参数，两个操作数
         `complex& operator += (const complex&);`
    - 友元函数运算符
        - 没有this指针，实质是opeartor<运算符>(<参数1>，<参数2>);
        - `friend complex& operator+ (complex &, const complex&);`
    - ？选择标准
        - 单目成员函数，双目友元函数
        - 以下双目只能重载为成员函数：=,(),[],->
        - 需要修改对象成员函数
        - 操作数有隐式类型转换友元函数
        - 最左边的操作数必须是类的对象或者该类对象的引用运算符时，成员函数
        - 最左边的操作数必须是不同类的对象或者内部类型的对象，友元函数(无this指针)
        - 具有可交换性，友元函数形式
16. 继承
    - 定义
        - 基类(父类)，派生类(子类)
        - 继承基类所有属性和方法并定义派生类特有属性和方法
    - 语法
         class 派生类名:继承方式 基类名
         {
            派生类成员声明
         };
    - 访问控制
        - 取决于 
          - 该成员在基类中的访问控制方式
          - 定义派生类所采用的继承方式

         |左继承上原成员|public|private|protect|
         |:-:|:-:|:-:|:-:|
         | public|public |不可直接访问|protected|
         | private|private |不可直接访问|private|
         | protected|protected |不可直接访问|protected|
    - 函数重定义
    - 派生类的构造函数与析构函数
        - 初始化/清除派生类中新添加的数据成员
        - 构造函数:先基后派
            派生类名(形参):基类名(实参)     后面不写等价于调用无参的构造函数
            {
               派生类中数据成员初始化
            }
            同时初始化基类：可以将派生类构造函数的形参，以及常量，全局变量等作为实参传递给基类构造函数l
        - 析构函数:先派后基
            ~派生类名()
    - 多继承
        - 语法
            class 派生类名:继承方式 基类名1，继承方式 基类名2
            {
               派生类成员声明
            };
        - 调用构造函数的顺序和继承顺序一致，析构函数相反
        - 二义性问题(菱形继承，即次级基类有共同基类)
          - 例：B,C类继承A类，D继承B,C类，那么D中会有两份A类的成员，调用时会报错
          - 虚拟继承和虚基类
               class 派生类名:virtual 继承方式 虚基类名{...}
              - 虚基类中的成员在类的继承关系中只会被继承一次，D只会继承一份A
              - 必须显式写出A类的初始化
               ```
               class B: virtual public A{...};
               class C: virtual public A{...};
               class D: public B,public C
               {
                  public:
                     D(...,int x,int y):B(...),C(...),A(x,y){}
                  ...
               }
          - 如果不是菱形继承，只是多个基类有同名成员，那么这个时候需要在成员名字前面加上类名和域解析符::，以显式地指明到底使用哪个类的成员，消除二义性。
17. 多态
    - 类型兼容
        - 指在基类对象可以出现的任何地方都可以用公有派生类的对象来替代
        - 可以用派生类对象为基类对象赋值
        - 可以用派生类对象初始化基类引用
        - 可以用派生类对象地址为基类指针赋值
        - 用派生类对象替代基类对象进行赋值操作后，通过基类对象，基类引用和基类指针**只能**访问派生类从基类继承的成员
    - 多态性
        - 定义：能够根据**指针**或**引用**所表示的对象的实际类型来调用该对象所属的类的函数，而不是每次都调用基类的函数的特性为多态性
        - 操作中使用相同函数进行统一处理
        - 绑定:建立函数调用和函数本体的关联
        - 先期绑定(静态绑定):绑定发生在程序运行前
        - 后期绑定(动态绑定):绑定发生在程序运行中
    - 虚函数
        - 实现动态绑定，基类函数加上virtual关键字
        - 具有继承性，基类函数为虚函数，派生类无论加不加virtual都是虚函数
        - 只有使用基类的指针或引用调用虚函数才能实现多态性，如果使用对象调用虚函数，则会调用基类的函数



 