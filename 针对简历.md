#### 流程（综合问题）
1. 自我介绍
    面试官您好，我是应聘者孙志豪，本科是浙江工业大学，硕士保研到了中国科学技术大学，专业方向都是物理相关。研究生课题做的是也是在Linux平台利用C++和python来设计科研算法与数据处理来探测中微子。。所以在此期间，我学习并使用了C++，MySQL，以及Linux平台上的相关命令与工具，比方说gdb，gcc，git，以及shell。后来不准备继续做科研了，就寻求转行做C++相关的软件开发工程师。在boss直聘上投递了相关的简历。
2. 公司了解
    主要业务方向是汽车这块的智能驾驶，新能源等等，包括软件研发和电子产品的研发，有全套的体系   
3. 职位了解
    linux平台上的，针对智能驾驶的C++软件研发。要求掌握C++，Linux操作系统相关经验，以及shell脚本等等。
4. 对城市的选择意向（北京，上海，成都，武汉，天津，西安）        
   - 可以去成都，上海，武汉
   - 测试开发必须要去北京,起初都需要去北京总部培训3-6个月
5. 期望薪资
    总包22w，要说明是年薪
6. 二面要做PPT
7. 代码量多少
    没有具体测算过，从时间上来算，从研一入学开始就在使用C++和python在linux平台做数据分析
8. 成绩绩点怎么样？英语分数?
    浙工大本科绩点3.68/5.0,中科大研究生绩点3.9/4.3，本科是在年级前10%，研究生学校没有统计，但是大致也在前10%
    英语六级成绩是518
9. 你认为你是一个什么样的人，性格是怎样的
    我个人认为我自身是一个善于钻研解决问题，也习惯与人沟通解决难题的人。同时抗压能力比较强。
    因为我是做物理方面的科研出身的，像我所在的高能粒子物理实验室平时针对的问题都比较难，基本上只能靠自己或者组内沟通解决。平时基本上是一周开两次组会，工作强度差不多是997.所以也算是在实验室里面锻炼出来的能力
10. 你周围老师和同学是怎么评价你的
    比较热心去帮人解决问题，就是有时候会说得太过于详细，没有太大必要。
    同时比较信守承诺，答应要完成的工作或是事情的时间点，从来没有错过
11. 你平时是怎么学习的,遇到困难怎么解决的    
    平时的学习基本上是靠自学查文献以及读书，因为我们的做高能粒子物理的方向没有其他人可以指导。遇到代码上或者物理上具体的问题的时候，可以请教师兄师姐。
12. 讲一下自己担任班干部的情况，以及自己的优势是啥
    本科的时候是天文社的副社长，在中科大是物理研究生会的干事。
13. 为什么不准备做科研了？
    这个问题比较复杂。我是在夏令营的时候保研到了中科大的天体物理，跟从一个在我们高能物理等离子体方向上非常强的一个老师，去做理论的分析。但是研一下的时候他就跳槽到其他学校去了，把我换给了一个新的导师。同时我的学习方向就完全更换了。新的导师的方向并不十分感兴趣。因为做科研很大程度上是要有兴趣支撑的，毕竟科研的困难不仅在于科研的课题，还有生活与现实的一些困难。于是我就不准备继续做科研了。
    并不是因为其他原因比如说怕吃苦不能抗压什么的，像我们做科研的，平时的作息都是997，甚至9107，一周要汇报2次组会。我个人来讲这些都可以接受，问题不大，但是一旦失去了前进的方向就真的很难再做下去了。

#### 反问
1. 公司常用的技术栈是什么？
2. 有标准的开发环境吗？是强制的吗？
3. 具体工作是什么？从计划到完成一项任务的工作流是什么样的？
4. 公司内部平时有指导或者技术交流活动吗?
5. 多久出结果？

 
#### 科研项目
1. 说一说你在学校做的项目
    - 我在学校做的项目总体上是偏向于科研算法和数据分析的。在Linux服务器上用，C++,python设计天文算法库，使用python,shell,make,root等数据分析及自动化工具，针对TB级别的粒子信号数据进行数据分析,从而达到探测中微子的目的。
    - 总体上是CPU计算密集型的
    - 科研项目的难点主要在于科研算法的实现
      - 首先在流程上，要针对整个物理流程的模型做出实现，比如一个高速移动的粒子撞击到大气上会发生什么物理现象。一般都是通过一些具体的公式来体现。这里面就需要用C++来实现一些天文的算法库，以及一些linux上的工具，比方说make，gcc，g++等。
      - 其次是在设计完成一个物理模型的框架后。就要进行对粒子的数据进行处理，筛选出合适的数据，并且尽量通过自动化脚本的方式来完成，应为我们处理的数据的量级大概是TB级别的。而这里就涉及了python的一些库比如说numpy，pandas，matplotlib可视化。
      - 最后是将数据放入模型中，看看模型是否满足预期，并进行修改。同时由于针对的是大批量的数据，还需要在物理和数学上做一些优化。比方说通过插值即取中间值或者别的近似值的方式来减少计算量，通过拟合来排除一些不符合规范的数据等等。
2. CPU密集型与IO密集型
   - CPU密集型
     - CPU密集型是指CPU使用率较高即计算密集型，而读写IO花费时间很短。
     - 一般情况下CPU密集型核心线程数 = CPU核数。或者直接使用多进程模型。因为这时多线程是没有意义的，反而会造成额外的线程切换的开销。
     - python下设置`export OMP_NUM_THREADS=1`,关闭python的多线程，是的每个python进程都保持单线程。避免了切换线程的开销。
     - python进程池`pool()`
   - IO密集型
     - IO密集型是指CPU使用率较低，而读写IO花费的时间较多，
     - I/O密集型核心线程数 = CPU核数 / （1-阻塞系数）。一般情况使用多线程，提高CPU的使用效率。
3. 为什么C++比python效率高
   - C++是编译执行的，而python是解释执行的
        C++编译器直接将源代码汇编再编译成机器码来执行，而python多了一层解释层，比如官方的python解释器是Cpython，用C\C++语言实现，也就是在运行过程中首先会被解释为C语言的规则，然后C语言会被编译为运行计算机相应的汇编，再由汇编翻译为二进制码由计算机执行。
   - python数据类型相对C++是动态的
        python的数据类型是在运行时才被推测出的，而对于C++编译型语言，变量的类型是在编译阶段确定的

#### C++
1. 面向对象和面向过程的区别
   - 面向过程
     - 面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数
     - 优点
        性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素
     - 缺点
        没有面向对象易维护、易复用、易扩展
   - 面对对象
     - 面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象。而继承，封装，多态等特性就是未来面向对象而设计的
     - 优点
        易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
     - 缺点
        性能比面向过程低
2. 介绍面向对象的三大特性，并且举例说明
    **三大特性：继承、封装和多态**
    - 继承
      - **让某种类型对象获得另一个类型对象的属性和方法**。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
      - 常见的继承：
        实现继承：指使用基类的属性和方法而无需额外编码的能力
        接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
    - 封装
        封装，也就是**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的**进行信息隐藏**，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。
    - 多态
      - **同一事物表现出不同事物的能力**，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。
      - 实现多态有二种方式：重写（override），重载（overload),**重载实现编译时多态，虚函数实现运行时多态**
3. 多态性底层的原理是什么？
   - 对于重载本质是静态绑定，而对于**重写本质是通过虚表和虚指针实现动态绑定**
   - 虚表
     - 虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表
     - 每个虚类，都有一个虚函数表；
     - 本质上是一个指针数组，其中元素为指向该类的虚成员函数的函数指针；
     - **属于类**，为该类的所有对象所共用；
     - 在**编译阶段就已经被确定**了
   - 虚指针
     - 在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针
     - 属于对象，是编译器自动添加的一个指针成员变量；
     - 虚表指针，在构造函数中初始化
   - 实现多态的过程
     - 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是指针数组，其中元素为指向该类的虚成员函数的函数指针
     - 每个对象中保存一个虚表指针vptr，指向对象所属类的虚表。构造对象的时候，基类先于派生类构造，基类构造函数初始化对象虚指针后，也会先将虚指针指向基类虚表，再在派生类构造中将虚指针指向派生类虚表
     - 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，会在自己的虚表中将此虚函数地址添加在后面